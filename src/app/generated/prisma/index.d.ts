
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Users
 * 
 */
export type Users = $Result.DefaultSelection<Prisma.$UsersPayload>
/**
 * Model Permissions
 * 
 */
export type Permissions = $Result.DefaultSelection<Prisma.$PermissionsPayload>
/**
 * Model Agency
 * 
 */
export type Agency = $Result.DefaultSelection<Prisma.$AgencyPayload>
/**
 * Model AgencySidebarOption
 * 
 */
export type AgencySidebarOption = $Result.DefaultSelection<Prisma.$AgencySidebarOptionPayload>
/**
 * Model SubAccounts
 * 
 */
export type SubAccounts = $Result.DefaultSelection<Prisma.$SubAccountsPayload>
/**
 * Model Pipelines
 * 
 */
export type Pipelines = $Result.DefaultSelection<Prisma.$PipelinesPayload>
/**
 * Model Triggers
 * 
 */
export type Triggers = $Result.DefaultSelection<Prisma.$TriggersPayload>
/**
 * Model Automations
 * 
 */
export type Automations = $Result.DefaultSelection<Prisma.$AutomationsPayload>
/**
 * Model AutomationInstance
 * 
 */
export type AutomationInstance = $Result.DefaultSelection<Prisma.$AutomationInstancePayload>
/**
 * Model Actions
 * 
 */
export type Actions = $Result.DefaultSelection<Prisma.$ActionsPayload>
/**
 * Model Contacts
 * 
 */
export type Contacts = $Result.DefaultSelection<Prisma.$ContactsPayload>
/**
 * Model Media
 * 
 */
export type Media = $Result.DefaultSelection<Prisma.$MediaPayload>
/**
 * Model Lane
 * 
 */
export type Lane = $Result.DefaultSelection<Prisma.$LanePayload>
/**
 * Model Tickets
 * 
 */
export type Tickets = $Result.DefaultSelection<Prisma.$TicketsPayload>
/**
 * Model Tags
 * 
 */
export type Tags = $Result.DefaultSelection<Prisma.$TagsPayload>
/**
 * Model SubAccountSidebarOption
 * 
 */
export type SubAccountSidebarOption = $Result.DefaultSelection<Prisma.$SubAccountSidebarOptionPayload>
/**
 * Model Invitations
 * 
 */
export type Invitations = $Result.DefaultSelection<Prisma.$InvitationsPayload>
/**
 * Model Funnels
 * 
 */
export type Funnels = $Result.DefaultSelection<Prisma.$FunnelsPayload>
/**
 * Model Notifications
 * 
 */
export type Notifications = $Result.DefaultSelection<Prisma.$NotificationsPayload>
/**
 * Model Subscriptions
 * 
 */
export type Subscriptions = $Result.DefaultSelection<Prisma.$SubscriptionsPayload>
/**
 * Model ClassName
 * 
 */
export type ClassName = $Result.DefaultSelection<Prisma.$ClassNamePayload>
/**
 * Model FunelPages
 * 
 */
export type FunelPages = $Result.DefaultSelection<Prisma.$FunelPagesPayload>
/**
 * Model AddOns
 * 
 */
export type AddOns = $Result.DefaultSelection<Prisma.$AddOnsPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  AGENCY_OWNER: 'AGENCY_OWNER',
  AGENCY_ADMIN: 'AGENCY_ADMIN',
  SUBACCOUNT_USER: 'SUBACCOUNT_USER',
  SUBACCOUNT_GUEST: 'SUBACCOUNT_GUEST'
};

export type Role = (typeof Role)[keyof typeof Role]


export const TriggerTypes: {
  CONTACT_FORM: 'CONTACT_FORM'
};

export type TriggerTypes = (typeof TriggerTypes)[keyof typeof TriggerTypes]


export const ActionType: {
  CREATE_CONTACT: 'CREATE_CONTACT'
};

export type ActionType = (typeof ActionType)[keyof typeof ActionType]


export const InvitationStatus: {
  ACCEPTED: 'ACCEPTED',
  REVOKED: 'REVOKED',
  PENDING: 'PENDING'
};

export type InvitationStatus = (typeof InvitationStatus)[keyof typeof InvitationStatus]


export const Plans: {
  price_10MhtQIld5Bk5htqogRZXP2e: 'price_10MhtQIld5Bk5htqogRZXP2e',
  price_10MhtcIld5Bk5htqx5CvF5nj: 'price_10MhtcIld5Bk5htqx5CvF5nj'
};

export type Plans = (typeof Plans)[keyof typeof Plans]


export const Icon: {
  settings: 'settings',
  chart: 'chart',
  calendar: 'calendar',
  check: 'check',
  chip: 'chip',
  compass: 'compass',
  database: 'database',
  flag: 'flag',
  name: 'name',
  info: 'info',
  link: 'link',
  lock: 'lock',
  messages: 'messages',
  notification: 'notification',
  payment: 'payment',
  power: 'power',
  receipt: 'receipt',
  sheild: 'sheild',
  star: 'star',
  tune: 'tune',
  videorecorder: 'videorecorder',
  wallet: 'wallet',
  warning: 'warning',
  headphones: 'headphones',
  send: 'send',
  pipeline: 'pipeline',
  person: 'person',
  category: 'category',
  contact: 'contact',
  clipboardIcon: 'clipboardIcon'
};

export type Icon = (typeof Icon)[keyof typeof Icon]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type TriggerTypes = $Enums.TriggerTypes

export const TriggerTypes: typeof $Enums.TriggerTypes

export type ActionType = $Enums.ActionType

export const ActionType: typeof $Enums.ActionType

export type InvitationStatus = $Enums.InvitationStatus

export const InvitationStatus: typeof $Enums.InvitationStatus

export type Plans = $Enums.Plans

export const Plans: typeof $Enums.Plans

export type Icon = $Enums.Icon

export const Icon: typeof $Enums.Icon

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.users.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.users.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.users`: Exposes CRUD operations for the **Users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.UsersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.permissions`: Exposes CRUD operations for the **Permissions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permissions
    * const permissions = await prisma.permissions.findMany()
    * ```
    */
  get permissions(): Prisma.PermissionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agency`: Exposes CRUD operations for the **Agency** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Agencies
    * const agencies = await prisma.agency.findMany()
    * ```
    */
  get agency(): Prisma.AgencyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agencySidebarOption`: Exposes CRUD operations for the **AgencySidebarOption** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgencySidebarOptions
    * const agencySidebarOptions = await prisma.agencySidebarOption.findMany()
    * ```
    */
  get agencySidebarOption(): Prisma.AgencySidebarOptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subAccounts`: Exposes CRUD operations for the **SubAccounts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubAccounts
    * const subAccounts = await prisma.subAccounts.findMany()
    * ```
    */
  get subAccounts(): Prisma.SubAccountsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pipelines`: Exposes CRUD operations for the **Pipelines** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pipelines
    * const pipelines = await prisma.pipelines.findMany()
    * ```
    */
  get pipelines(): Prisma.PipelinesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.triggers`: Exposes CRUD operations for the **Triggers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Triggers
    * const triggers = await prisma.triggers.findMany()
    * ```
    */
  get triggers(): Prisma.TriggersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.automations`: Exposes CRUD operations for the **Automations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Automations
    * const automations = await prisma.automations.findMany()
    * ```
    */
  get automations(): Prisma.AutomationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.automationInstance`: Exposes CRUD operations for the **AutomationInstance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AutomationInstances
    * const automationInstances = await prisma.automationInstance.findMany()
    * ```
    */
  get automationInstance(): Prisma.AutomationInstanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.actions`: Exposes CRUD operations for the **Actions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Actions
    * const actions = await prisma.actions.findMany()
    * ```
    */
  get actions(): Prisma.ActionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contacts`: Exposes CRUD operations for the **Contacts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contacts
    * const contacts = await prisma.contacts.findMany()
    * ```
    */
  get contacts(): Prisma.ContactsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.media`: Exposes CRUD operations for the **Media** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Media
    * const media = await prisma.media.findMany()
    * ```
    */
  get media(): Prisma.MediaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lane`: Exposes CRUD operations for the **Lane** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lanes
    * const lanes = await prisma.lane.findMany()
    * ```
    */
  get lane(): Prisma.LaneDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tickets`: Exposes CRUD operations for the **Tickets** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tickets
    * const tickets = await prisma.tickets.findMany()
    * ```
    */
  get tickets(): Prisma.TicketsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tags`: Exposes CRUD operations for the **Tags** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tags.findMany()
    * ```
    */
  get tags(): Prisma.TagsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subAccountSidebarOption`: Exposes CRUD operations for the **SubAccountSidebarOption** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubAccountSidebarOptions
    * const subAccountSidebarOptions = await prisma.subAccountSidebarOption.findMany()
    * ```
    */
  get subAccountSidebarOption(): Prisma.SubAccountSidebarOptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invitations`: Exposes CRUD operations for the **Invitations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invitations
    * const invitations = await prisma.invitations.findMany()
    * ```
    */
  get invitations(): Prisma.InvitationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.funnels`: Exposes CRUD operations for the **Funnels** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Funnels
    * const funnels = await prisma.funnels.findMany()
    * ```
    */
  get funnels(): Prisma.FunnelsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notifications`: Exposes CRUD operations for the **Notifications** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notifications.findMany()
    * ```
    */
  get notifications(): Prisma.NotificationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subscriptions`: Exposes CRUD operations for the **Subscriptions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscriptions.findMany()
    * ```
    */
  get subscriptions(): Prisma.SubscriptionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.className`: Exposes CRUD operations for the **ClassName** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClassNames
    * const classNames = await prisma.className.findMany()
    * ```
    */
  get className(): Prisma.ClassNameDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.funelPages`: Exposes CRUD operations for the **FunelPages** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FunelPages
    * const funelPages = await prisma.funelPages.findMany()
    * ```
    */
  get funelPages(): Prisma.FunelPagesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.addOns`: Exposes CRUD operations for the **AddOns** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AddOns
    * const addOns = await prisma.addOns.findMany()
    * ```
    */
  get addOns(): Prisma.AddOnsDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.10.1
   * Query Engine version: 9b628578b3b7cae625e8c927178f15a170e74a9c
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Users: 'Users',
    Permissions: 'Permissions',
    Agency: 'Agency',
    AgencySidebarOption: 'AgencySidebarOption',
    SubAccounts: 'SubAccounts',
    Pipelines: 'Pipelines',
    Triggers: 'Triggers',
    Automations: 'Automations',
    AutomationInstance: 'AutomationInstance',
    Actions: 'Actions',
    Contacts: 'Contacts',
    Media: 'Media',
    Lane: 'Lane',
    Tickets: 'Tickets',
    Tags: 'Tags',
    SubAccountSidebarOption: 'SubAccountSidebarOption',
    Invitations: 'Invitations',
    Funnels: 'Funnels',
    Notifications: 'Notifications',
    Subscriptions: 'Subscriptions',
    ClassName: 'ClassName',
    FunelPages: 'FunelPages',
    AddOns: 'AddOns'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "users" | "permissions" | "agency" | "agencySidebarOption" | "subAccounts" | "pipelines" | "triggers" | "automations" | "automationInstance" | "actions" | "contacts" | "media" | "lane" | "tickets" | "tags" | "subAccountSidebarOption" | "invitations" | "funnels" | "notifications" | "subscriptions" | "className" | "funelPages" | "addOns"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Users: {
        payload: Prisma.$UsersPayload<ExtArgs>
        fields: Prisma.UsersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          findFirst: {
            args: Prisma.UsersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          findMany: {
            args: Prisma.UsersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>[]
          }
          create: {
            args: Prisma.UsersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          createMany: {
            args: Prisma.UsersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>[]
          }
          delete: {
            args: Prisma.UsersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          update: {
            args: Prisma.UsersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          deleteMany: {
            args: Prisma.UsersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UsersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>[]
          }
          upsert: {
            args: Prisma.UsersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.UsersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      Permissions: {
        payload: Prisma.$PermissionsPayload<ExtArgs>
        fields: Prisma.PermissionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PermissionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PermissionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionsPayload>
          }
          findFirst: {
            args: Prisma.PermissionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PermissionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionsPayload>
          }
          findMany: {
            args: Prisma.PermissionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionsPayload>[]
          }
          create: {
            args: Prisma.PermissionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionsPayload>
          }
          createMany: {
            args: Prisma.PermissionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PermissionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionsPayload>[]
          }
          delete: {
            args: Prisma.PermissionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionsPayload>
          }
          update: {
            args: Prisma.PermissionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionsPayload>
          }
          deleteMany: {
            args: Prisma.PermissionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PermissionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PermissionsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionsPayload>[]
          }
          upsert: {
            args: Prisma.PermissionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionsPayload>
          }
          aggregate: {
            args: Prisma.PermissionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermissions>
          }
          groupBy: {
            args: Prisma.PermissionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PermissionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.PermissionsCountArgs<ExtArgs>
            result: $Utils.Optional<PermissionsCountAggregateOutputType> | number
          }
        }
      }
      Agency: {
        payload: Prisma.$AgencyPayload<ExtArgs>
        fields: Prisma.AgencyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgencyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgencyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>
          }
          findFirst: {
            args: Prisma.AgencyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgencyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>
          }
          findMany: {
            args: Prisma.AgencyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>[]
          }
          create: {
            args: Prisma.AgencyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>
          }
          createMany: {
            args: Prisma.AgencyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgencyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>[]
          }
          delete: {
            args: Prisma.AgencyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>
          }
          update: {
            args: Prisma.AgencyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>
          }
          deleteMany: {
            args: Prisma.AgencyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgencyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AgencyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>[]
          }
          upsert: {
            args: Prisma.AgencyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencyPayload>
          }
          aggregate: {
            args: Prisma.AgencyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgency>
          }
          groupBy: {
            args: Prisma.AgencyGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgencyGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgencyCountArgs<ExtArgs>
            result: $Utils.Optional<AgencyCountAggregateOutputType> | number
          }
        }
      }
      AgencySidebarOption: {
        payload: Prisma.$AgencySidebarOptionPayload<ExtArgs>
        fields: Prisma.AgencySidebarOptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgencySidebarOptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencySidebarOptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgencySidebarOptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencySidebarOptionPayload>
          }
          findFirst: {
            args: Prisma.AgencySidebarOptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencySidebarOptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgencySidebarOptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencySidebarOptionPayload>
          }
          findMany: {
            args: Prisma.AgencySidebarOptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencySidebarOptionPayload>[]
          }
          create: {
            args: Prisma.AgencySidebarOptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencySidebarOptionPayload>
          }
          createMany: {
            args: Prisma.AgencySidebarOptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgencySidebarOptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencySidebarOptionPayload>[]
          }
          delete: {
            args: Prisma.AgencySidebarOptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencySidebarOptionPayload>
          }
          update: {
            args: Prisma.AgencySidebarOptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencySidebarOptionPayload>
          }
          deleteMany: {
            args: Prisma.AgencySidebarOptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgencySidebarOptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AgencySidebarOptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencySidebarOptionPayload>[]
          }
          upsert: {
            args: Prisma.AgencySidebarOptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgencySidebarOptionPayload>
          }
          aggregate: {
            args: Prisma.AgencySidebarOptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgencySidebarOption>
          }
          groupBy: {
            args: Prisma.AgencySidebarOptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgencySidebarOptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgencySidebarOptionCountArgs<ExtArgs>
            result: $Utils.Optional<AgencySidebarOptionCountAggregateOutputType> | number
          }
        }
      }
      SubAccounts: {
        payload: Prisma.$SubAccountsPayload<ExtArgs>
        fields: Prisma.SubAccountsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubAccountsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubAccountsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountsPayload>
          }
          findFirst: {
            args: Prisma.SubAccountsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubAccountsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountsPayload>
          }
          findMany: {
            args: Prisma.SubAccountsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountsPayload>[]
          }
          create: {
            args: Prisma.SubAccountsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountsPayload>
          }
          createMany: {
            args: Prisma.SubAccountsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubAccountsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountsPayload>[]
          }
          delete: {
            args: Prisma.SubAccountsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountsPayload>
          }
          update: {
            args: Prisma.SubAccountsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountsPayload>
          }
          deleteMany: {
            args: Prisma.SubAccountsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubAccountsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubAccountsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountsPayload>[]
          }
          upsert: {
            args: Prisma.SubAccountsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountsPayload>
          }
          aggregate: {
            args: Prisma.SubAccountsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubAccounts>
          }
          groupBy: {
            args: Prisma.SubAccountsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubAccountsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubAccountsCountArgs<ExtArgs>
            result: $Utils.Optional<SubAccountsCountAggregateOutputType> | number
          }
        }
      }
      Pipelines: {
        payload: Prisma.$PipelinesPayload<ExtArgs>
        fields: Prisma.PipelinesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PipelinesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PipelinesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinesPayload>
          }
          findFirst: {
            args: Prisma.PipelinesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PipelinesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinesPayload>
          }
          findMany: {
            args: Prisma.PipelinesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinesPayload>[]
          }
          create: {
            args: Prisma.PipelinesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinesPayload>
          }
          createMany: {
            args: Prisma.PipelinesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PipelinesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinesPayload>[]
          }
          delete: {
            args: Prisma.PipelinesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinesPayload>
          }
          update: {
            args: Prisma.PipelinesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinesPayload>
          }
          deleteMany: {
            args: Prisma.PipelinesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PipelinesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PipelinesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinesPayload>[]
          }
          upsert: {
            args: Prisma.PipelinesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinesPayload>
          }
          aggregate: {
            args: Prisma.PipelinesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePipelines>
          }
          groupBy: {
            args: Prisma.PipelinesGroupByArgs<ExtArgs>
            result: $Utils.Optional<PipelinesGroupByOutputType>[]
          }
          count: {
            args: Prisma.PipelinesCountArgs<ExtArgs>
            result: $Utils.Optional<PipelinesCountAggregateOutputType> | number
          }
        }
      }
      Triggers: {
        payload: Prisma.$TriggersPayload<ExtArgs>
        fields: Prisma.TriggersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TriggersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriggersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TriggersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriggersPayload>
          }
          findFirst: {
            args: Prisma.TriggersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriggersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TriggersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriggersPayload>
          }
          findMany: {
            args: Prisma.TriggersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriggersPayload>[]
          }
          create: {
            args: Prisma.TriggersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriggersPayload>
          }
          createMany: {
            args: Prisma.TriggersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TriggersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriggersPayload>[]
          }
          delete: {
            args: Prisma.TriggersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriggersPayload>
          }
          update: {
            args: Prisma.TriggersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriggersPayload>
          }
          deleteMany: {
            args: Prisma.TriggersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TriggersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TriggersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriggersPayload>[]
          }
          upsert: {
            args: Prisma.TriggersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TriggersPayload>
          }
          aggregate: {
            args: Prisma.TriggersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTriggers>
          }
          groupBy: {
            args: Prisma.TriggersGroupByArgs<ExtArgs>
            result: $Utils.Optional<TriggersGroupByOutputType>[]
          }
          count: {
            args: Prisma.TriggersCountArgs<ExtArgs>
            result: $Utils.Optional<TriggersCountAggregateOutputType> | number
          }
        }
      }
      Automations: {
        payload: Prisma.$AutomationsPayload<ExtArgs>
        fields: Prisma.AutomationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AutomationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AutomationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationsPayload>
          }
          findFirst: {
            args: Prisma.AutomationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AutomationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationsPayload>
          }
          findMany: {
            args: Prisma.AutomationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationsPayload>[]
          }
          create: {
            args: Prisma.AutomationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationsPayload>
          }
          createMany: {
            args: Prisma.AutomationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AutomationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationsPayload>[]
          }
          delete: {
            args: Prisma.AutomationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationsPayload>
          }
          update: {
            args: Prisma.AutomationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationsPayload>
          }
          deleteMany: {
            args: Prisma.AutomationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AutomationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AutomationsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationsPayload>[]
          }
          upsert: {
            args: Prisma.AutomationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationsPayload>
          }
          aggregate: {
            args: Prisma.AutomationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAutomations>
          }
          groupBy: {
            args: Prisma.AutomationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AutomationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.AutomationsCountArgs<ExtArgs>
            result: $Utils.Optional<AutomationsCountAggregateOutputType> | number
          }
        }
      }
      AutomationInstance: {
        payload: Prisma.$AutomationInstancePayload<ExtArgs>
        fields: Prisma.AutomationInstanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AutomationInstanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationInstancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AutomationInstanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationInstancePayload>
          }
          findFirst: {
            args: Prisma.AutomationInstanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationInstancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AutomationInstanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationInstancePayload>
          }
          findMany: {
            args: Prisma.AutomationInstanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationInstancePayload>[]
          }
          create: {
            args: Prisma.AutomationInstanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationInstancePayload>
          }
          createMany: {
            args: Prisma.AutomationInstanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AutomationInstanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationInstancePayload>[]
          }
          delete: {
            args: Prisma.AutomationInstanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationInstancePayload>
          }
          update: {
            args: Prisma.AutomationInstanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationInstancePayload>
          }
          deleteMany: {
            args: Prisma.AutomationInstanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AutomationInstanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AutomationInstanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationInstancePayload>[]
          }
          upsert: {
            args: Prisma.AutomationInstanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutomationInstancePayload>
          }
          aggregate: {
            args: Prisma.AutomationInstanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAutomationInstance>
          }
          groupBy: {
            args: Prisma.AutomationInstanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<AutomationInstanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.AutomationInstanceCountArgs<ExtArgs>
            result: $Utils.Optional<AutomationInstanceCountAggregateOutputType> | number
          }
        }
      }
      Actions: {
        payload: Prisma.$ActionsPayload<ExtArgs>
        fields: Prisma.ActionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionsPayload>
          }
          findFirst: {
            args: Prisma.ActionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionsPayload>
          }
          findMany: {
            args: Prisma.ActionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionsPayload>[]
          }
          create: {
            args: Prisma.ActionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionsPayload>
          }
          createMany: {
            args: Prisma.ActionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionsPayload>[]
          }
          delete: {
            args: Prisma.ActionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionsPayload>
          }
          update: {
            args: Prisma.ActionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionsPayload>
          }
          deleteMany: {
            args: Prisma.ActionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ActionsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionsPayload>[]
          }
          upsert: {
            args: Prisma.ActionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionsPayload>
          }
          aggregate: {
            args: Prisma.ActionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActions>
          }
          groupBy: {
            args: Prisma.ActionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActionsCountArgs<ExtArgs>
            result: $Utils.Optional<ActionsCountAggregateOutputType> | number
          }
        }
      }
      Contacts: {
        payload: Prisma.$ContactsPayload<ExtArgs>
        fields: Prisma.ContactsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactsPayload>
          }
          findFirst: {
            args: Prisma.ContactsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactsPayload>
          }
          findMany: {
            args: Prisma.ContactsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactsPayload>[]
          }
          create: {
            args: Prisma.ContactsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactsPayload>
          }
          createMany: {
            args: Prisma.ContactsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContactsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactsPayload>[]
          }
          delete: {
            args: Prisma.ContactsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactsPayload>
          }
          update: {
            args: Prisma.ContactsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactsPayload>
          }
          deleteMany: {
            args: Prisma.ContactsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContactsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactsPayload>[]
          }
          upsert: {
            args: Prisma.ContactsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactsPayload>
          }
          aggregate: {
            args: Prisma.ContactsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContacts>
          }
          groupBy: {
            args: Prisma.ContactsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactsCountArgs<ExtArgs>
            result: $Utils.Optional<ContactsCountAggregateOutputType> | number
          }
        }
      }
      Media: {
        payload: Prisma.$MediaPayload<ExtArgs>
        fields: Prisma.MediaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MediaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MediaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          findFirst: {
            args: Prisma.MediaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MediaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          findMany: {
            args: Prisma.MediaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>[]
          }
          create: {
            args: Prisma.MediaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          createMany: {
            args: Prisma.MediaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MediaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>[]
          }
          delete: {
            args: Prisma.MediaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          update: {
            args: Prisma.MediaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          deleteMany: {
            args: Prisma.MediaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MediaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MediaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>[]
          }
          upsert: {
            args: Prisma.MediaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          aggregate: {
            args: Prisma.MediaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedia>
          }
          groupBy: {
            args: Prisma.MediaGroupByArgs<ExtArgs>
            result: $Utils.Optional<MediaGroupByOutputType>[]
          }
          count: {
            args: Prisma.MediaCountArgs<ExtArgs>
            result: $Utils.Optional<MediaCountAggregateOutputType> | number
          }
        }
      }
      Lane: {
        payload: Prisma.$LanePayload<ExtArgs>
        fields: Prisma.LaneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LaneFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LaneFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanePayload>
          }
          findFirst: {
            args: Prisma.LaneFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LaneFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanePayload>
          }
          findMany: {
            args: Prisma.LaneFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanePayload>[]
          }
          create: {
            args: Prisma.LaneCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanePayload>
          }
          createMany: {
            args: Prisma.LaneCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LaneCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanePayload>[]
          }
          delete: {
            args: Prisma.LaneDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanePayload>
          }
          update: {
            args: Prisma.LaneUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanePayload>
          }
          deleteMany: {
            args: Prisma.LaneDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LaneUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LaneUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanePayload>[]
          }
          upsert: {
            args: Prisma.LaneUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LanePayload>
          }
          aggregate: {
            args: Prisma.LaneAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLane>
          }
          groupBy: {
            args: Prisma.LaneGroupByArgs<ExtArgs>
            result: $Utils.Optional<LaneGroupByOutputType>[]
          }
          count: {
            args: Prisma.LaneCountArgs<ExtArgs>
            result: $Utils.Optional<LaneCountAggregateOutputType> | number
          }
        }
      }
      Tickets: {
        payload: Prisma.$TicketsPayload<ExtArgs>
        fields: Prisma.TicketsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketsPayload>
          }
          findFirst: {
            args: Prisma.TicketsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketsPayload>
          }
          findMany: {
            args: Prisma.TicketsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketsPayload>[]
          }
          create: {
            args: Prisma.TicketsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketsPayload>
          }
          createMany: {
            args: Prisma.TicketsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TicketsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketsPayload>[]
          }
          delete: {
            args: Prisma.TicketsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketsPayload>
          }
          update: {
            args: Prisma.TicketsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketsPayload>
          }
          deleteMany: {
            args: Prisma.TicketsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TicketsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketsPayload>[]
          }
          upsert: {
            args: Prisma.TicketsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketsPayload>
          }
          aggregate: {
            args: Prisma.TicketsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTickets>
          }
          groupBy: {
            args: Prisma.TicketsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketsGroupByOutputType>[]
          }
          count: {
            args: Prisma.TicketsCountArgs<ExtArgs>
            result: $Utils.Optional<TicketsCountAggregateOutputType> | number
          }
        }
      }
      Tags: {
        payload: Prisma.$TagsPayload<ExtArgs>
        fields: Prisma.TagsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload>
          }
          findFirst: {
            args: Prisma.TagsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload>
          }
          findMany: {
            args: Prisma.TagsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload>[]
          }
          create: {
            args: Prisma.TagsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload>
          }
          createMany: {
            args: Prisma.TagsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TagsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload>[]
          }
          delete: {
            args: Prisma.TagsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload>
          }
          update: {
            args: Prisma.TagsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload>
          }
          deleteMany: {
            args: Prisma.TagsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TagsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TagsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload>[]
          }
          upsert: {
            args: Prisma.TagsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload>
          }
          aggregate: {
            args: Prisma.TagsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTags>
          }
          groupBy: {
            args: Prisma.TagsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagsGroupByOutputType>[]
          }
          count: {
            args: Prisma.TagsCountArgs<ExtArgs>
            result: $Utils.Optional<TagsCountAggregateOutputType> | number
          }
        }
      }
      SubAccountSidebarOption: {
        payload: Prisma.$SubAccountSidebarOptionPayload<ExtArgs>
        fields: Prisma.SubAccountSidebarOptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubAccountSidebarOptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountSidebarOptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubAccountSidebarOptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountSidebarOptionPayload>
          }
          findFirst: {
            args: Prisma.SubAccountSidebarOptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountSidebarOptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubAccountSidebarOptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountSidebarOptionPayload>
          }
          findMany: {
            args: Prisma.SubAccountSidebarOptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountSidebarOptionPayload>[]
          }
          create: {
            args: Prisma.SubAccountSidebarOptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountSidebarOptionPayload>
          }
          createMany: {
            args: Prisma.SubAccountSidebarOptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubAccountSidebarOptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountSidebarOptionPayload>[]
          }
          delete: {
            args: Prisma.SubAccountSidebarOptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountSidebarOptionPayload>
          }
          update: {
            args: Prisma.SubAccountSidebarOptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountSidebarOptionPayload>
          }
          deleteMany: {
            args: Prisma.SubAccountSidebarOptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubAccountSidebarOptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubAccountSidebarOptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountSidebarOptionPayload>[]
          }
          upsert: {
            args: Prisma.SubAccountSidebarOptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubAccountSidebarOptionPayload>
          }
          aggregate: {
            args: Prisma.SubAccountSidebarOptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubAccountSidebarOption>
          }
          groupBy: {
            args: Prisma.SubAccountSidebarOptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubAccountSidebarOptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubAccountSidebarOptionCountArgs<ExtArgs>
            result: $Utils.Optional<SubAccountSidebarOptionCountAggregateOutputType> | number
          }
        }
      }
      Invitations: {
        payload: Prisma.$InvitationsPayload<ExtArgs>
        fields: Prisma.InvitationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvitationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvitationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationsPayload>
          }
          findFirst: {
            args: Prisma.InvitationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvitationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationsPayload>
          }
          findMany: {
            args: Prisma.InvitationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationsPayload>[]
          }
          create: {
            args: Prisma.InvitationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationsPayload>
          }
          createMany: {
            args: Prisma.InvitationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvitationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationsPayload>[]
          }
          delete: {
            args: Prisma.InvitationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationsPayload>
          }
          update: {
            args: Prisma.InvitationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationsPayload>
          }
          deleteMany: {
            args: Prisma.InvitationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvitationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvitationsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationsPayload>[]
          }
          upsert: {
            args: Prisma.InvitationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationsPayload>
          }
          aggregate: {
            args: Prisma.InvitationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvitations>
          }
          groupBy: {
            args: Prisma.InvitationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvitationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvitationsCountArgs<ExtArgs>
            result: $Utils.Optional<InvitationsCountAggregateOutputType> | number
          }
        }
      }
      Funnels: {
        payload: Prisma.$FunnelsPayload<ExtArgs>
        fields: Prisma.FunnelsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FunnelsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FunnelsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelsPayload>
          }
          findFirst: {
            args: Prisma.FunnelsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FunnelsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelsPayload>
          }
          findMany: {
            args: Prisma.FunnelsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelsPayload>[]
          }
          create: {
            args: Prisma.FunnelsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelsPayload>
          }
          createMany: {
            args: Prisma.FunnelsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FunnelsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelsPayload>[]
          }
          delete: {
            args: Prisma.FunnelsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelsPayload>
          }
          update: {
            args: Prisma.FunnelsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelsPayload>
          }
          deleteMany: {
            args: Prisma.FunnelsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FunnelsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FunnelsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelsPayload>[]
          }
          upsert: {
            args: Prisma.FunnelsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunnelsPayload>
          }
          aggregate: {
            args: Prisma.FunnelsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFunnels>
          }
          groupBy: {
            args: Prisma.FunnelsGroupByArgs<ExtArgs>
            result: $Utils.Optional<FunnelsGroupByOutputType>[]
          }
          count: {
            args: Prisma.FunnelsCountArgs<ExtArgs>
            result: $Utils.Optional<FunnelsCountAggregateOutputType> | number
          }
        }
      }
      Notifications: {
        payload: Prisma.$NotificationsPayload<ExtArgs>
        fields: Prisma.NotificationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>
          }
          findFirst: {
            args: Prisma.NotificationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>
          }
          findMany: {
            args: Prisma.NotificationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>[]
          }
          create: {
            args: Prisma.NotificationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>
          }
          createMany: {
            args: Prisma.NotificationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>[]
          }
          delete: {
            args: Prisma.NotificationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>
          }
          update: {
            args: Prisma.NotificationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>
          }
          deleteMany: {
            args: Prisma.NotificationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>[]
          }
          upsert: {
            args: Prisma.NotificationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>
          }
          aggregate: {
            args: Prisma.NotificationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotifications>
          }
          groupBy: {
            args: Prisma.NotificationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationsCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationsCountAggregateOutputType> | number
          }
        }
      }
      Subscriptions: {
        payload: Prisma.$SubscriptionsPayload<ExtArgs>
        fields: Prisma.SubscriptionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionsPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionsPayload>
          }
          findMany: {
            args: Prisma.SubscriptionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionsPayload>[]
          }
          create: {
            args: Prisma.SubscriptionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionsPayload>
          }
          createMany: {
            args: Prisma.SubscriptionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionsPayload>[]
          }
          delete: {
            args: Prisma.SubscriptionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionsPayload>
          }
          update: {
            args: Prisma.SubscriptionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionsPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubscriptionsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionsPayload>[]
          }
          upsert: {
            args: Prisma.SubscriptionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionsPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscriptions>
          }
          groupBy: {
            args: Prisma.SubscriptionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionsCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionsCountAggregateOutputType> | number
          }
        }
      }
      ClassName: {
        payload: Prisma.$ClassNamePayload<ExtArgs>
        fields: Prisma.ClassNameFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClassNameFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassNamePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClassNameFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassNamePayload>
          }
          findFirst: {
            args: Prisma.ClassNameFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassNamePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClassNameFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassNamePayload>
          }
          findMany: {
            args: Prisma.ClassNameFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassNamePayload>[]
          }
          create: {
            args: Prisma.ClassNameCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassNamePayload>
          }
          createMany: {
            args: Prisma.ClassNameCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClassNameCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassNamePayload>[]
          }
          delete: {
            args: Prisma.ClassNameDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassNamePayload>
          }
          update: {
            args: Prisma.ClassNameUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassNamePayload>
          }
          deleteMany: {
            args: Prisma.ClassNameDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClassNameUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClassNameUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassNamePayload>[]
          }
          upsert: {
            args: Prisma.ClassNameUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassNamePayload>
          }
          aggregate: {
            args: Prisma.ClassNameAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClassName>
          }
          groupBy: {
            args: Prisma.ClassNameGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClassNameGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClassNameCountArgs<ExtArgs>
            result: $Utils.Optional<ClassNameCountAggregateOutputType> | number
          }
        }
      }
      FunelPages: {
        payload: Prisma.$FunelPagesPayload<ExtArgs>
        fields: Prisma.FunelPagesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FunelPagesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunelPagesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FunelPagesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunelPagesPayload>
          }
          findFirst: {
            args: Prisma.FunelPagesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunelPagesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FunelPagesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunelPagesPayload>
          }
          findMany: {
            args: Prisma.FunelPagesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunelPagesPayload>[]
          }
          create: {
            args: Prisma.FunelPagesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunelPagesPayload>
          }
          createMany: {
            args: Prisma.FunelPagesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FunelPagesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunelPagesPayload>[]
          }
          delete: {
            args: Prisma.FunelPagesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunelPagesPayload>
          }
          update: {
            args: Prisma.FunelPagesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunelPagesPayload>
          }
          deleteMany: {
            args: Prisma.FunelPagesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FunelPagesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FunelPagesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunelPagesPayload>[]
          }
          upsert: {
            args: Prisma.FunelPagesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FunelPagesPayload>
          }
          aggregate: {
            args: Prisma.FunelPagesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFunelPages>
          }
          groupBy: {
            args: Prisma.FunelPagesGroupByArgs<ExtArgs>
            result: $Utils.Optional<FunelPagesGroupByOutputType>[]
          }
          count: {
            args: Prisma.FunelPagesCountArgs<ExtArgs>
            result: $Utils.Optional<FunelPagesCountAggregateOutputType> | number
          }
        }
      }
      AddOns: {
        payload: Prisma.$AddOnsPayload<ExtArgs>
        fields: Prisma.AddOnsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AddOnsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddOnsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AddOnsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddOnsPayload>
          }
          findFirst: {
            args: Prisma.AddOnsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddOnsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AddOnsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddOnsPayload>
          }
          findMany: {
            args: Prisma.AddOnsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddOnsPayload>[]
          }
          create: {
            args: Prisma.AddOnsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddOnsPayload>
          }
          createMany: {
            args: Prisma.AddOnsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AddOnsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddOnsPayload>[]
          }
          delete: {
            args: Prisma.AddOnsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddOnsPayload>
          }
          update: {
            args: Prisma.AddOnsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddOnsPayload>
          }
          deleteMany: {
            args: Prisma.AddOnsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AddOnsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AddOnsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddOnsPayload>[]
          }
          upsert: {
            args: Prisma.AddOnsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddOnsPayload>
          }
          aggregate: {
            args: Prisma.AddOnsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAddOns>
          }
          groupBy: {
            args: Prisma.AddOnsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AddOnsGroupByOutputType>[]
          }
          count: {
            args: Prisma.AddOnsCountArgs<ExtArgs>
            result: $Utils.Optional<AddOnsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    users?: UsersOmit
    permissions?: PermissionsOmit
    agency?: AgencyOmit
    agencySidebarOption?: AgencySidebarOptionOmit
    subAccounts?: SubAccountsOmit
    pipelines?: PipelinesOmit
    triggers?: TriggersOmit
    automations?: AutomationsOmit
    automationInstance?: AutomationInstanceOmit
    actions?: ActionsOmit
    contacts?: ContactsOmit
    media?: MediaOmit
    lane?: LaneOmit
    tickets?: TicketsOmit
    tags?: TagsOmit
    subAccountSidebarOption?: SubAccountSidebarOptionOmit
    invitations?: InvitationsOmit
    funnels?: FunnelsOmit
    notifications?: NotificationsOmit
    subscriptions?: SubscriptionsOmit
    className?: ClassNameOmit
    funelPages?: FunelPagesOmit
    addOns?: AddOnsOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    Permission: number
    Ticket: number
    Notification: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Permission?: boolean | UsersCountOutputTypeCountPermissionArgs
    Ticket?: boolean | UsersCountOutputTypeCountTicketArgs
    Notification?: boolean | UsersCountOutputTypeCountNotificationArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountPermissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountTicketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountNotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationsWhereInput
  }


  /**
   * Count Type AgencyCountOutputType
   */

  export type AgencyCountOutputType = {
    user: number
    SubAccount: number
    SidebarOption: number
    Invitation: number
    Notification: number
    AddOns: number
  }

  export type AgencyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AgencyCountOutputTypeCountUserArgs
    SubAccount?: boolean | AgencyCountOutputTypeCountSubAccountArgs
    SidebarOption?: boolean | AgencyCountOutputTypeCountSidebarOptionArgs
    Invitation?: boolean | AgencyCountOutputTypeCountInvitationArgs
    Notification?: boolean | AgencyCountOutputTypeCountNotificationArgs
    AddOns?: boolean | AgencyCountOutputTypeCountAddOnsArgs
  }

  // Custom InputTypes
  /**
   * AgencyCountOutputType without action
   */
  export type AgencyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencyCountOutputType
     */
    select?: AgencyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AgencyCountOutputType without action
   */
  export type AgencyCountOutputTypeCountUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersWhereInput
  }

  /**
   * AgencyCountOutputType without action
   */
  export type AgencyCountOutputTypeCountSubAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubAccountsWhereInput
  }

  /**
   * AgencyCountOutputType without action
   */
  export type AgencyCountOutputTypeCountSidebarOptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencySidebarOptionWhereInput
  }

  /**
   * AgencyCountOutputType without action
   */
  export type AgencyCountOutputTypeCountInvitationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvitationsWhereInput
  }

  /**
   * AgencyCountOutputType without action
   */
  export type AgencyCountOutputTypeCountNotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationsWhereInput
  }

  /**
   * AgencyCountOutputType without action
   */
  export type AgencyCountOutputTypeCountAddOnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddOnsWhereInput
  }


  /**
   * Count Type SubAccountsCountOutputType
   */

  export type SubAccountsCountOutputType = {
    SidebarOption: number
    Permissions: number
    Funnels: number
    Media: number
    Contact: number
    Trigger: number
    Automation: number
    Pipeline: number
    Tags: number
    Notification: number
    SubAccountSidebarOption: number
  }

  export type SubAccountsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SidebarOption?: boolean | SubAccountsCountOutputTypeCountSidebarOptionArgs
    Permissions?: boolean | SubAccountsCountOutputTypeCountPermissionsArgs
    Funnels?: boolean | SubAccountsCountOutputTypeCountFunnelsArgs
    Media?: boolean | SubAccountsCountOutputTypeCountMediaArgs
    Contact?: boolean | SubAccountsCountOutputTypeCountContactArgs
    Trigger?: boolean | SubAccountsCountOutputTypeCountTriggerArgs
    Automation?: boolean | SubAccountsCountOutputTypeCountAutomationArgs
    Pipeline?: boolean | SubAccountsCountOutputTypeCountPipelineArgs
    Tags?: boolean | SubAccountsCountOutputTypeCountTagsArgs
    Notification?: boolean | SubAccountsCountOutputTypeCountNotificationArgs
    SubAccountSidebarOption?: boolean | SubAccountsCountOutputTypeCountSubAccountSidebarOptionArgs
  }

  // Custom InputTypes
  /**
   * SubAccountsCountOutputType without action
   */
  export type SubAccountsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccountsCountOutputType
     */
    select?: SubAccountsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubAccountsCountOutputType without action
   */
  export type SubAccountsCountOutputTypeCountSidebarOptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencySidebarOptionWhereInput
  }

  /**
   * SubAccountsCountOutputType without action
   */
  export type SubAccountsCountOutputTypeCountPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionsWhereInput
  }

  /**
   * SubAccountsCountOutputType without action
   */
  export type SubAccountsCountOutputTypeCountFunnelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FunnelsWhereInput
  }

  /**
   * SubAccountsCountOutputType without action
   */
  export type SubAccountsCountOutputTypeCountMediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaWhereInput
  }

  /**
   * SubAccountsCountOutputType without action
   */
  export type SubAccountsCountOutputTypeCountContactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactsWhereInput
  }

  /**
   * SubAccountsCountOutputType without action
   */
  export type SubAccountsCountOutputTypeCountTriggerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TriggersWhereInput
  }

  /**
   * SubAccountsCountOutputType without action
   */
  export type SubAccountsCountOutputTypeCountAutomationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutomationsWhereInput
  }

  /**
   * SubAccountsCountOutputType without action
   */
  export type SubAccountsCountOutputTypeCountPipelineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PipelinesWhereInput
  }

  /**
   * SubAccountsCountOutputType without action
   */
  export type SubAccountsCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagsWhereInput
  }

  /**
   * SubAccountsCountOutputType without action
   */
  export type SubAccountsCountOutputTypeCountNotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationsWhereInput
  }

  /**
   * SubAccountsCountOutputType without action
   */
  export type SubAccountsCountOutputTypeCountSubAccountSidebarOptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubAccountSidebarOptionWhereInput
  }


  /**
   * Count Type PipelinesCountOutputType
   */

  export type PipelinesCountOutputType = {
    Lane: number
  }

  export type PipelinesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Lane?: boolean | PipelinesCountOutputTypeCountLaneArgs
  }

  // Custom InputTypes
  /**
   * PipelinesCountOutputType without action
   */
  export type PipelinesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PipelinesCountOutputType
     */
    select?: PipelinesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PipelinesCountOutputType without action
   */
  export type PipelinesCountOutputTypeCountLaneArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LaneWhereInput
  }


  /**
   * Count Type TriggersCountOutputType
   */

  export type TriggersCountOutputType = {
    Automations: number
  }

  export type TriggersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Automations?: boolean | TriggersCountOutputTypeCountAutomationsArgs
  }

  // Custom InputTypes
  /**
   * TriggersCountOutputType without action
   */
  export type TriggersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TriggersCountOutputType
     */
    select?: TriggersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TriggersCountOutputType without action
   */
  export type TriggersCountOutputTypeCountAutomationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutomationsWhereInput
  }


  /**
   * Count Type AutomationsCountOutputType
   */

  export type AutomationsCountOutputType = {
    Actions: number
    AutomationInstance: number
  }

  export type AutomationsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Actions?: boolean | AutomationsCountOutputTypeCountActionsArgs
    AutomationInstance?: boolean | AutomationsCountOutputTypeCountAutomationInstanceArgs
  }

  // Custom InputTypes
  /**
   * AutomationsCountOutputType without action
   */
  export type AutomationsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationsCountOutputType
     */
    select?: AutomationsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AutomationsCountOutputType without action
   */
  export type AutomationsCountOutputTypeCountActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActionsWhereInput
  }

  /**
   * AutomationsCountOutputType without action
   */
  export type AutomationsCountOutputTypeCountAutomationInstanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutomationInstanceWhereInput
  }


  /**
   * Count Type ContactsCountOutputType
   */

  export type ContactsCountOutputType = {
    Tickets: number
  }

  export type ContactsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Tickets?: boolean | ContactsCountOutputTypeCountTicketsArgs
  }

  // Custom InputTypes
  /**
   * ContactsCountOutputType without action
   */
  export type ContactsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactsCountOutputType
     */
    select?: ContactsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContactsCountOutputType without action
   */
  export type ContactsCountOutputTypeCountTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketsWhereInput
  }


  /**
   * Count Type LaneCountOutputType
   */

  export type LaneCountOutputType = {
    Tickets: number
  }

  export type LaneCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Tickets?: boolean | LaneCountOutputTypeCountTicketsArgs
  }

  // Custom InputTypes
  /**
   * LaneCountOutputType without action
   */
  export type LaneCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LaneCountOutputType
     */
    select?: LaneCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LaneCountOutputType without action
   */
  export type LaneCountOutputTypeCountTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketsWhereInput
  }


  /**
   * Count Type TicketsCountOutputType
   */

  export type TicketsCountOutputType = {
    tags: number
  }

  export type TicketsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tags?: boolean | TicketsCountOutputTypeCountTagsArgs
  }

  // Custom InputTypes
  /**
   * TicketsCountOutputType without action
   */
  export type TicketsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketsCountOutputType
     */
    select?: TicketsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TicketsCountOutputType without action
   */
  export type TicketsCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagsWhereInput
  }


  /**
   * Count Type TagsCountOutputType
   */

  export type TagsCountOutputType = {
    Tickets: number
  }

  export type TagsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Tickets?: boolean | TagsCountOutputTypeCountTicketsArgs
  }

  // Custom InputTypes
  /**
   * TagsCountOutputType without action
   */
  export type TagsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagsCountOutputType
     */
    select?: TagsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TagsCountOutputType without action
   */
  export type TagsCountOutputTypeCountTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketsWhereInput
  }


  /**
   * Count Type FunnelsCountOutputType
   */

  export type FunnelsCountOutputType = {
    FunelPages: number
    className: number
  }

  export type FunnelsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    FunelPages?: boolean | FunnelsCountOutputTypeCountFunelPagesArgs
    className?: boolean | FunnelsCountOutputTypeCountClassNameArgs
  }

  // Custom InputTypes
  /**
   * FunnelsCountOutputType without action
   */
  export type FunnelsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunnelsCountOutputType
     */
    select?: FunnelsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FunnelsCountOutputType without action
   */
  export type FunnelsCountOutputTypeCountFunelPagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FunelPagesWhereInput
  }

  /**
   * FunnelsCountOutputType without action
   */
  export type FunnelsCountOutputTypeCountClassNameArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassNameWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersMinAggregateOutputType = {
    id: string | null
    name: string | null
    avatarUrl: string | null
    email: string | null
    createdAt: Date | null
    updatedAt: Date | null
    role: $Enums.Role | null
    agencyId: string | null
  }

  export type UsersMaxAggregateOutputType = {
    id: string | null
    name: string | null
    avatarUrl: string | null
    email: string | null
    createdAt: Date | null
    updatedAt: Date | null
    role: $Enums.Role | null
    agencyId: string | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    name: number
    avatarUrl: number
    email: number
    createdAt: number
    updatedAt: number
    role: number
    agencyId: number
    _all: number
  }


  export type UsersMinAggregateInputType = {
    id?: true
    name?: true
    avatarUrl?: true
    email?: true
    createdAt?: true
    updatedAt?: true
    role?: true
    agencyId?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    name?: true
    avatarUrl?: true
    email?: true
    createdAt?: true
    updatedAt?: true
    role?: true
    agencyId?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    name?: true
    avatarUrl?: true
    email?: true
    createdAt?: true
    updatedAt?: true
    role?: true
    agencyId?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to aggregate.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type UsersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersWhereInput
    orderBy?: UsersOrderByWithAggregationInput | UsersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: UsersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: string
    name: string
    avatarUrl: string
    email: string
    createdAt: Date
    updatedAt: Date
    role: $Enums.Role
    agencyId: string | null
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends UsersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type UsersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    avatarUrl?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    role?: boolean
    agencyId?: boolean
    Agency?: boolean | Users$AgencyArgs<ExtArgs>
    Permission?: boolean | Users$PermissionArgs<ExtArgs>
    Ticket?: boolean | Users$TicketArgs<ExtArgs>
    Notification?: boolean | Users$NotificationArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type UsersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    avatarUrl?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    role?: boolean
    agencyId?: boolean
    Agency?: boolean | Users$AgencyArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type UsersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    avatarUrl?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    role?: boolean
    agencyId?: boolean
    Agency?: boolean | Users$AgencyArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type UsersSelectScalar = {
    id?: boolean
    name?: boolean
    avatarUrl?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    role?: boolean
    agencyId?: boolean
  }

  export type UsersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "avatarUrl" | "email" | "createdAt" | "updatedAt" | "role" | "agencyId", ExtArgs["result"]["users"]>
  export type UsersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Agency?: boolean | Users$AgencyArgs<ExtArgs>
    Permission?: boolean | Users$PermissionArgs<ExtArgs>
    Ticket?: boolean | Users$TicketArgs<ExtArgs>
    Notification?: boolean | Users$NotificationArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UsersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Agency?: boolean | Users$AgencyArgs<ExtArgs>
  }
  export type UsersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Agency?: boolean | Users$AgencyArgs<ExtArgs>
  }

  export type $UsersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Users"
    objects: {
      Agency: Prisma.$AgencyPayload<ExtArgs> | null
      Permission: Prisma.$PermissionsPayload<ExtArgs>[]
      Ticket: Prisma.$TicketsPayload<ExtArgs>[]
      Notification: Prisma.$NotificationsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      avatarUrl: string
      email: string
      createdAt: Date
      updatedAt: Date
      role: $Enums.Role
      agencyId: string | null
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type UsersGetPayload<S extends boolean | null | undefined | UsersDefaultArgs> = $Result.GetResult<Prisma.$UsersPayload, S>

  type UsersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UsersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface UsersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Users'], meta: { name: 'Users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {UsersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsersFindUniqueArgs>(args: SelectSubset<T, UsersFindUniqueArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UsersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsersFindUniqueOrThrowArgs>(args: SelectSubset<T, UsersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsersFindFirstArgs>(args?: SelectSubset<T, UsersFindFirstArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsersFindFirstOrThrowArgs>(args?: SelectSubset<T, UsersFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsersFindManyArgs>(args?: SelectSubset<T, UsersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Users.
     * @param {UsersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends UsersCreateArgs>(args: SelectSubset<T, UsersCreateArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UsersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsersCreateManyArgs>(args?: SelectSubset<T, UsersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UsersCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsersCreateManyAndReturnArgs>(args?: SelectSubset<T, UsersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Users.
     * @param {UsersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends UsersDeleteArgs>(args: SelectSubset<T, UsersDeleteArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Users.
     * @param {UsersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsersUpdateArgs>(args: SelectSubset<T, UsersUpdateArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UsersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsersDeleteManyArgs>(args?: SelectSubset<T, UsersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsersUpdateManyArgs>(args: SelectSubset<T, UsersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UsersUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UsersUpdateManyAndReturnArgs>(args: SelectSubset<T, UsersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Users.
     * @param {UsersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends UsersUpsertArgs>(args: SelectSubset<T, UsersUpsertArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UsersCountArgs>(
      args?: Subset<T, UsersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsersGroupByArgs['orderBy'] }
        : { orderBy?: UsersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Users model
   */
  readonly fields: UsersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Agency<T extends Users$AgencyArgs<ExtArgs> = {}>(args?: Subset<T, Users$AgencyArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Permission<T extends Users$PermissionArgs<ExtArgs> = {}>(args?: Subset<T, Users$PermissionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Ticket<T extends Users$TicketArgs<ExtArgs> = {}>(args?: Subset<T, Users$TicketArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Notification<T extends Users$NotificationArgs<ExtArgs> = {}>(args?: Subset<T, Users$NotificationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Users model
   */
  interface UsersFieldRefs {
    readonly id: FieldRef<"Users", 'String'>
    readonly name: FieldRef<"Users", 'String'>
    readonly avatarUrl: FieldRef<"Users", 'String'>
    readonly email: FieldRef<"Users", 'String'>
    readonly createdAt: FieldRef<"Users", 'DateTime'>
    readonly updatedAt: FieldRef<"Users", 'DateTime'>
    readonly role: FieldRef<"Users", 'Role'>
    readonly agencyId: FieldRef<"Users", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Users findUnique
   */
  export type UsersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users findUniqueOrThrow
   */
  export type UsersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users findFirst
   */
  export type UsersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users findFirstOrThrow
   */
  export type UsersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users findMany
   */
  export type UsersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users create
   */
  export type UsersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The data needed to create a Users.
     */
    data: XOR<UsersCreateInput, UsersUncheckedCreateInput>
  }

  /**
   * Users createMany
   */
  export type UsersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UsersCreateManyInput | UsersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Users createManyAndReturn
   */
  export type UsersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UsersCreateManyInput | UsersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Users update
   */
  export type UsersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The data needed to update a Users.
     */
    data: XOR<UsersUpdateInput, UsersUncheckedUpdateInput>
    /**
     * Choose, which Users to update.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users updateMany
   */
  export type UsersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UsersUpdateManyMutationInput, UsersUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UsersWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * Users updateManyAndReturn
   */
  export type UsersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UsersUpdateManyMutationInput, UsersUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UsersWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Users upsert
   */
  export type UsersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The filter to search for the Users to update in case it exists.
     */
    where: UsersWhereUniqueInput
    /**
     * In case the Users found by the `where` argument doesn't exist, create a new Users with this data.
     */
    create: XOR<UsersCreateInput, UsersUncheckedCreateInput>
    /**
     * In case the Users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsersUpdateInput, UsersUncheckedUpdateInput>
  }

  /**
   * Users delete
   */
  export type UsersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter which Users to delete.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users deleteMany
   */
  export type UsersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UsersWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * Users.Agency
   */
  export type Users$AgencyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    where?: AgencyWhereInput
  }

  /**
   * Users.Permission
   */
  export type Users$PermissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permissions
     */
    select?: PermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permissions
     */
    omit?: PermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionsInclude<ExtArgs> | null
    where?: PermissionsWhereInput
    orderBy?: PermissionsOrderByWithRelationInput | PermissionsOrderByWithRelationInput[]
    cursor?: PermissionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PermissionsScalarFieldEnum | PermissionsScalarFieldEnum[]
  }

  /**
   * Users.Ticket
   */
  export type Users$TicketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tickets
     */
    select?: TicketsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tickets
     */
    omit?: TicketsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketsInclude<ExtArgs> | null
    where?: TicketsWhereInput
    orderBy?: TicketsOrderByWithRelationInput | TicketsOrderByWithRelationInput[]
    cursor?: TicketsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketsScalarFieldEnum | TicketsScalarFieldEnum[]
  }

  /**
   * Users.Notification
   */
  export type Users$NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    where?: NotificationsWhereInput
    orderBy?: NotificationsOrderByWithRelationInput | NotificationsOrderByWithRelationInput[]
    cursor?: NotificationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * Users without action
   */
  export type UsersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
  }


  /**
   * Model Permissions
   */

  export type AggregatePermissions = {
    _count: PermissionsCountAggregateOutputType | null
    _min: PermissionsMinAggregateOutputType | null
    _max: PermissionsMaxAggregateOutputType | null
  }

  export type PermissionsMinAggregateOutputType = {
    id: string | null
    email: string | null
    subAccontId: string | null
    access: boolean | null
  }

  export type PermissionsMaxAggregateOutputType = {
    id: string | null
    email: string | null
    subAccontId: string | null
    access: boolean | null
  }

  export type PermissionsCountAggregateOutputType = {
    id: number
    email: number
    subAccontId: number
    access: number
    _all: number
  }


  export type PermissionsMinAggregateInputType = {
    id?: true
    email?: true
    subAccontId?: true
    access?: true
  }

  export type PermissionsMaxAggregateInputType = {
    id?: true
    email?: true
    subAccontId?: true
    access?: true
  }

  export type PermissionsCountAggregateInputType = {
    id?: true
    email?: true
    subAccontId?: true
    access?: true
    _all?: true
  }

  export type PermissionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permissions to aggregate.
     */
    where?: PermissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionsOrderByWithRelationInput | PermissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PermissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Permissions
    **/
    _count?: true | PermissionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionsMaxAggregateInputType
  }

  export type GetPermissionsAggregateType<T extends PermissionsAggregateArgs> = {
        [P in keyof T & keyof AggregatePermissions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermissions[P]>
      : GetScalarType<T[P], AggregatePermissions[P]>
  }




  export type PermissionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionsWhereInput
    orderBy?: PermissionsOrderByWithAggregationInput | PermissionsOrderByWithAggregationInput[]
    by: PermissionsScalarFieldEnum[] | PermissionsScalarFieldEnum
    having?: PermissionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionsCountAggregateInputType | true
    _min?: PermissionsMinAggregateInputType
    _max?: PermissionsMaxAggregateInputType
  }

  export type PermissionsGroupByOutputType = {
    id: string
    email: string
    subAccontId: string
    access: boolean
    _count: PermissionsCountAggregateOutputType | null
    _min: PermissionsMinAggregateOutputType | null
    _max: PermissionsMaxAggregateOutputType | null
  }

  type GetPermissionsGroupByPayload<T extends PermissionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermissionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionsGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionsGroupByOutputType[P]>
        }
      >
    >


  export type PermissionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    subAccontId?: boolean
    access?: boolean
    Users?: boolean | UsersDefaultArgs<ExtArgs>
    SubAcctount?: boolean | SubAccountsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permissions"]>

  export type PermissionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    subAccontId?: boolean
    access?: boolean
    Users?: boolean | UsersDefaultArgs<ExtArgs>
    SubAcctount?: boolean | SubAccountsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permissions"]>

  export type PermissionsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    subAccontId?: boolean
    access?: boolean
    Users?: boolean | UsersDefaultArgs<ExtArgs>
    SubAcctount?: boolean | SubAccountsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permissions"]>

  export type PermissionsSelectScalar = {
    id?: boolean
    email?: boolean
    subAccontId?: boolean
    access?: boolean
  }

  export type PermissionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "subAccontId" | "access", ExtArgs["result"]["permissions"]>
  export type PermissionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | UsersDefaultArgs<ExtArgs>
    SubAcctount?: boolean | SubAccountsDefaultArgs<ExtArgs>
  }
  export type PermissionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | UsersDefaultArgs<ExtArgs>
    SubAcctount?: boolean | SubAccountsDefaultArgs<ExtArgs>
  }
  export type PermissionsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | UsersDefaultArgs<ExtArgs>
    SubAcctount?: boolean | SubAccountsDefaultArgs<ExtArgs>
  }

  export type $PermissionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Permissions"
    objects: {
      Users: Prisma.$UsersPayload<ExtArgs>
      SubAcctount: Prisma.$SubAccountsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      subAccontId: string
      access: boolean
    }, ExtArgs["result"]["permissions"]>
    composites: {}
  }

  type PermissionsGetPayload<S extends boolean | null | undefined | PermissionsDefaultArgs> = $Result.GetResult<Prisma.$PermissionsPayload, S>

  type PermissionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PermissionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PermissionsCountAggregateInputType | true
    }

  export interface PermissionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Permissions'], meta: { name: 'Permissions' } }
    /**
     * Find zero or one Permissions that matches the filter.
     * @param {PermissionsFindUniqueArgs} args - Arguments to find a Permissions
     * @example
     * // Get one Permissions
     * const permissions = await prisma.permissions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PermissionsFindUniqueArgs>(args: SelectSubset<T, PermissionsFindUniqueArgs<ExtArgs>>): Prisma__PermissionsClient<$Result.GetResult<Prisma.$PermissionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Permissions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PermissionsFindUniqueOrThrowArgs} args - Arguments to find a Permissions
     * @example
     * // Get one Permissions
     * const permissions = await prisma.permissions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PermissionsFindUniqueOrThrowArgs>(args: SelectSubset<T, PermissionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PermissionsClient<$Result.GetResult<Prisma.$PermissionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionsFindFirstArgs} args - Arguments to find a Permissions
     * @example
     * // Get one Permissions
     * const permissions = await prisma.permissions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PermissionsFindFirstArgs>(args?: SelectSubset<T, PermissionsFindFirstArgs<ExtArgs>>): Prisma__PermissionsClient<$Result.GetResult<Prisma.$PermissionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permissions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionsFindFirstOrThrowArgs} args - Arguments to find a Permissions
     * @example
     * // Get one Permissions
     * const permissions = await prisma.permissions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PermissionsFindFirstOrThrowArgs>(args?: SelectSubset<T, PermissionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__PermissionsClient<$Result.GetResult<Prisma.$PermissionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissions
     * const permissions = await prisma.permissions.findMany()
     * 
     * // Get first 10 Permissions
     * const permissions = await prisma.permissions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permissionsWithIdOnly = await prisma.permissions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PermissionsFindManyArgs>(args?: SelectSubset<T, PermissionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Permissions.
     * @param {PermissionsCreateArgs} args - Arguments to create a Permissions.
     * @example
     * // Create one Permissions
     * const Permissions = await prisma.permissions.create({
     *   data: {
     *     // ... data to create a Permissions
     *   }
     * })
     * 
     */
    create<T extends PermissionsCreateArgs>(args: SelectSubset<T, PermissionsCreateArgs<ExtArgs>>): Prisma__PermissionsClient<$Result.GetResult<Prisma.$PermissionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Permissions.
     * @param {PermissionsCreateManyArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permissions = await prisma.permissions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PermissionsCreateManyArgs>(args?: SelectSubset<T, PermissionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Permissions and returns the data saved in the database.
     * @param {PermissionsCreateManyAndReturnArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permissions = await prisma.permissions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Permissions and only return the `id`
     * const permissionsWithIdOnly = await prisma.permissions.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PermissionsCreateManyAndReturnArgs>(args?: SelectSubset<T, PermissionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Permissions.
     * @param {PermissionsDeleteArgs} args - Arguments to delete one Permissions.
     * @example
     * // Delete one Permissions
     * const Permissions = await prisma.permissions.delete({
     *   where: {
     *     // ... filter to delete one Permissions
     *   }
     * })
     * 
     */
    delete<T extends PermissionsDeleteArgs>(args: SelectSubset<T, PermissionsDeleteArgs<ExtArgs>>): Prisma__PermissionsClient<$Result.GetResult<Prisma.$PermissionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Permissions.
     * @param {PermissionsUpdateArgs} args - Arguments to update one Permissions.
     * @example
     * // Update one Permissions
     * const permissions = await prisma.permissions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PermissionsUpdateArgs>(args: SelectSubset<T, PermissionsUpdateArgs<ExtArgs>>): Prisma__PermissionsClient<$Result.GetResult<Prisma.$PermissionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Permissions.
     * @param {PermissionsDeleteManyArgs} args - Arguments to filter Permissions to delete.
     * @example
     * // Delete a few Permissions
     * const { count } = await prisma.permissions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PermissionsDeleteManyArgs>(args?: SelectSubset<T, PermissionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissions
     * const permissions = await prisma.permissions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PermissionsUpdateManyArgs>(args: SelectSubset<T, PermissionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions and returns the data updated in the database.
     * @param {PermissionsUpdateManyAndReturnArgs} args - Arguments to update many Permissions.
     * @example
     * // Update many Permissions
     * const permissions = await prisma.permissions.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Permissions and only return the `id`
     * const permissionsWithIdOnly = await prisma.permissions.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PermissionsUpdateManyAndReturnArgs>(args: SelectSubset<T, PermissionsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Permissions.
     * @param {PermissionsUpsertArgs} args - Arguments to update or create a Permissions.
     * @example
     * // Update or create a Permissions
     * const permissions = await prisma.permissions.upsert({
     *   create: {
     *     // ... data to create a Permissions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permissions we want to update
     *   }
     * })
     */
    upsert<T extends PermissionsUpsertArgs>(args: SelectSubset<T, PermissionsUpsertArgs<ExtArgs>>): Prisma__PermissionsClient<$Result.GetResult<Prisma.$PermissionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionsCountArgs} args - Arguments to filter Permissions to count.
     * @example
     * // Count the number of Permissions
     * const count = await prisma.permissions.count({
     *   where: {
     *     // ... the filter for the Permissions we want to count
     *   }
     * })
    **/
    count<T extends PermissionsCountArgs>(
      args?: Subset<T, PermissionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionsAggregateArgs>(args: Subset<T, PermissionsAggregateArgs>): Prisma.PrismaPromise<GetPermissionsAggregateType<T>>

    /**
     * Group by Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PermissionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PermissionsGroupByArgs['orderBy'] }
        : { orderBy?: PermissionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PermissionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Permissions model
   */
  readonly fields: PermissionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Permissions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PermissionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    SubAcctount<T extends SubAccountsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubAccountsDefaultArgs<ExtArgs>>): Prisma__SubAccountsClient<$Result.GetResult<Prisma.$SubAccountsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Permissions model
   */
  interface PermissionsFieldRefs {
    readonly id: FieldRef<"Permissions", 'String'>
    readonly email: FieldRef<"Permissions", 'String'>
    readonly subAccontId: FieldRef<"Permissions", 'String'>
    readonly access: FieldRef<"Permissions", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Permissions findUnique
   */
  export type PermissionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permissions
     */
    select?: PermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permissions
     */
    omit?: PermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionsInclude<ExtArgs> | null
    /**
     * Filter, which Permissions to fetch.
     */
    where: PermissionsWhereUniqueInput
  }

  /**
   * Permissions findUniqueOrThrow
   */
  export type PermissionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permissions
     */
    select?: PermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permissions
     */
    omit?: PermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionsInclude<ExtArgs> | null
    /**
     * Filter, which Permissions to fetch.
     */
    where: PermissionsWhereUniqueInput
  }

  /**
   * Permissions findFirst
   */
  export type PermissionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permissions
     */
    select?: PermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permissions
     */
    omit?: PermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionsInclude<ExtArgs> | null
    /**
     * Filter, which Permissions to fetch.
     */
    where?: PermissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionsOrderByWithRelationInput | PermissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionsScalarFieldEnum | PermissionsScalarFieldEnum[]
  }

  /**
   * Permissions findFirstOrThrow
   */
  export type PermissionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permissions
     */
    select?: PermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permissions
     */
    omit?: PermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionsInclude<ExtArgs> | null
    /**
     * Filter, which Permissions to fetch.
     */
    where?: PermissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionsOrderByWithRelationInput | PermissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionsScalarFieldEnum | PermissionsScalarFieldEnum[]
  }

  /**
   * Permissions findMany
   */
  export type PermissionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permissions
     */
    select?: PermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permissions
     */
    omit?: PermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionsInclude<ExtArgs> | null
    /**
     * Filter, which Permissions to fetch.
     */
    where?: PermissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionsOrderByWithRelationInput | PermissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Permissions.
     */
    cursor?: PermissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    distinct?: PermissionsScalarFieldEnum | PermissionsScalarFieldEnum[]
  }

  /**
   * Permissions create
   */
  export type PermissionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permissions
     */
    select?: PermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permissions
     */
    omit?: PermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionsInclude<ExtArgs> | null
    /**
     * The data needed to create a Permissions.
     */
    data: XOR<PermissionsCreateInput, PermissionsUncheckedCreateInput>
  }

  /**
   * Permissions createMany
   */
  export type PermissionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Permissions.
     */
    data: PermissionsCreateManyInput | PermissionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permissions createManyAndReturn
   */
  export type PermissionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permissions
     */
    select?: PermissionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Permissions
     */
    omit?: PermissionsOmit<ExtArgs> | null
    /**
     * The data used to create many Permissions.
     */
    data: PermissionsCreateManyInput | PermissionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Permissions update
   */
  export type PermissionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permissions
     */
    select?: PermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permissions
     */
    omit?: PermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionsInclude<ExtArgs> | null
    /**
     * The data needed to update a Permissions.
     */
    data: XOR<PermissionsUpdateInput, PermissionsUncheckedUpdateInput>
    /**
     * Choose, which Permissions to update.
     */
    where: PermissionsWhereUniqueInput
  }

  /**
   * Permissions updateMany
   */
  export type PermissionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionsUpdateManyMutationInput, PermissionsUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionsWhereInput
    /**
     * Limit how many Permissions to update.
     */
    limit?: number
  }

  /**
   * Permissions updateManyAndReturn
   */
  export type PermissionsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permissions
     */
    select?: PermissionsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Permissions
     */
    omit?: PermissionsOmit<ExtArgs> | null
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionsUpdateManyMutationInput, PermissionsUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionsWhereInput
    /**
     * Limit how many Permissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Permissions upsert
   */
  export type PermissionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permissions
     */
    select?: PermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permissions
     */
    omit?: PermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionsInclude<ExtArgs> | null
    /**
     * The filter to search for the Permissions to update in case it exists.
     */
    where: PermissionsWhereUniqueInput
    /**
     * In case the Permissions found by the `where` argument doesn't exist, create a new Permissions with this data.
     */
    create: XOR<PermissionsCreateInput, PermissionsUncheckedCreateInput>
    /**
     * In case the Permissions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PermissionsUpdateInput, PermissionsUncheckedUpdateInput>
  }

  /**
   * Permissions delete
   */
  export type PermissionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permissions
     */
    select?: PermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permissions
     */
    omit?: PermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionsInclude<ExtArgs> | null
    /**
     * Filter which Permissions to delete.
     */
    where: PermissionsWhereUniqueInput
  }

  /**
   * Permissions deleteMany
   */
  export type PermissionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permissions to delete
     */
    where?: PermissionsWhereInput
    /**
     * Limit how many Permissions to delete.
     */
    limit?: number
  }

  /**
   * Permissions without action
   */
  export type PermissionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permissions
     */
    select?: PermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permissions
     */
    omit?: PermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionsInclude<ExtArgs> | null
  }


  /**
   * Model Agency
   */

  export type AggregateAgency = {
    _count: AgencyCountAggregateOutputType | null
    _avg: AgencyAvgAggregateOutputType | null
    _sum: AgencySumAggregateOutputType | null
    _min: AgencyMinAggregateOutputType | null
    _max: AgencyMaxAggregateOutputType | null
  }

  export type AgencyAvgAggregateOutputType = {
    goal: number | null
  }

  export type AgencySumAggregateOutputType = {
    goal: number | null
  }

  export type AgencyMinAggregateOutputType = {
    id: string | null
    connectAccountId: string | null
    customerId: string | null
    name: string | null
    agencyLogo: string | null
    companyEmail: string | null
    companyPhone: string | null
    whiteLabel: boolean | null
    address: string | null
    city: string | null
    zipCode: string | null
    state: string | null
    country: string | null
    goal: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgencyMaxAggregateOutputType = {
    id: string | null
    connectAccountId: string | null
    customerId: string | null
    name: string | null
    agencyLogo: string | null
    companyEmail: string | null
    companyPhone: string | null
    whiteLabel: boolean | null
    address: string | null
    city: string | null
    zipCode: string | null
    state: string | null
    country: string | null
    goal: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgencyCountAggregateOutputType = {
    id: number
    connectAccountId: number
    customerId: number
    name: number
    agencyLogo: number
    companyEmail: number
    companyPhone: number
    whiteLabel: number
    address: number
    city: number
    zipCode: number
    state: number
    country: number
    goal: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AgencyAvgAggregateInputType = {
    goal?: true
  }

  export type AgencySumAggregateInputType = {
    goal?: true
  }

  export type AgencyMinAggregateInputType = {
    id?: true
    connectAccountId?: true
    customerId?: true
    name?: true
    agencyLogo?: true
    companyEmail?: true
    companyPhone?: true
    whiteLabel?: true
    address?: true
    city?: true
    zipCode?: true
    state?: true
    country?: true
    goal?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgencyMaxAggregateInputType = {
    id?: true
    connectAccountId?: true
    customerId?: true
    name?: true
    agencyLogo?: true
    companyEmail?: true
    companyPhone?: true
    whiteLabel?: true
    address?: true
    city?: true
    zipCode?: true
    state?: true
    country?: true
    goal?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgencyCountAggregateInputType = {
    id?: true
    connectAccountId?: true
    customerId?: true
    name?: true
    agencyLogo?: true
    companyEmail?: true
    companyPhone?: true
    whiteLabel?: true
    address?: true
    city?: true
    zipCode?: true
    state?: true
    country?: true
    goal?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AgencyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agency to aggregate.
     */
    where?: AgencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agencies to fetch.
     */
    orderBy?: AgencyOrderByWithRelationInput | AgencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Agencies
    **/
    _count?: true | AgencyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgencyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgencySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgencyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgencyMaxAggregateInputType
  }

  export type GetAgencyAggregateType<T extends AgencyAggregateArgs> = {
        [P in keyof T & keyof AggregateAgency]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgency[P]>
      : GetScalarType<T[P], AggregateAgency[P]>
  }




  export type AgencyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencyWhereInput
    orderBy?: AgencyOrderByWithAggregationInput | AgencyOrderByWithAggregationInput[]
    by: AgencyScalarFieldEnum[] | AgencyScalarFieldEnum
    having?: AgencyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgencyCountAggregateInputType | true
    _avg?: AgencyAvgAggregateInputType
    _sum?: AgencySumAggregateInputType
    _min?: AgencyMinAggregateInputType
    _max?: AgencyMaxAggregateInputType
  }

  export type AgencyGroupByOutputType = {
    id: string
    connectAccountId: string | null
    customerId: string
    name: string
    agencyLogo: string
    companyEmail: string
    companyPhone: string
    whiteLabel: boolean
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    goal: number
    createdAt: Date
    updatedAt: Date
    _count: AgencyCountAggregateOutputType | null
    _avg: AgencyAvgAggregateOutputType | null
    _sum: AgencySumAggregateOutputType | null
    _min: AgencyMinAggregateOutputType | null
    _max: AgencyMaxAggregateOutputType | null
  }

  type GetAgencyGroupByPayload<T extends AgencyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgencyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgencyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgencyGroupByOutputType[P]>
            : GetScalarType<T[P], AgencyGroupByOutputType[P]>
        }
      >
    >


  export type AgencySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    connectAccountId?: boolean
    customerId?: boolean
    name?: boolean
    agencyLogo?: boolean
    companyEmail?: boolean
    companyPhone?: boolean
    whiteLabel?: boolean
    address?: boolean
    city?: boolean
    zipCode?: boolean
    state?: boolean
    country?: boolean
    goal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Agency$userArgs<ExtArgs>
    SubAccount?: boolean | Agency$SubAccountArgs<ExtArgs>
    SidebarOption?: boolean | Agency$SidebarOptionArgs<ExtArgs>
    Invitation?: boolean | Agency$InvitationArgs<ExtArgs>
    Notification?: boolean | Agency$NotificationArgs<ExtArgs>
    Subscription?: boolean | Agency$SubscriptionArgs<ExtArgs>
    AddOns?: boolean | Agency$AddOnsArgs<ExtArgs>
    _count?: boolean | AgencyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agency"]>

  export type AgencySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    connectAccountId?: boolean
    customerId?: boolean
    name?: boolean
    agencyLogo?: boolean
    companyEmail?: boolean
    companyPhone?: boolean
    whiteLabel?: boolean
    address?: boolean
    city?: boolean
    zipCode?: boolean
    state?: boolean
    country?: boolean
    goal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["agency"]>

  export type AgencySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    connectAccountId?: boolean
    customerId?: boolean
    name?: boolean
    agencyLogo?: boolean
    companyEmail?: boolean
    companyPhone?: boolean
    whiteLabel?: boolean
    address?: boolean
    city?: boolean
    zipCode?: boolean
    state?: boolean
    country?: boolean
    goal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["agency"]>

  export type AgencySelectScalar = {
    id?: boolean
    connectAccountId?: boolean
    customerId?: boolean
    name?: boolean
    agencyLogo?: boolean
    companyEmail?: boolean
    companyPhone?: boolean
    whiteLabel?: boolean
    address?: boolean
    city?: boolean
    zipCode?: boolean
    state?: boolean
    country?: boolean
    goal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AgencyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "connectAccountId" | "customerId" | "name" | "agencyLogo" | "companyEmail" | "companyPhone" | "whiteLabel" | "address" | "city" | "zipCode" | "state" | "country" | "goal" | "createdAt" | "updatedAt", ExtArgs["result"]["agency"]>
  export type AgencyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Agency$userArgs<ExtArgs>
    SubAccount?: boolean | Agency$SubAccountArgs<ExtArgs>
    SidebarOption?: boolean | Agency$SidebarOptionArgs<ExtArgs>
    Invitation?: boolean | Agency$InvitationArgs<ExtArgs>
    Notification?: boolean | Agency$NotificationArgs<ExtArgs>
    Subscription?: boolean | Agency$SubscriptionArgs<ExtArgs>
    AddOns?: boolean | Agency$AddOnsArgs<ExtArgs>
    _count?: boolean | AgencyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AgencyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AgencyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AgencyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Agency"
    objects: {
      user: Prisma.$UsersPayload<ExtArgs>[]
      SubAccount: Prisma.$SubAccountsPayload<ExtArgs>[]
      SidebarOption: Prisma.$AgencySidebarOptionPayload<ExtArgs>[]
      Invitation: Prisma.$InvitationsPayload<ExtArgs>[]
      Notification: Prisma.$NotificationsPayload<ExtArgs>[]
      Subscription: Prisma.$SubscriptionsPayload<ExtArgs> | null
      AddOns: Prisma.$AddOnsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      connectAccountId: string | null
      customerId: string
      name: string
      agencyLogo: string
      companyEmail: string
      companyPhone: string
      whiteLabel: boolean
      address: string
      city: string
      zipCode: string
      state: string
      country: string
      goal: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["agency"]>
    composites: {}
  }

  type AgencyGetPayload<S extends boolean | null | undefined | AgencyDefaultArgs> = $Result.GetResult<Prisma.$AgencyPayload, S>

  type AgencyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgencyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgencyCountAggregateInputType | true
    }

  export interface AgencyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Agency'], meta: { name: 'Agency' } }
    /**
     * Find zero or one Agency that matches the filter.
     * @param {AgencyFindUniqueArgs} args - Arguments to find a Agency
     * @example
     * // Get one Agency
     * const agency = await prisma.agency.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgencyFindUniqueArgs>(args: SelectSubset<T, AgencyFindUniqueArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Agency that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgencyFindUniqueOrThrowArgs} args - Arguments to find a Agency
     * @example
     * // Get one Agency
     * const agency = await prisma.agency.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgencyFindUniqueOrThrowArgs>(args: SelectSubset<T, AgencyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agency that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyFindFirstArgs} args - Arguments to find a Agency
     * @example
     * // Get one Agency
     * const agency = await prisma.agency.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgencyFindFirstArgs>(args?: SelectSubset<T, AgencyFindFirstArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agency that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyFindFirstOrThrowArgs} args - Arguments to find a Agency
     * @example
     * // Get one Agency
     * const agency = await prisma.agency.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgencyFindFirstOrThrowArgs>(args?: SelectSubset<T, AgencyFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Agencies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Agencies
     * const agencies = await prisma.agency.findMany()
     * 
     * // Get first 10 Agencies
     * const agencies = await prisma.agency.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agencyWithIdOnly = await prisma.agency.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgencyFindManyArgs>(args?: SelectSubset<T, AgencyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Agency.
     * @param {AgencyCreateArgs} args - Arguments to create a Agency.
     * @example
     * // Create one Agency
     * const Agency = await prisma.agency.create({
     *   data: {
     *     // ... data to create a Agency
     *   }
     * })
     * 
     */
    create<T extends AgencyCreateArgs>(args: SelectSubset<T, AgencyCreateArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Agencies.
     * @param {AgencyCreateManyArgs} args - Arguments to create many Agencies.
     * @example
     * // Create many Agencies
     * const agency = await prisma.agency.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgencyCreateManyArgs>(args?: SelectSubset<T, AgencyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Agencies and returns the data saved in the database.
     * @param {AgencyCreateManyAndReturnArgs} args - Arguments to create many Agencies.
     * @example
     * // Create many Agencies
     * const agency = await prisma.agency.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Agencies and only return the `id`
     * const agencyWithIdOnly = await prisma.agency.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgencyCreateManyAndReturnArgs>(args?: SelectSubset<T, AgencyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Agency.
     * @param {AgencyDeleteArgs} args - Arguments to delete one Agency.
     * @example
     * // Delete one Agency
     * const Agency = await prisma.agency.delete({
     *   where: {
     *     // ... filter to delete one Agency
     *   }
     * })
     * 
     */
    delete<T extends AgencyDeleteArgs>(args: SelectSubset<T, AgencyDeleteArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Agency.
     * @param {AgencyUpdateArgs} args - Arguments to update one Agency.
     * @example
     * // Update one Agency
     * const agency = await prisma.agency.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgencyUpdateArgs>(args: SelectSubset<T, AgencyUpdateArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Agencies.
     * @param {AgencyDeleteManyArgs} args - Arguments to filter Agencies to delete.
     * @example
     * // Delete a few Agencies
     * const { count } = await prisma.agency.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgencyDeleteManyArgs>(args?: SelectSubset<T, AgencyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Agencies
     * const agency = await prisma.agency.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgencyUpdateManyArgs>(args: SelectSubset<T, AgencyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agencies and returns the data updated in the database.
     * @param {AgencyUpdateManyAndReturnArgs} args - Arguments to update many Agencies.
     * @example
     * // Update many Agencies
     * const agency = await prisma.agency.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Agencies and only return the `id`
     * const agencyWithIdOnly = await prisma.agency.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AgencyUpdateManyAndReturnArgs>(args: SelectSubset<T, AgencyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Agency.
     * @param {AgencyUpsertArgs} args - Arguments to update or create a Agency.
     * @example
     * // Update or create a Agency
     * const agency = await prisma.agency.upsert({
     *   create: {
     *     // ... data to create a Agency
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Agency we want to update
     *   }
     * })
     */
    upsert<T extends AgencyUpsertArgs>(args: SelectSubset<T, AgencyUpsertArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Agencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyCountArgs} args - Arguments to filter Agencies to count.
     * @example
     * // Count the number of Agencies
     * const count = await prisma.agency.count({
     *   where: {
     *     // ... the filter for the Agencies we want to count
     *   }
     * })
    **/
    count<T extends AgencyCountArgs>(
      args?: Subset<T, AgencyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgencyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Agency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgencyAggregateArgs>(args: Subset<T, AgencyAggregateArgs>): Prisma.PrismaPromise<GetAgencyAggregateType<T>>

    /**
     * Group by Agency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgencyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgencyGroupByArgs['orderBy'] }
        : { orderBy?: AgencyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgencyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgencyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Agency model
   */
  readonly fields: AgencyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Agency.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgencyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Agency$userArgs<ExtArgs> = {}>(args?: Subset<T, Agency$userArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    SubAccount<T extends Agency$SubAccountArgs<ExtArgs> = {}>(args?: Subset<T, Agency$SubAccountArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubAccountsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    SidebarOption<T extends Agency$SidebarOptionArgs<ExtArgs> = {}>(args?: Subset<T, Agency$SidebarOptionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencySidebarOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Invitation<T extends Agency$InvitationArgs<ExtArgs> = {}>(args?: Subset<T, Agency$InvitationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Notification<T extends Agency$NotificationArgs<ExtArgs> = {}>(args?: Subset<T, Agency$NotificationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Subscription<T extends Agency$SubscriptionArgs<ExtArgs> = {}>(args?: Subset<T, Agency$SubscriptionArgs<ExtArgs>>): Prisma__SubscriptionsClient<$Result.GetResult<Prisma.$SubscriptionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    AddOns<T extends Agency$AddOnsArgs<ExtArgs> = {}>(args?: Subset<T, Agency$AddOnsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddOnsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Agency model
   */
  interface AgencyFieldRefs {
    readonly id: FieldRef<"Agency", 'String'>
    readonly connectAccountId: FieldRef<"Agency", 'String'>
    readonly customerId: FieldRef<"Agency", 'String'>
    readonly name: FieldRef<"Agency", 'String'>
    readonly agencyLogo: FieldRef<"Agency", 'String'>
    readonly companyEmail: FieldRef<"Agency", 'String'>
    readonly companyPhone: FieldRef<"Agency", 'String'>
    readonly whiteLabel: FieldRef<"Agency", 'Boolean'>
    readonly address: FieldRef<"Agency", 'String'>
    readonly city: FieldRef<"Agency", 'String'>
    readonly zipCode: FieldRef<"Agency", 'String'>
    readonly state: FieldRef<"Agency", 'String'>
    readonly country: FieldRef<"Agency", 'String'>
    readonly goal: FieldRef<"Agency", 'Int'>
    readonly createdAt: FieldRef<"Agency", 'DateTime'>
    readonly updatedAt: FieldRef<"Agency", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Agency findUnique
   */
  export type AgencyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * Filter, which Agency to fetch.
     */
    where: AgencyWhereUniqueInput
  }

  /**
   * Agency findUniqueOrThrow
   */
  export type AgencyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * Filter, which Agency to fetch.
     */
    where: AgencyWhereUniqueInput
  }

  /**
   * Agency findFirst
   */
  export type AgencyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * Filter, which Agency to fetch.
     */
    where?: AgencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agencies to fetch.
     */
    orderBy?: AgencyOrderByWithRelationInput | AgencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agencies.
     */
    cursor?: AgencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agencies.
     */
    distinct?: AgencyScalarFieldEnum | AgencyScalarFieldEnum[]
  }

  /**
   * Agency findFirstOrThrow
   */
  export type AgencyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * Filter, which Agency to fetch.
     */
    where?: AgencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agencies to fetch.
     */
    orderBy?: AgencyOrderByWithRelationInput | AgencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agencies.
     */
    cursor?: AgencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agencies.
     */
    distinct?: AgencyScalarFieldEnum | AgencyScalarFieldEnum[]
  }

  /**
   * Agency findMany
   */
  export type AgencyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * Filter, which Agencies to fetch.
     */
    where?: AgencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agencies to fetch.
     */
    orderBy?: AgencyOrderByWithRelationInput | AgencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Agencies.
     */
    cursor?: AgencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agencies.
     */
    skip?: number
    distinct?: AgencyScalarFieldEnum | AgencyScalarFieldEnum[]
  }

  /**
   * Agency create
   */
  export type AgencyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * The data needed to create a Agency.
     */
    data: XOR<AgencyCreateInput, AgencyUncheckedCreateInput>
  }

  /**
   * Agency createMany
   */
  export type AgencyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Agencies.
     */
    data: AgencyCreateManyInput | AgencyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Agency createManyAndReturn
   */
  export type AgencyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * The data used to create many Agencies.
     */
    data: AgencyCreateManyInput | AgencyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Agency update
   */
  export type AgencyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * The data needed to update a Agency.
     */
    data: XOR<AgencyUpdateInput, AgencyUncheckedUpdateInput>
    /**
     * Choose, which Agency to update.
     */
    where: AgencyWhereUniqueInput
  }

  /**
   * Agency updateMany
   */
  export type AgencyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Agencies.
     */
    data: XOR<AgencyUpdateManyMutationInput, AgencyUncheckedUpdateManyInput>
    /**
     * Filter which Agencies to update
     */
    where?: AgencyWhereInput
    /**
     * Limit how many Agencies to update.
     */
    limit?: number
  }

  /**
   * Agency updateManyAndReturn
   */
  export type AgencyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * The data used to update Agencies.
     */
    data: XOR<AgencyUpdateManyMutationInput, AgencyUncheckedUpdateManyInput>
    /**
     * Filter which Agencies to update
     */
    where?: AgencyWhereInput
    /**
     * Limit how many Agencies to update.
     */
    limit?: number
  }

  /**
   * Agency upsert
   */
  export type AgencyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * The filter to search for the Agency to update in case it exists.
     */
    where: AgencyWhereUniqueInput
    /**
     * In case the Agency found by the `where` argument doesn't exist, create a new Agency with this data.
     */
    create: XOR<AgencyCreateInput, AgencyUncheckedCreateInput>
    /**
     * In case the Agency was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgencyUpdateInput, AgencyUncheckedUpdateInput>
  }

  /**
   * Agency delete
   */
  export type AgencyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    /**
     * Filter which Agency to delete.
     */
    where: AgencyWhereUniqueInput
  }

  /**
   * Agency deleteMany
   */
  export type AgencyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agencies to delete
     */
    where?: AgencyWhereInput
    /**
     * Limit how many Agencies to delete.
     */
    limit?: number
  }

  /**
   * Agency.user
   */
  export type Agency$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    where?: UsersWhereInput
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    cursor?: UsersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Agency.SubAccount
   */
  export type Agency$SubAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccounts
     */
    select?: SubAccountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccounts
     */
    omit?: SubAccountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountsInclude<ExtArgs> | null
    where?: SubAccountsWhereInput
    orderBy?: SubAccountsOrderByWithRelationInput | SubAccountsOrderByWithRelationInput[]
    cursor?: SubAccountsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubAccountsScalarFieldEnum | SubAccountsScalarFieldEnum[]
  }

  /**
   * Agency.SidebarOption
   */
  export type Agency$SidebarOptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencySidebarOption
     */
    select?: AgencySidebarOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencySidebarOption
     */
    omit?: AgencySidebarOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencySidebarOptionInclude<ExtArgs> | null
    where?: AgencySidebarOptionWhereInput
    orderBy?: AgencySidebarOptionOrderByWithRelationInput | AgencySidebarOptionOrderByWithRelationInput[]
    cursor?: AgencySidebarOptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgencySidebarOptionScalarFieldEnum | AgencySidebarOptionScalarFieldEnum[]
  }

  /**
   * Agency.Invitation
   */
  export type Agency$InvitationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitations
     */
    select?: InvitationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitations
     */
    omit?: InvitationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationsInclude<ExtArgs> | null
    where?: InvitationsWhereInput
    orderBy?: InvitationsOrderByWithRelationInput | InvitationsOrderByWithRelationInput[]
    cursor?: InvitationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvitationsScalarFieldEnum | InvitationsScalarFieldEnum[]
  }

  /**
   * Agency.Notification
   */
  export type Agency$NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    where?: NotificationsWhereInput
    orderBy?: NotificationsOrderByWithRelationInput | NotificationsOrderByWithRelationInput[]
    cursor?: NotificationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * Agency.Subscription
   */
  export type Agency$SubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriptions
     */
    select?: SubscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscriptions
     */
    omit?: SubscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionsInclude<ExtArgs> | null
    where?: SubscriptionsWhereInput
  }

  /**
   * Agency.AddOns
   */
  export type Agency$AddOnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOns
     */
    select?: AddOnsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddOns
     */
    omit?: AddOnsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddOnsInclude<ExtArgs> | null
    where?: AddOnsWhereInput
    orderBy?: AddOnsOrderByWithRelationInput | AddOnsOrderByWithRelationInput[]
    cursor?: AddOnsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AddOnsScalarFieldEnum | AddOnsScalarFieldEnum[]
  }

  /**
   * Agency without action
   */
  export type AgencyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
  }


  /**
   * Model AgencySidebarOption
   */

  export type AggregateAgencySidebarOption = {
    _count: AgencySidebarOptionCountAggregateOutputType | null
    _min: AgencySidebarOptionMinAggregateOutputType | null
    _max: AgencySidebarOptionMaxAggregateOutputType | null
  }

  export type AgencySidebarOptionMinAggregateOutputType = {
    id: string | null
    name: string | null
    link: string | null
    icon: $Enums.Icon | null
    createdAt: Date | null
    updatedAt: Date | null
    agencyId: string | null
    subAccountId: string | null
  }

  export type AgencySidebarOptionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    link: string | null
    icon: $Enums.Icon | null
    createdAt: Date | null
    updatedAt: Date | null
    agencyId: string | null
    subAccountId: string | null
  }

  export type AgencySidebarOptionCountAggregateOutputType = {
    id: number
    name: number
    link: number
    icon: number
    createdAt: number
    updatedAt: number
    agencyId: number
    subAccountId: number
    _all: number
  }


  export type AgencySidebarOptionMinAggregateInputType = {
    id?: true
    name?: true
    link?: true
    icon?: true
    createdAt?: true
    updatedAt?: true
    agencyId?: true
    subAccountId?: true
  }

  export type AgencySidebarOptionMaxAggregateInputType = {
    id?: true
    name?: true
    link?: true
    icon?: true
    createdAt?: true
    updatedAt?: true
    agencyId?: true
    subAccountId?: true
  }

  export type AgencySidebarOptionCountAggregateInputType = {
    id?: true
    name?: true
    link?: true
    icon?: true
    createdAt?: true
    updatedAt?: true
    agencyId?: true
    subAccountId?: true
    _all?: true
  }

  export type AgencySidebarOptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgencySidebarOption to aggregate.
     */
    where?: AgencySidebarOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencySidebarOptions to fetch.
     */
    orderBy?: AgencySidebarOptionOrderByWithRelationInput | AgencySidebarOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgencySidebarOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencySidebarOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencySidebarOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgencySidebarOptions
    **/
    _count?: true | AgencySidebarOptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgencySidebarOptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgencySidebarOptionMaxAggregateInputType
  }

  export type GetAgencySidebarOptionAggregateType<T extends AgencySidebarOptionAggregateArgs> = {
        [P in keyof T & keyof AggregateAgencySidebarOption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgencySidebarOption[P]>
      : GetScalarType<T[P], AggregateAgencySidebarOption[P]>
  }




  export type AgencySidebarOptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgencySidebarOptionWhereInput
    orderBy?: AgencySidebarOptionOrderByWithAggregationInput | AgencySidebarOptionOrderByWithAggregationInput[]
    by: AgencySidebarOptionScalarFieldEnum[] | AgencySidebarOptionScalarFieldEnum
    having?: AgencySidebarOptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgencySidebarOptionCountAggregateInputType | true
    _min?: AgencySidebarOptionMinAggregateInputType
    _max?: AgencySidebarOptionMaxAggregateInputType
  }

  export type AgencySidebarOptionGroupByOutputType = {
    id: string
    name: string
    link: string
    icon: $Enums.Icon
    createdAt: Date
    updatedAt: Date
    agencyId: string
    subAccountId: string | null
    _count: AgencySidebarOptionCountAggregateOutputType | null
    _min: AgencySidebarOptionMinAggregateOutputType | null
    _max: AgencySidebarOptionMaxAggregateOutputType | null
  }

  type GetAgencySidebarOptionGroupByPayload<T extends AgencySidebarOptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgencySidebarOptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgencySidebarOptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgencySidebarOptionGroupByOutputType[P]>
            : GetScalarType<T[P], AgencySidebarOptionGroupByOutputType[P]>
        }
      >
    >


  export type AgencySidebarOptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    link?: boolean
    icon?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agencyId?: boolean
    subAccountId?: boolean
    Agency?: boolean | AgencyDefaultArgs<ExtArgs>
    SubAccounts?: boolean | AgencySidebarOption$SubAccountsArgs<ExtArgs>
  }, ExtArgs["result"]["agencySidebarOption"]>

  export type AgencySidebarOptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    link?: boolean
    icon?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agencyId?: boolean
    subAccountId?: boolean
    Agency?: boolean | AgencyDefaultArgs<ExtArgs>
    SubAccounts?: boolean | AgencySidebarOption$SubAccountsArgs<ExtArgs>
  }, ExtArgs["result"]["agencySidebarOption"]>

  export type AgencySidebarOptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    link?: boolean
    icon?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agencyId?: boolean
    subAccountId?: boolean
    Agency?: boolean | AgencyDefaultArgs<ExtArgs>
    SubAccounts?: boolean | AgencySidebarOption$SubAccountsArgs<ExtArgs>
  }, ExtArgs["result"]["agencySidebarOption"]>

  export type AgencySidebarOptionSelectScalar = {
    id?: boolean
    name?: boolean
    link?: boolean
    icon?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agencyId?: boolean
    subAccountId?: boolean
  }

  export type AgencySidebarOptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "link" | "icon" | "createdAt" | "updatedAt" | "agencyId" | "subAccountId", ExtArgs["result"]["agencySidebarOption"]>
  export type AgencySidebarOptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Agency?: boolean | AgencyDefaultArgs<ExtArgs>
    SubAccounts?: boolean | AgencySidebarOption$SubAccountsArgs<ExtArgs>
  }
  export type AgencySidebarOptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Agency?: boolean | AgencyDefaultArgs<ExtArgs>
    SubAccounts?: boolean | AgencySidebarOption$SubAccountsArgs<ExtArgs>
  }
  export type AgencySidebarOptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Agency?: boolean | AgencyDefaultArgs<ExtArgs>
    SubAccounts?: boolean | AgencySidebarOption$SubAccountsArgs<ExtArgs>
  }

  export type $AgencySidebarOptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AgencySidebarOption"
    objects: {
      Agency: Prisma.$AgencyPayload<ExtArgs>
      SubAccounts: Prisma.$SubAccountsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      link: string
      icon: $Enums.Icon
      createdAt: Date
      updatedAt: Date
      agencyId: string
      subAccountId: string | null
    }, ExtArgs["result"]["agencySidebarOption"]>
    composites: {}
  }

  type AgencySidebarOptionGetPayload<S extends boolean | null | undefined | AgencySidebarOptionDefaultArgs> = $Result.GetResult<Prisma.$AgencySidebarOptionPayload, S>

  type AgencySidebarOptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgencySidebarOptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgencySidebarOptionCountAggregateInputType | true
    }

  export interface AgencySidebarOptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AgencySidebarOption'], meta: { name: 'AgencySidebarOption' } }
    /**
     * Find zero or one AgencySidebarOption that matches the filter.
     * @param {AgencySidebarOptionFindUniqueArgs} args - Arguments to find a AgencySidebarOption
     * @example
     * // Get one AgencySidebarOption
     * const agencySidebarOption = await prisma.agencySidebarOption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgencySidebarOptionFindUniqueArgs>(args: SelectSubset<T, AgencySidebarOptionFindUniqueArgs<ExtArgs>>): Prisma__AgencySidebarOptionClient<$Result.GetResult<Prisma.$AgencySidebarOptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AgencySidebarOption that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgencySidebarOptionFindUniqueOrThrowArgs} args - Arguments to find a AgencySidebarOption
     * @example
     * // Get one AgencySidebarOption
     * const agencySidebarOption = await prisma.agencySidebarOption.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgencySidebarOptionFindUniqueOrThrowArgs>(args: SelectSubset<T, AgencySidebarOptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgencySidebarOptionClient<$Result.GetResult<Prisma.$AgencySidebarOptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgencySidebarOption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencySidebarOptionFindFirstArgs} args - Arguments to find a AgencySidebarOption
     * @example
     * // Get one AgencySidebarOption
     * const agencySidebarOption = await prisma.agencySidebarOption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgencySidebarOptionFindFirstArgs>(args?: SelectSubset<T, AgencySidebarOptionFindFirstArgs<ExtArgs>>): Prisma__AgencySidebarOptionClient<$Result.GetResult<Prisma.$AgencySidebarOptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgencySidebarOption that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencySidebarOptionFindFirstOrThrowArgs} args - Arguments to find a AgencySidebarOption
     * @example
     * // Get one AgencySidebarOption
     * const agencySidebarOption = await prisma.agencySidebarOption.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgencySidebarOptionFindFirstOrThrowArgs>(args?: SelectSubset<T, AgencySidebarOptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgencySidebarOptionClient<$Result.GetResult<Prisma.$AgencySidebarOptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AgencySidebarOptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencySidebarOptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgencySidebarOptions
     * const agencySidebarOptions = await prisma.agencySidebarOption.findMany()
     * 
     * // Get first 10 AgencySidebarOptions
     * const agencySidebarOptions = await prisma.agencySidebarOption.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agencySidebarOptionWithIdOnly = await prisma.agencySidebarOption.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgencySidebarOptionFindManyArgs>(args?: SelectSubset<T, AgencySidebarOptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencySidebarOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AgencySidebarOption.
     * @param {AgencySidebarOptionCreateArgs} args - Arguments to create a AgencySidebarOption.
     * @example
     * // Create one AgencySidebarOption
     * const AgencySidebarOption = await prisma.agencySidebarOption.create({
     *   data: {
     *     // ... data to create a AgencySidebarOption
     *   }
     * })
     * 
     */
    create<T extends AgencySidebarOptionCreateArgs>(args: SelectSubset<T, AgencySidebarOptionCreateArgs<ExtArgs>>): Prisma__AgencySidebarOptionClient<$Result.GetResult<Prisma.$AgencySidebarOptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AgencySidebarOptions.
     * @param {AgencySidebarOptionCreateManyArgs} args - Arguments to create many AgencySidebarOptions.
     * @example
     * // Create many AgencySidebarOptions
     * const agencySidebarOption = await prisma.agencySidebarOption.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgencySidebarOptionCreateManyArgs>(args?: SelectSubset<T, AgencySidebarOptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AgencySidebarOptions and returns the data saved in the database.
     * @param {AgencySidebarOptionCreateManyAndReturnArgs} args - Arguments to create many AgencySidebarOptions.
     * @example
     * // Create many AgencySidebarOptions
     * const agencySidebarOption = await prisma.agencySidebarOption.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AgencySidebarOptions and only return the `id`
     * const agencySidebarOptionWithIdOnly = await prisma.agencySidebarOption.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgencySidebarOptionCreateManyAndReturnArgs>(args?: SelectSubset<T, AgencySidebarOptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencySidebarOptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AgencySidebarOption.
     * @param {AgencySidebarOptionDeleteArgs} args - Arguments to delete one AgencySidebarOption.
     * @example
     * // Delete one AgencySidebarOption
     * const AgencySidebarOption = await prisma.agencySidebarOption.delete({
     *   where: {
     *     // ... filter to delete one AgencySidebarOption
     *   }
     * })
     * 
     */
    delete<T extends AgencySidebarOptionDeleteArgs>(args: SelectSubset<T, AgencySidebarOptionDeleteArgs<ExtArgs>>): Prisma__AgencySidebarOptionClient<$Result.GetResult<Prisma.$AgencySidebarOptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AgencySidebarOption.
     * @param {AgencySidebarOptionUpdateArgs} args - Arguments to update one AgencySidebarOption.
     * @example
     * // Update one AgencySidebarOption
     * const agencySidebarOption = await prisma.agencySidebarOption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgencySidebarOptionUpdateArgs>(args: SelectSubset<T, AgencySidebarOptionUpdateArgs<ExtArgs>>): Prisma__AgencySidebarOptionClient<$Result.GetResult<Prisma.$AgencySidebarOptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AgencySidebarOptions.
     * @param {AgencySidebarOptionDeleteManyArgs} args - Arguments to filter AgencySidebarOptions to delete.
     * @example
     * // Delete a few AgencySidebarOptions
     * const { count } = await prisma.agencySidebarOption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgencySidebarOptionDeleteManyArgs>(args?: SelectSubset<T, AgencySidebarOptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgencySidebarOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencySidebarOptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgencySidebarOptions
     * const agencySidebarOption = await prisma.agencySidebarOption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgencySidebarOptionUpdateManyArgs>(args: SelectSubset<T, AgencySidebarOptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgencySidebarOptions and returns the data updated in the database.
     * @param {AgencySidebarOptionUpdateManyAndReturnArgs} args - Arguments to update many AgencySidebarOptions.
     * @example
     * // Update many AgencySidebarOptions
     * const agencySidebarOption = await prisma.agencySidebarOption.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AgencySidebarOptions and only return the `id`
     * const agencySidebarOptionWithIdOnly = await prisma.agencySidebarOption.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AgencySidebarOptionUpdateManyAndReturnArgs>(args: SelectSubset<T, AgencySidebarOptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencySidebarOptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AgencySidebarOption.
     * @param {AgencySidebarOptionUpsertArgs} args - Arguments to update or create a AgencySidebarOption.
     * @example
     * // Update or create a AgencySidebarOption
     * const agencySidebarOption = await prisma.agencySidebarOption.upsert({
     *   create: {
     *     // ... data to create a AgencySidebarOption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgencySidebarOption we want to update
     *   }
     * })
     */
    upsert<T extends AgencySidebarOptionUpsertArgs>(args: SelectSubset<T, AgencySidebarOptionUpsertArgs<ExtArgs>>): Prisma__AgencySidebarOptionClient<$Result.GetResult<Prisma.$AgencySidebarOptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AgencySidebarOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencySidebarOptionCountArgs} args - Arguments to filter AgencySidebarOptions to count.
     * @example
     * // Count the number of AgencySidebarOptions
     * const count = await prisma.agencySidebarOption.count({
     *   where: {
     *     // ... the filter for the AgencySidebarOptions we want to count
     *   }
     * })
    **/
    count<T extends AgencySidebarOptionCountArgs>(
      args?: Subset<T, AgencySidebarOptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgencySidebarOptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgencySidebarOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencySidebarOptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgencySidebarOptionAggregateArgs>(args: Subset<T, AgencySidebarOptionAggregateArgs>): Prisma.PrismaPromise<GetAgencySidebarOptionAggregateType<T>>

    /**
     * Group by AgencySidebarOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgencySidebarOptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgencySidebarOptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgencySidebarOptionGroupByArgs['orderBy'] }
        : { orderBy?: AgencySidebarOptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgencySidebarOptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgencySidebarOptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AgencySidebarOption model
   */
  readonly fields: AgencySidebarOptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AgencySidebarOption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgencySidebarOptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Agency<T extends AgencyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgencyDefaultArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    SubAccounts<T extends AgencySidebarOption$SubAccountsArgs<ExtArgs> = {}>(args?: Subset<T, AgencySidebarOption$SubAccountsArgs<ExtArgs>>): Prisma__SubAccountsClient<$Result.GetResult<Prisma.$SubAccountsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AgencySidebarOption model
   */
  interface AgencySidebarOptionFieldRefs {
    readonly id: FieldRef<"AgencySidebarOption", 'String'>
    readonly name: FieldRef<"AgencySidebarOption", 'String'>
    readonly link: FieldRef<"AgencySidebarOption", 'String'>
    readonly icon: FieldRef<"AgencySidebarOption", 'Icon'>
    readonly createdAt: FieldRef<"AgencySidebarOption", 'DateTime'>
    readonly updatedAt: FieldRef<"AgencySidebarOption", 'DateTime'>
    readonly agencyId: FieldRef<"AgencySidebarOption", 'String'>
    readonly subAccountId: FieldRef<"AgencySidebarOption", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AgencySidebarOption findUnique
   */
  export type AgencySidebarOptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencySidebarOption
     */
    select?: AgencySidebarOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencySidebarOption
     */
    omit?: AgencySidebarOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencySidebarOptionInclude<ExtArgs> | null
    /**
     * Filter, which AgencySidebarOption to fetch.
     */
    where: AgencySidebarOptionWhereUniqueInput
  }

  /**
   * AgencySidebarOption findUniqueOrThrow
   */
  export type AgencySidebarOptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencySidebarOption
     */
    select?: AgencySidebarOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencySidebarOption
     */
    omit?: AgencySidebarOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencySidebarOptionInclude<ExtArgs> | null
    /**
     * Filter, which AgencySidebarOption to fetch.
     */
    where: AgencySidebarOptionWhereUniqueInput
  }

  /**
   * AgencySidebarOption findFirst
   */
  export type AgencySidebarOptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencySidebarOption
     */
    select?: AgencySidebarOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencySidebarOption
     */
    omit?: AgencySidebarOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencySidebarOptionInclude<ExtArgs> | null
    /**
     * Filter, which AgencySidebarOption to fetch.
     */
    where?: AgencySidebarOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencySidebarOptions to fetch.
     */
    orderBy?: AgencySidebarOptionOrderByWithRelationInput | AgencySidebarOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgencySidebarOptions.
     */
    cursor?: AgencySidebarOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencySidebarOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencySidebarOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgencySidebarOptions.
     */
    distinct?: AgencySidebarOptionScalarFieldEnum | AgencySidebarOptionScalarFieldEnum[]
  }

  /**
   * AgencySidebarOption findFirstOrThrow
   */
  export type AgencySidebarOptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencySidebarOption
     */
    select?: AgencySidebarOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencySidebarOption
     */
    omit?: AgencySidebarOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencySidebarOptionInclude<ExtArgs> | null
    /**
     * Filter, which AgencySidebarOption to fetch.
     */
    where?: AgencySidebarOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencySidebarOptions to fetch.
     */
    orderBy?: AgencySidebarOptionOrderByWithRelationInput | AgencySidebarOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgencySidebarOptions.
     */
    cursor?: AgencySidebarOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencySidebarOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencySidebarOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgencySidebarOptions.
     */
    distinct?: AgencySidebarOptionScalarFieldEnum | AgencySidebarOptionScalarFieldEnum[]
  }

  /**
   * AgencySidebarOption findMany
   */
  export type AgencySidebarOptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencySidebarOption
     */
    select?: AgencySidebarOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencySidebarOption
     */
    omit?: AgencySidebarOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencySidebarOptionInclude<ExtArgs> | null
    /**
     * Filter, which AgencySidebarOptions to fetch.
     */
    where?: AgencySidebarOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgencySidebarOptions to fetch.
     */
    orderBy?: AgencySidebarOptionOrderByWithRelationInput | AgencySidebarOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgencySidebarOptions.
     */
    cursor?: AgencySidebarOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgencySidebarOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgencySidebarOptions.
     */
    skip?: number
    distinct?: AgencySidebarOptionScalarFieldEnum | AgencySidebarOptionScalarFieldEnum[]
  }

  /**
   * AgencySidebarOption create
   */
  export type AgencySidebarOptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencySidebarOption
     */
    select?: AgencySidebarOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencySidebarOption
     */
    omit?: AgencySidebarOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencySidebarOptionInclude<ExtArgs> | null
    /**
     * The data needed to create a AgencySidebarOption.
     */
    data: XOR<AgencySidebarOptionCreateInput, AgencySidebarOptionUncheckedCreateInput>
  }

  /**
   * AgencySidebarOption createMany
   */
  export type AgencySidebarOptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AgencySidebarOptions.
     */
    data: AgencySidebarOptionCreateManyInput | AgencySidebarOptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AgencySidebarOption createManyAndReturn
   */
  export type AgencySidebarOptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencySidebarOption
     */
    select?: AgencySidebarOptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgencySidebarOption
     */
    omit?: AgencySidebarOptionOmit<ExtArgs> | null
    /**
     * The data used to create many AgencySidebarOptions.
     */
    data: AgencySidebarOptionCreateManyInput | AgencySidebarOptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencySidebarOptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgencySidebarOption update
   */
  export type AgencySidebarOptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencySidebarOption
     */
    select?: AgencySidebarOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencySidebarOption
     */
    omit?: AgencySidebarOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencySidebarOptionInclude<ExtArgs> | null
    /**
     * The data needed to update a AgencySidebarOption.
     */
    data: XOR<AgencySidebarOptionUpdateInput, AgencySidebarOptionUncheckedUpdateInput>
    /**
     * Choose, which AgencySidebarOption to update.
     */
    where: AgencySidebarOptionWhereUniqueInput
  }

  /**
   * AgencySidebarOption updateMany
   */
  export type AgencySidebarOptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AgencySidebarOptions.
     */
    data: XOR<AgencySidebarOptionUpdateManyMutationInput, AgencySidebarOptionUncheckedUpdateManyInput>
    /**
     * Filter which AgencySidebarOptions to update
     */
    where?: AgencySidebarOptionWhereInput
    /**
     * Limit how many AgencySidebarOptions to update.
     */
    limit?: number
  }

  /**
   * AgencySidebarOption updateManyAndReturn
   */
  export type AgencySidebarOptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencySidebarOption
     */
    select?: AgencySidebarOptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgencySidebarOption
     */
    omit?: AgencySidebarOptionOmit<ExtArgs> | null
    /**
     * The data used to update AgencySidebarOptions.
     */
    data: XOR<AgencySidebarOptionUpdateManyMutationInput, AgencySidebarOptionUncheckedUpdateManyInput>
    /**
     * Filter which AgencySidebarOptions to update
     */
    where?: AgencySidebarOptionWhereInput
    /**
     * Limit how many AgencySidebarOptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencySidebarOptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgencySidebarOption upsert
   */
  export type AgencySidebarOptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencySidebarOption
     */
    select?: AgencySidebarOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencySidebarOption
     */
    omit?: AgencySidebarOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencySidebarOptionInclude<ExtArgs> | null
    /**
     * The filter to search for the AgencySidebarOption to update in case it exists.
     */
    where: AgencySidebarOptionWhereUniqueInput
    /**
     * In case the AgencySidebarOption found by the `where` argument doesn't exist, create a new AgencySidebarOption with this data.
     */
    create: XOR<AgencySidebarOptionCreateInput, AgencySidebarOptionUncheckedCreateInput>
    /**
     * In case the AgencySidebarOption was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgencySidebarOptionUpdateInput, AgencySidebarOptionUncheckedUpdateInput>
  }

  /**
   * AgencySidebarOption delete
   */
  export type AgencySidebarOptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencySidebarOption
     */
    select?: AgencySidebarOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencySidebarOption
     */
    omit?: AgencySidebarOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencySidebarOptionInclude<ExtArgs> | null
    /**
     * Filter which AgencySidebarOption to delete.
     */
    where: AgencySidebarOptionWhereUniqueInput
  }

  /**
   * AgencySidebarOption deleteMany
   */
  export type AgencySidebarOptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgencySidebarOptions to delete
     */
    where?: AgencySidebarOptionWhereInput
    /**
     * Limit how many AgencySidebarOptions to delete.
     */
    limit?: number
  }

  /**
   * AgencySidebarOption.SubAccounts
   */
  export type AgencySidebarOption$SubAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccounts
     */
    select?: SubAccountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccounts
     */
    omit?: SubAccountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountsInclude<ExtArgs> | null
    where?: SubAccountsWhereInput
  }

  /**
   * AgencySidebarOption without action
   */
  export type AgencySidebarOptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencySidebarOption
     */
    select?: AgencySidebarOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencySidebarOption
     */
    omit?: AgencySidebarOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencySidebarOptionInclude<ExtArgs> | null
  }


  /**
   * Model SubAccounts
   */

  export type AggregateSubAccounts = {
    _count: SubAccountsCountAggregateOutputType | null
    _avg: SubAccountsAvgAggregateOutputType | null
    _sum: SubAccountsSumAggregateOutputType | null
    _min: SubAccountsMinAggregateOutputType | null
    _max: SubAccountsMaxAggregateOutputType | null
  }

  export type SubAccountsAvgAggregateOutputType = {
    goal: number | null
  }

  export type SubAccountsSumAggregateOutputType = {
    goal: number | null
  }

  export type SubAccountsMinAggregateOutputType = {
    id: string | null
    connectAccountId: string | null
    name: string | null
    subAcctountLogo: string | null
    createdAt: Date | null
    updatedAt: Date | null
    companyEmail: string | null
    companyPhone: string | null
    goal: number | null
    address: string | null
    city: string | null
    zipCode: string | null
    state: string | null
    country: string | null
    agencyId: string | null
  }

  export type SubAccountsMaxAggregateOutputType = {
    id: string | null
    connectAccountId: string | null
    name: string | null
    subAcctountLogo: string | null
    createdAt: Date | null
    updatedAt: Date | null
    companyEmail: string | null
    companyPhone: string | null
    goal: number | null
    address: string | null
    city: string | null
    zipCode: string | null
    state: string | null
    country: string | null
    agencyId: string | null
  }

  export type SubAccountsCountAggregateOutputType = {
    id: number
    connectAccountId: number
    name: number
    subAcctountLogo: number
    createdAt: number
    updatedAt: number
    companyEmail: number
    companyPhone: number
    goal: number
    address: number
    city: number
    zipCode: number
    state: number
    country: number
    agencyId: number
    _all: number
  }


  export type SubAccountsAvgAggregateInputType = {
    goal?: true
  }

  export type SubAccountsSumAggregateInputType = {
    goal?: true
  }

  export type SubAccountsMinAggregateInputType = {
    id?: true
    connectAccountId?: true
    name?: true
    subAcctountLogo?: true
    createdAt?: true
    updatedAt?: true
    companyEmail?: true
    companyPhone?: true
    goal?: true
    address?: true
    city?: true
    zipCode?: true
    state?: true
    country?: true
    agencyId?: true
  }

  export type SubAccountsMaxAggregateInputType = {
    id?: true
    connectAccountId?: true
    name?: true
    subAcctountLogo?: true
    createdAt?: true
    updatedAt?: true
    companyEmail?: true
    companyPhone?: true
    goal?: true
    address?: true
    city?: true
    zipCode?: true
    state?: true
    country?: true
    agencyId?: true
  }

  export type SubAccountsCountAggregateInputType = {
    id?: true
    connectAccountId?: true
    name?: true
    subAcctountLogo?: true
    createdAt?: true
    updatedAt?: true
    companyEmail?: true
    companyPhone?: true
    goal?: true
    address?: true
    city?: true
    zipCode?: true
    state?: true
    country?: true
    agencyId?: true
    _all?: true
  }

  export type SubAccountsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubAccounts to aggregate.
     */
    where?: SubAccountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubAccounts to fetch.
     */
    orderBy?: SubAccountsOrderByWithRelationInput | SubAccountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubAccountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubAccounts
    **/
    _count?: true | SubAccountsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubAccountsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubAccountsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubAccountsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubAccountsMaxAggregateInputType
  }

  export type GetSubAccountsAggregateType<T extends SubAccountsAggregateArgs> = {
        [P in keyof T & keyof AggregateSubAccounts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubAccounts[P]>
      : GetScalarType<T[P], AggregateSubAccounts[P]>
  }




  export type SubAccountsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubAccountsWhereInput
    orderBy?: SubAccountsOrderByWithAggregationInput | SubAccountsOrderByWithAggregationInput[]
    by: SubAccountsScalarFieldEnum[] | SubAccountsScalarFieldEnum
    having?: SubAccountsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubAccountsCountAggregateInputType | true
    _avg?: SubAccountsAvgAggregateInputType
    _sum?: SubAccountsSumAggregateInputType
    _min?: SubAccountsMinAggregateInputType
    _max?: SubAccountsMaxAggregateInputType
  }

  export type SubAccountsGroupByOutputType = {
    id: string
    connectAccountId: string | null
    name: string
    subAcctountLogo: string
    createdAt: Date
    updatedAt: Date
    companyEmail: string
    companyPhone: string
    goal: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    agencyId: string
    _count: SubAccountsCountAggregateOutputType | null
    _avg: SubAccountsAvgAggregateOutputType | null
    _sum: SubAccountsSumAggregateOutputType | null
    _min: SubAccountsMinAggregateOutputType | null
    _max: SubAccountsMaxAggregateOutputType | null
  }

  type GetSubAccountsGroupByPayload<T extends SubAccountsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubAccountsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubAccountsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubAccountsGroupByOutputType[P]>
            : GetScalarType<T[P], SubAccountsGroupByOutputType[P]>
        }
      >
    >


  export type SubAccountsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    connectAccountId?: boolean
    name?: boolean
    subAcctountLogo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyEmail?: boolean
    companyPhone?: boolean
    goal?: boolean
    address?: boolean
    city?: boolean
    zipCode?: boolean
    state?: boolean
    country?: boolean
    agencyId?: boolean
    Agency?: boolean | AgencyDefaultArgs<ExtArgs>
    SidebarOption?: boolean | SubAccounts$SidebarOptionArgs<ExtArgs>
    Permissions?: boolean | SubAccounts$PermissionsArgs<ExtArgs>
    Funnels?: boolean | SubAccounts$FunnelsArgs<ExtArgs>
    Media?: boolean | SubAccounts$MediaArgs<ExtArgs>
    Contact?: boolean | SubAccounts$ContactArgs<ExtArgs>
    Trigger?: boolean | SubAccounts$TriggerArgs<ExtArgs>
    Automation?: boolean | SubAccounts$AutomationArgs<ExtArgs>
    Pipeline?: boolean | SubAccounts$PipelineArgs<ExtArgs>
    Tags?: boolean | SubAccounts$TagsArgs<ExtArgs>
    Notification?: boolean | SubAccounts$NotificationArgs<ExtArgs>
    SubAccountSidebarOption?: boolean | SubAccounts$SubAccountSidebarOptionArgs<ExtArgs>
    _count?: boolean | SubAccountsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subAccounts"]>

  export type SubAccountsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    connectAccountId?: boolean
    name?: boolean
    subAcctountLogo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyEmail?: boolean
    companyPhone?: boolean
    goal?: boolean
    address?: boolean
    city?: boolean
    zipCode?: boolean
    state?: boolean
    country?: boolean
    agencyId?: boolean
    Agency?: boolean | AgencyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subAccounts"]>

  export type SubAccountsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    connectAccountId?: boolean
    name?: boolean
    subAcctountLogo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyEmail?: boolean
    companyPhone?: boolean
    goal?: boolean
    address?: boolean
    city?: boolean
    zipCode?: boolean
    state?: boolean
    country?: boolean
    agencyId?: boolean
    Agency?: boolean | AgencyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subAccounts"]>

  export type SubAccountsSelectScalar = {
    id?: boolean
    connectAccountId?: boolean
    name?: boolean
    subAcctountLogo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyEmail?: boolean
    companyPhone?: boolean
    goal?: boolean
    address?: boolean
    city?: boolean
    zipCode?: boolean
    state?: boolean
    country?: boolean
    agencyId?: boolean
  }

  export type SubAccountsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "connectAccountId" | "name" | "subAcctountLogo" | "createdAt" | "updatedAt" | "companyEmail" | "companyPhone" | "goal" | "address" | "city" | "zipCode" | "state" | "country" | "agencyId", ExtArgs["result"]["subAccounts"]>
  export type SubAccountsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Agency?: boolean | AgencyDefaultArgs<ExtArgs>
    SidebarOption?: boolean | SubAccounts$SidebarOptionArgs<ExtArgs>
    Permissions?: boolean | SubAccounts$PermissionsArgs<ExtArgs>
    Funnels?: boolean | SubAccounts$FunnelsArgs<ExtArgs>
    Media?: boolean | SubAccounts$MediaArgs<ExtArgs>
    Contact?: boolean | SubAccounts$ContactArgs<ExtArgs>
    Trigger?: boolean | SubAccounts$TriggerArgs<ExtArgs>
    Automation?: boolean | SubAccounts$AutomationArgs<ExtArgs>
    Pipeline?: boolean | SubAccounts$PipelineArgs<ExtArgs>
    Tags?: boolean | SubAccounts$TagsArgs<ExtArgs>
    Notification?: boolean | SubAccounts$NotificationArgs<ExtArgs>
    SubAccountSidebarOption?: boolean | SubAccounts$SubAccountSidebarOptionArgs<ExtArgs>
    _count?: boolean | SubAccountsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubAccountsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Agency?: boolean | AgencyDefaultArgs<ExtArgs>
  }
  export type SubAccountsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Agency?: boolean | AgencyDefaultArgs<ExtArgs>
  }

  export type $SubAccountsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubAccounts"
    objects: {
      Agency: Prisma.$AgencyPayload<ExtArgs>
      SidebarOption: Prisma.$AgencySidebarOptionPayload<ExtArgs>[]
      Permissions: Prisma.$PermissionsPayload<ExtArgs>[]
      Funnels: Prisma.$FunnelsPayload<ExtArgs>[]
      Media: Prisma.$MediaPayload<ExtArgs>[]
      Contact: Prisma.$ContactsPayload<ExtArgs>[]
      Trigger: Prisma.$TriggersPayload<ExtArgs>[]
      Automation: Prisma.$AutomationsPayload<ExtArgs>[]
      Pipeline: Prisma.$PipelinesPayload<ExtArgs>[]
      Tags: Prisma.$TagsPayload<ExtArgs>[]
      Notification: Prisma.$NotificationsPayload<ExtArgs>[]
      SubAccountSidebarOption: Prisma.$SubAccountSidebarOptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      connectAccountId: string | null
      name: string
      subAcctountLogo: string
      createdAt: Date
      updatedAt: Date
      companyEmail: string
      companyPhone: string
      goal: number
      address: string
      city: string
      zipCode: string
      state: string
      country: string
      agencyId: string
    }, ExtArgs["result"]["subAccounts"]>
    composites: {}
  }

  type SubAccountsGetPayload<S extends boolean | null | undefined | SubAccountsDefaultArgs> = $Result.GetResult<Prisma.$SubAccountsPayload, S>

  type SubAccountsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubAccountsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubAccountsCountAggregateInputType | true
    }

  export interface SubAccountsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubAccounts'], meta: { name: 'SubAccounts' } }
    /**
     * Find zero or one SubAccounts that matches the filter.
     * @param {SubAccountsFindUniqueArgs} args - Arguments to find a SubAccounts
     * @example
     * // Get one SubAccounts
     * const subAccounts = await prisma.subAccounts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubAccountsFindUniqueArgs>(args: SelectSubset<T, SubAccountsFindUniqueArgs<ExtArgs>>): Prisma__SubAccountsClient<$Result.GetResult<Prisma.$SubAccountsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SubAccounts that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubAccountsFindUniqueOrThrowArgs} args - Arguments to find a SubAccounts
     * @example
     * // Get one SubAccounts
     * const subAccounts = await prisma.subAccounts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubAccountsFindUniqueOrThrowArgs>(args: SelectSubset<T, SubAccountsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubAccountsClient<$Result.GetResult<Prisma.$SubAccountsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubAccountsFindFirstArgs} args - Arguments to find a SubAccounts
     * @example
     * // Get one SubAccounts
     * const subAccounts = await prisma.subAccounts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubAccountsFindFirstArgs>(args?: SelectSubset<T, SubAccountsFindFirstArgs<ExtArgs>>): Prisma__SubAccountsClient<$Result.GetResult<Prisma.$SubAccountsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubAccounts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubAccountsFindFirstOrThrowArgs} args - Arguments to find a SubAccounts
     * @example
     * // Get one SubAccounts
     * const subAccounts = await prisma.subAccounts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubAccountsFindFirstOrThrowArgs>(args?: SelectSubset<T, SubAccountsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubAccountsClient<$Result.GetResult<Prisma.$SubAccountsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SubAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubAccountsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubAccounts
     * const subAccounts = await prisma.subAccounts.findMany()
     * 
     * // Get first 10 SubAccounts
     * const subAccounts = await prisma.subAccounts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subAccountsWithIdOnly = await prisma.subAccounts.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubAccountsFindManyArgs>(args?: SelectSubset<T, SubAccountsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubAccountsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SubAccounts.
     * @param {SubAccountsCreateArgs} args - Arguments to create a SubAccounts.
     * @example
     * // Create one SubAccounts
     * const SubAccounts = await prisma.subAccounts.create({
     *   data: {
     *     // ... data to create a SubAccounts
     *   }
     * })
     * 
     */
    create<T extends SubAccountsCreateArgs>(args: SelectSubset<T, SubAccountsCreateArgs<ExtArgs>>): Prisma__SubAccountsClient<$Result.GetResult<Prisma.$SubAccountsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SubAccounts.
     * @param {SubAccountsCreateManyArgs} args - Arguments to create many SubAccounts.
     * @example
     * // Create many SubAccounts
     * const subAccounts = await prisma.subAccounts.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubAccountsCreateManyArgs>(args?: SelectSubset<T, SubAccountsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SubAccounts and returns the data saved in the database.
     * @param {SubAccountsCreateManyAndReturnArgs} args - Arguments to create many SubAccounts.
     * @example
     * // Create many SubAccounts
     * const subAccounts = await prisma.subAccounts.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SubAccounts and only return the `id`
     * const subAccountsWithIdOnly = await prisma.subAccounts.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubAccountsCreateManyAndReturnArgs>(args?: SelectSubset<T, SubAccountsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubAccountsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SubAccounts.
     * @param {SubAccountsDeleteArgs} args - Arguments to delete one SubAccounts.
     * @example
     * // Delete one SubAccounts
     * const SubAccounts = await prisma.subAccounts.delete({
     *   where: {
     *     // ... filter to delete one SubAccounts
     *   }
     * })
     * 
     */
    delete<T extends SubAccountsDeleteArgs>(args: SelectSubset<T, SubAccountsDeleteArgs<ExtArgs>>): Prisma__SubAccountsClient<$Result.GetResult<Prisma.$SubAccountsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SubAccounts.
     * @param {SubAccountsUpdateArgs} args - Arguments to update one SubAccounts.
     * @example
     * // Update one SubAccounts
     * const subAccounts = await prisma.subAccounts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubAccountsUpdateArgs>(args: SelectSubset<T, SubAccountsUpdateArgs<ExtArgs>>): Prisma__SubAccountsClient<$Result.GetResult<Prisma.$SubAccountsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SubAccounts.
     * @param {SubAccountsDeleteManyArgs} args - Arguments to filter SubAccounts to delete.
     * @example
     * // Delete a few SubAccounts
     * const { count } = await prisma.subAccounts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubAccountsDeleteManyArgs>(args?: SelectSubset<T, SubAccountsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubAccountsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubAccounts
     * const subAccounts = await prisma.subAccounts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubAccountsUpdateManyArgs>(args: SelectSubset<T, SubAccountsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubAccounts and returns the data updated in the database.
     * @param {SubAccountsUpdateManyAndReturnArgs} args - Arguments to update many SubAccounts.
     * @example
     * // Update many SubAccounts
     * const subAccounts = await prisma.subAccounts.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SubAccounts and only return the `id`
     * const subAccountsWithIdOnly = await prisma.subAccounts.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubAccountsUpdateManyAndReturnArgs>(args: SelectSubset<T, SubAccountsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubAccountsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SubAccounts.
     * @param {SubAccountsUpsertArgs} args - Arguments to update or create a SubAccounts.
     * @example
     * // Update or create a SubAccounts
     * const subAccounts = await prisma.subAccounts.upsert({
     *   create: {
     *     // ... data to create a SubAccounts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubAccounts we want to update
     *   }
     * })
     */
    upsert<T extends SubAccountsUpsertArgs>(args: SelectSubset<T, SubAccountsUpsertArgs<ExtArgs>>): Prisma__SubAccountsClient<$Result.GetResult<Prisma.$SubAccountsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SubAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubAccountsCountArgs} args - Arguments to filter SubAccounts to count.
     * @example
     * // Count the number of SubAccounts
     * const count = await prisma.subAccounts.count({
     *   where: {
     *     // ... the filter for the SubAccounts we want to count
     *   }
     * })
    **/
    count<T extends SubAccountsCountArgs>(
      args?: Subset<T, SubAccountsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubAccountsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubAccountsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubAccountsAggregateArgs>(args: Subset<T, SubAccountsAggregateArgs>): Prisma.PrismaPromise<GetSubAccountsAggregateType<T>>

    /**
     * Group by SubAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubAccountsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubAccountsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubAccountsGroupByArgs['orderBy'] }
        : { orderBy?: SubAccountsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubAccountsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubAccountsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubAccounts model
   */
  readonly fields: SubAccountsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubAccounts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubAccountsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Agency<T extends AgencyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgencyDefaultArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    SidebarOption<T extends SubAccounts$SidebarOptionArgs<ExtArgs> = {}>(args?: Subset<T, SubAccounts$SidebarOptionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgencySidebarOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Permissions<T extends SubAccounts$PermissionsArgs<ExtArgs> = {}>(args?: Subset<T, SubAccounts$PermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Funnels<T extends SubAccounts$FunnelsArgs<ExtArgs> = {}>(args?: Subset<T, SubAccounts$FunnelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FunnelsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Media<T extends SubAccounts$MediaArgs<ExtArgs> = {}>(args?: Subset<T, SubAccounts$MediaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Contact<T extends SubAccounts$ContactArgs<ExtArgs> = {}>(args?: Subset<T, SubAccounts$ContactArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Trigger<T extends SubAccounts$TriggerArgs<ExtArgs> = {}>(args?: Subset<T, SubAccounts$TriggerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TriggersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Automation<T extends SubAccounts$AutomationArgs<ExtArgs> = {}>(args?: Subset<T, SubAccounts$AutomationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Pipeline<T extends SubAccounts$PipelineArgs<ExtArgs> = {}>(args?: Subset<T, SubAccounts$PipelineArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PipelinesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Tags<T extends SubAccounts$TagsArgs<ExtArgs> = {}>(args?: Subset<T, SubAccounts$TagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Notification<T extends SubAccounts$NotificationArgs<ExtArgs> = {}>(args?: Subset<T, SubAccounts$NotificationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    SubAccountSidebarOption<T extends SubAccounts$SubAccountSidebarOptionArgs<ExtArgs> = {}>(args?: Subset<T, SubAccounts$SubAccountSidebarOptionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubAccountSidebarOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubAccounts model
   */
  interface SubAccountsFieldRefs {
    readonly id: FieldRef<"SubAccounts", 'String'>
    readonly connectAccountId: FieldRef<"SubAccounts", 'String'>
    readonly name: FieldRef<"SubAccounts", 'String'>
    readonly subAcctountLogo: FieldRef<"SubAccounts", 'String'>
    readonly createdAt: FieldRef<"SubAccounts", 'DateTime'>
    readonly updatedAt: FieldRef<"SubAccounts", 'DateTime'>
    readonly companyEmail: FieldRef<"SubAccounts", 'String'>
    readonly companyPhone: FieldRef<"SubAccounts", 'String'>
    readonly goal: FieldRef<"SubAccounts", 'Int'>
    readonly address: FieldRef<"SubAccounts", 'String'>
    readonly city: FieldRef<"SubAccounts", 'String'>
    readonly zipCode: FieldRef<"SubAccounts", 'String'>
    readonly state: FieldRef<"SubAccounts", 'String'>
    readonly country: FieldRef<"SubAccounts", 'String'>
    readonly agencyId: FieldRef<"SubAccounts", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SubAccounts findUnique
   */
  export type SubAccountsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccounts
     */
    select?: SubAccountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccounts
     */
    omit?: SubAccountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountsInclude<ExtArgs> | null
    /**
     * Filter, which SubAccounts to fetch.
     */
    where: SubAccountsWhereUniqueInput
  }

  /**
   * SubAccounts findUniqueOrThrow
   */
  export type SubAccountsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccounts
     */
    select?: SubAccountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccounts
     */
    omit?: SubAccountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountsInclude<ExtArgs> | null
    /**
     * Filter, which SubAccounts to fetch.
     */
    where: SubAccountsWhereUniqueInput
  }

  /**
   * SubAccounts findFirst
   */
  export type SubAccountsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccounts
     */
    select?: SubAccountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccounts
     */
    omit?: SubAccountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountsInclude<ExtArgs> | null
    /**
     * Filter, which SubAccounts to fetch.
     */
    where?: SubAccountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubAccounts to fetch.
     */
    orderBy?: SubAccountsOrderByWithRelationInput | SubAccountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubAccounts.
     */
    cursor?: SubAccountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubAccounts.
     */
    distinct?: SubAccountsScalarFieldEnum | SubAccountsScalarFieldEnum[]
  }

  /**
   * SubAccounts findFirstOrThrow
   */
  export type SubAccountsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccounts
     */
    select?: SubAccountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccounts
     */
    omit?: SubAccountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountsInclude<ExtArgs> | null
    /**
     * Filter, which SubAccounts to fetch.
     */
    where?: SubAccountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubAccounts to fetch.
     */
    orderBy?: SubAccountsOrderByWithRelationInput | SubAccountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubAccounts.
     */
    cursor?: SubAccountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubAccounts.
     */
    distinct?: SubAccountsScalarFieldEnum | SubAccountsScalarFieldEnum[]
  }

  /**
   * SubAccounts findMany
   */
  export type SubAccountsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccounts
     */
    select?: SubAccountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccounts
     */
    omit?: SubAccountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountsInclude<ExtArgs> | null
    /**
     * Filter, which SubAccounts to fetch.
     */
    where?: SubAccountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubAccounts to fetch.
     */
    orderBy?: SubAccountsOrderByWithRelationInput | SubAccountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubAccounts.
     */
    cursor?: SubAccountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubAccounts.
     */
    skip?: number
    distinct?: SubAccountsScalarFieldEnum | SubAccountsScalarFieldEnum[]
  }

  /**
   * SubAccounts create
   */
  export type SubAccountsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccounts
     */
    select?: SubAccountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccounts
     */
    omit?: SubAccountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountsInclude<ExtArgs> | null
    /**
     * The data needed to create a SubAccounts.
     */
    data: XOR<SubAccountsCreateInput, SubAccountsUncheckedCreateInput>
  }

  /**
   * SubAccounts createMany
   */
  export type SubAccountsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubAccounts.
     */
    data: SubAccountsCreateManyInput | SubAccountsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubAccounts createManyAndReturn
   */
  export type SubAccountsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccounts
     */
    select?: SubAccountsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccounts
     */
    omit?: SubAccountsOmit<ExtArgs> | null
    /**
     * The data used to create many SubAccounts.
     */
    data: SubAccountsCreateManyInput | SubAccountsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubAccounts update
   */
  export type SubAccountsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccounts
     */
    select?: SubAccountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccounts
     */
    omit?: SubAccountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountsInclude<ExtArgs> | null
    /**
     * The data needed to update a SubAccounts.
     */
    data: XOR<SubAccountsUpdateInput, SubAccountsUncheckedUpdateInput>
    /**
     * Choose, which SubAccounts to update.
     */
    where: SubAccountsWhereUniqueInput
  }

  /**
   * SubAccounts updateMany
   */
  export type SubAccountsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubAccounts.
     */
    data: XOR<SubAccountsUpdateManyMutationInput, SubAccountsUncheckedUpdateManyInput>
    /**
     * Filter which SubAccounts to update
     */
    where?: SubAccountsWhereInput
    /**
     * Limit how many SubAccounts to update.
     */
    limit?: number
  }

  /**
   * SubAccounts updateManyAndReturn
   */
  export type SubAccountsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccounts
     */
    select?: SubAccountsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccounts
     */
    omit?: SubAccountsOmit<ExtArgs> | null
    /**
     * The data used to update SubAccounts.
     */
    data: XOR<SubAccountsUpdateManyMutationInput, SubAccountsUncheckedUpdateManyInput>
    /**
     * Filter which SubAccounts to update
     */
    where?: SubAccountsWhereInput
    /**
     * Limit how many SubAccounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubAccounts upsert
   */
  export type SubAccountsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccounts
     */
    select?: SubAccountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccounts
     */
    omit?: SubAccountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountsInclude<ExtArgs> | null
    /**
     * The filter to search for the SubAccounts to update in case it exists.
     */
    where: SubAccountsWhereUniqueInput
    /**
     * In case the SubAccounts found by the `where` argument doesn't exist, create a new SubAccounts with this data.
     */
    create: XOR<SubAccountsCreateInput, SubAccountsUncheckedCreateInput>
    /**
     * In case the SubAccounts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubAccountsUpdateInput, SubAccountsUncheckedUpdateInput>
  }

  /**
   * SubAccounts delete
   */
  export type SubAccountsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccounts
     */
    select?: SubAccountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccounts
     */
    omit?: SubAccountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountsInclude<ExtArgs> | null
    /**
     * Filter which SubAccounts to delete.
     */
    where: SubAccountsWhereUniqueInput
  }

  /**
   * SubAccounts deleteMany
   */
  export type SubAccountsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubAccounts to delete
     */
    where?: SubAccountsWhereInput
    /**
     * Limit how many SubAccounts to delete.
     */
    limit?: number
  }

  /**
   * SubAccounts.SidebarOption
   */
  export type SubAccounts$SidebarOptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgencySidebarOption
     */
    select?: AgencySidebarOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgencySidebarOption
     */
    omit?: AgencySidebarOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencySidebarOptionInclude<ExtArgs> | null
    where?: AgencySidebarOptionWhereInput
    orderBy?: AgencySidebarOptionOrderByWithRelationInput | AgencySidebarOptionOrderByWithRelationInput[]
    cursor?: AgencySidebarOptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgencySidebarOptionScalarFieldEnum | AgencySidebarOptionScalarFieldEnum[]
  }

  /**
   * SubAccounts.Permissions
   */
  export type SubAccounts$PermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permissions
     */
    select?: PermissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permissions
     */
    omit?: PermissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionsInclude<ExtArgs> | null
    where?: PermissionsWhereInput
    orderBy?: PermissionsOrderByWithRelationInput | PermissionsOrderByWithRelationInput[]
    cursor?: PermissionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PermissionsScalarFieldEnum | PermissionsScalarFieldEnum[]
  }

  /**
   * SubAccounts.Funnels
   */
  export type SubAccounts$FunnelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Funnels
     */
    select?: FunnelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Funnels
     */
    omit?: FunnelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelsInclude<ExtArgs> | null
    where?: FunnelsWhereInput
    orderBy?: FunnelsOrderByWithRelationInput | FunnelsOrderByWithRelationInput[]
    cursor?: FunnelsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FunnelsScalarFieldEnum | FunnelsScalarFieldEnum[]
  }

  /**
   * SubAccounts.Media
   */
  export type SubAccounts$MediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    cursor?: MediaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * SubAccounts.Contact
   */
  export type SubAccounts$ContactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contacts
     */
    select?: ContactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contacts
     */
    omit?: ContactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactsInclude<ExtArgs> | null
    where?: ContactsWhereInput
    orderBy?: ContactsOrderByWithRelationInput | ContactsOrderByWithRelationInput[]
    cursor?: ContactsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactsScalarFieldEnum | ContactsScalarFieldEnum[]
  }

  /**
   * SubAccounts.Trigger
   */
  export type SubAccounts$TriggerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Triggers
     */
    select?: TriggersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Triggers
     */
    omit?: TriggersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriggersInclude<ExtArgs> | null
    where?: TriggersWhereInput
    orderBy?: TriggersOrderByWithRelationInput | TriggersOrderByWithRelationInput[]
    cursor?: TriggersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TriggersScalarFieldEnum | TriggersScalarFieldEnum[]
  }

  /**
   * SubAccounts.Automation
   */
  export type SubAccounts$AutomationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automations
     */
    select?: AutomationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Automations
     */
    omit?: AutomationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationsInclude<ExtArgs> | null
    where?: AutomationsWhereInput
    orderBy?: AutomationsOrderByWithRelationInput | AutomationsOrderByWithRelationInput[]
    cursor?: AutomationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AutomationsScalarFieldEnum | AutomationsScalarFieldEnum[]
  }

  /**
   * SubAccounts.Pipeline
   */
  export type SubAccounts$PipelineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipelines
     */
    select?: PipelinesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipelines
     */
    omit?: PipelinesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelinesInclude<ExtArgs> | null
    where?: PipelinesWhereInput
    orderBy?: PipelinesOrderByWithRelationInput | PipelinesOrderByWithRelationInput[]
    cursor?: PipelinesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PipelinesScalarFieldEnum | PipelinesScalarFieldEnum[]
  }

  /**
   * SubAccounts.Tags
   */
  export type SubAccounts$TagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsInclude<ExtArgs> | null
    where?: TagsWhereInput
    orderBy?: TagsOrderByWithRelationInput | TagsOrderByWithRelationInput[]
    cursor?: TagsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagsScalarFieldEnum | TagsScalarFieldEnum[]
  }

  /**
   * SubAccounts.Notification
   */
  export type SubAccounts$NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    where?: NotificationsWhereInput
    orderBy?: NotificationsOrderByWithRelationInput | NotificationsOrderByWithRelationInput[]
    cursor?: NotificationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * SubAccounts.SubAccountSidebarOption
   */
  export type SubAccounts$SubAccountSidebarOptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccountSidebarOption
     */
    select?: SubAccountSidebarOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccountSidebarOption
     */
    omit?: SubAccountSidebarOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountSidebarOptionInclude<ExtArgs> | null
    where?: SubAccountSidebarOptionWhereInput
    orderBy?: SubAccountSidebarOptionOrderByWithRelationInput | SubAccountSidebarOptionOrderByWithRelationInput[]
    cursor?: SubAccountSidebarOptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubAccountSidebarOptionScalarFieldEnum | SubAccountSidebarOptionScalarFieldEnum[]
  }

  /**
   * SubAccounts without action
   */
  export type SubAccountsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccounts
     */
    select?: SubAccountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccounts
     */
    omit?: SubAccountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountsInclude<ExtArgs> | null
  }


  /**
   * Model Pipelines
   */

  export type AggregatePipelines = {
    _count: PipelinesCountAggregateOutputType | null
    _min: PipelinesMinAggregateOutputType | null
    _max: PipelinesMaxAggregateOutputType | null
  }

  export type PipelinesMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    subAccountId: string | null
  }

  export type PipelinesMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    subAccountId: string | null
  }

  export type PipelinesCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    subAccountId: number
    _all: number
  }


  export type PipelinesMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    subAccountId?: true
  }

  export type PipelinesMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    subAccountId?: true
  }

  export type PipelinesCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    subAccountId?: true
    _all?: true
  }

  export type PipelinesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pipelines to aggregate.
     */
    where?: PipelinesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pipelines to fetch.
     */
    orderBy?: PipelinesOrderByWithRelationInput | PipelinesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PipelinesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pipelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pipelines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pipelines
    **/
    _count?: true | PipelinesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PipelinesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PipelinesMaxAggregateInputType
  }

  export type GetPipelinesAggregateType<T extends PipelinesAggregateArgs> = {
        [P in keyof T & keyof AggregatePipelines]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePipelines[P]>
      : GetScalarType<T[P], AggregatePipelines[P]>
  }




  export type PipelinesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PipelinesWhereInput
    orderBy?: PipelinesOrderByWithAggregationInput | PipelinesOrderByWithAggregationInput[]
    by: PipelinesScalarFieldEnum[] | PipelinesScalarFieldEnum
    having?: PipelinesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PipelinesCountAggregateInputType | true
    _min?: PipelinesMinAggregateInputType
    _max?: PipelinesMaxAggregateInputType
  }

  export type PipelinesGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    updatedAt: Date
    subAccountId: string
    _count: PipelinesCountAggregateOutputType | null
    _min: PipelinesMinAggregateOutputType | null
    _max: PipelinesMaxAggregateOutputType | null
  }

  type GetPipelinesGroupByPayload<T extends PipelinesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PipelinesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PipelinesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PipelinesGroupByOutputType[P]>
            : GetScalarType<T[P], PipelinesGroupByOutputType[P]>
        }
      >
    >


  export type PipelinesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subAccountId?: boolean
    Lane?: boolean | Pipelines$LaneArgs<ExtArgs>
    SubAccount?: boolean | SubAccountsDefaultArgs<ExtArgs>
    _count?: boolean | PipelinesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pipelines"]>

  export type PipelinesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subAccountId?: boolean
    SubAccount?: boolean | SubAccountsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pipelines"]>

  export type PipelinesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subAccountId?: boolean
    SubAccount?: boolean | SubAccountsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pipelines"]>

  export type PipelinesSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subAccountId?: boolean
  }

  export type PipelinesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "updatedAt" | "subAccountId", ExtArgs["result"]["pipelines"]>
  export type PipelinesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Lane?: boolean | Pipelines$LaneArgs<ExtArgs>
    SubAccount?: boolean | SubAccountsDefaultArgs<ExtArgs>
    _count?: boolean | PipelinesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PipelinesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SubAccount?: boolean | SubAccountsDefaultArgs<ExtArgs>
  }
  export type PipelinesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SubAccount?: boolean | SubAccountsDefaultArgs<ExtArgs>
  }

  export type $PipelinesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Pipelines"
    objects: {
      Lane: Prisma.$LanePayload<ExtArgs>[]
      SubAccount: Prisma.$SubAccountsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
      updatedAt: Date
      subAccountId: string
    }, ExtArgs["result"]["pipelines"]>
    composites: {}
  }

  type PipelinesGetPayload<S extends boolean | null | undefined | PipelinesDefaultArgs> = $Result.GetResult<Prisma.$PipelinesPayload, S>

  type PipelinesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PipelinesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PipelinesCountAggregateInputType | true
    }

  export interface PipelinesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pipelines'], meta: { name: 'Pipelines' } }
    /**
     * Find zero or one Pipelines that matches the filter.
     * @param {PipelinesFindUniqueArgs} args - Arguments to find a Pipelines
     * @example
     * // Get one Pipelines
     * const pipelines = await prisma.pipelines.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PipelinesFindUniqueArgs>(args: SelectSubset<T, PipelinesFindUniqueArgs<ExtArgs>>): Prisma__PipelinesClient<$Result.GetResult<Prisma.$PipelinesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Pipelines that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PipelinesFindUniqueOrThrowArgs} args - Arguments to find a Pipelines
     * @example
     * // Get one Pipelines
     * const pipelines = await prisma.pipelines.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PipelinesFindUniqueOrThrowArgs>(args: SelectSubset<T, PipelinesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PipelinesClient<$Result.GetResult<Prisma.$PipelinesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pipelines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelinesFindFirstArgs} args - Arguments to find a Pipelines
     * @example
     * // Get one Pipelines
     * const pipelines = await prisma.pipelines.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PipelinesFindFirstArgs>(args?: SelectSubset<T, PipelinesFindFirstArgs<ExtArgs>>): Prisma__PipelinesClient<$Result.GetResult<Prisma.$PipelinesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pipelines that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelinesFindFirstOrThrowArgs} args - Arguments to find a Pipelines
     * @example
     * // Get one Pipelines
     * const pipelines = await prisma.pipelines.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PipelinesFindFirstOrThrowArgs>(args?: SelectSubset<T, PipelinesFindFirstOrThrowArgs<ExtArgs>>): Prisma__PipelinesClient<$Result.GetResult<Prisma.$PipelinesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Pipelines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelinesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pipelines
     * const pipelines = await prisma.pipelines.findMany()
     * 
     * // Get first 10 Pipelines
     * const pipelines = await prisma.pipelines.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pipelinesWithIdOnly = await prisma.pipelines.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PipelinesFindManyArgs>(args?: SelectSubset<T, PipelinesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PipelinesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Pipelines.
     * @param {PipelinesCreateArgs} args - Arguments to create a Pipelines.
     * @example
     * // Create one Pipelines
     * const Pipelines = await prisma.pipelines.create({
     *   data: {
     *     // ... data to create a Pipelines
     *   }
     * })
     * 
     */
    create<T extends PipelinesCreateArgs>(args: SelectSubset<T, PipelinesCreateArgs<ExtArgs>>): Prisma__PipelinesClient<$Result.GetResult<Prisma.$PipelinesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Pipelines.
     * @param {PipelinesCreateManyArgs} args - Arguments to create many Pipelines.
     * @example
     * // Create many Pipelines
     * const pipelines = await prisma.pipelines.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PipelinesCreateManyArgs>(args?: SelectSubset<T, PipelinesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pipelines and returns the data saved in the database.
     * @param {PipelinesCreateManyAndReturnArgs} args - Arguments to create many Pipelines.
     * @example
     * // Create many Pipelines
     * const pipelines = await prisma.pipelines.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pipelines and only return the `id`
     * const pipelinesWithIdOnly = await prisma.pipelines.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PipelinesCreateManyAndReturnArgs>(args?: SelectSubset<T, PipelinesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PipelinesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Pipelines.
     * @param {PipelinesDeleteArgs} args - Arguments to delete one Pipelines.
     * @example
     * // Delete one Pipelines
     * const Pipelines = await prisma.pipelines.delete({
     *   where: {
     *     // ... filter to delete one Pipelines
     *   }
     * })
     * 
     */
    delete<T extends PipelinesDeleteArgs>(args: SelectSubset<T, PipelinesDeleteArgs<ExtArgs>>): Prisma__PipelinesClient<$Result.GetResult<Prisma.$PipelinesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Pipelines.
     * @param {PipelinesUpdateArgs} args - Arguments to update one Pipelines.
     * @example
     * // Update one Pipelines
     * const pipelines = await prisma.pipelines.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PipelinesUpdateArgs>(args: SelectSubset<T, PipelinesUpdateArgs<ExtArgs>>): Prisma__PipelinesClient<$Result.GetResult<Prisma.$PipelinesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Pipelines.
     * @param {PipelinesDeleteManyArgs} args - Arguments to filter Pipelines to delete.
     * @example
     * // Delete a few Pipelines
     * const { count } = await prisma.pipelines.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PipelinesDeleteManyArgs>(args?: SelectSubset<T, PipelinesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pipelines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelinesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pipelines
     * const pipelines = await prisma.pipelines.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PipelinesUpdateManyArgs>(args: SelectSubset<T, PipelinesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pipelines and returns the data updated in the database.
     * @param {PipelinesUpdateManyAndReturnArgs} args - Arguments to update many Pipelines.
     * @example
     * // Update many Pipelines
     * const pipelines = await prisma.pipelines.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Pipelines and only return the `id`
     * const pipelinesWithIdOnly = await prisma.pipelines.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PipelinesUpdateManyAndReturnArgs>(args: SelectSubset<T, PipelinesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PipelinesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Pipelines.
     * @param {PipelinesUpsertArgs} args - Arguments to update or create a Pipelines.
     * @example
     * // Update or create a Pipelines
     * const pipelines = await prisma.pipelines.upsert({
     *   create: {
     *     // ... data to create a Pipelines
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pipelines we want to update
     *   }
     * })
     */
    upsert<T extends PipelinesUpsertArgs>(args: SelectSubset<T, PipelinesUpsertArgs<ExtArgs>>): Prisma__PipelinesClient<$Result.GetResult<Prisma.$PipelinesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Pipelines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelinesCountArgs} args - Arguments to filter Pipelines to count.
     * @example
     * // Count the number of Pipelines
     * const count = await prisma.pipelines.count({
     *   where: {
     *     // ... the filter for the Pipelines we want to count
     *   }
     * })
    **/
    count<T extends PipelinesCountArgs>(
      args?: Subset<T, PipelinesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PipelinesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pipelines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelinesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PipelinesAggregateArgs>(args: Subset<T, PipelinesAggregateArgs>): Prisma.PrismaPromise<GetPipelinesAggregateType<T>>

    /**
     * Group by Pipelines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelinesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PipelinesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PipelinesGroupByArgs['orderBy'] }
        : { orderBy?: PipelinesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PipelinesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPipelinesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Pipelines model
   */
  readonly fields: PipelinesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pipelines.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PipelinesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Lane<T extends Pipelines$LaneArgs<ExtArgs> = {}>(args?: Subset<T, Pipelines$LaneArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    SubAccount<T extends SubAccountsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubAccountsDefaultArgs<ExtArgs>>): Prisma__SubAccountsClient<$Result.GetResult<Prisma.$SubAccountsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Pipelines model
   */
  interface PipelinesFieldRefs {
    readonly id: FieldRef<"Pipelines", 'String'>
    readonly name: FieldRef<"Pipelines", 'String'>
    readonly createdAt: FieldRef<"Pipelines", 'DateTime'>
    readonly updatedAt: FieldRef<"Pipelines", 'DateTime'>
    readonly subAccountId: FieldRef<"Pipelines", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Pipelines findUnique
   */
  export type PipelinesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipelines
     */
    select?: PipelinesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipelines
     */
    omit?: PipelinesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelinesInclude<ExtArgs> | null
    /**
     * Filter, which Pipelines to fetch.
     */
    where: PipelinesWhereUniqueInput
  }

  /**
   * Pipelines findUniqueOrThrow
   */
  export type PipelinesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipelines
     */
    select?: PipelinesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipelines
     */
    omit?: PipelinesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelinesInclude<ExtArgs> | null
    /**
     * Filter, which Pipelines to fetch.
     */
    where: PipelinesWhereUniqueInput
  }

  /**
   * Pipelines findFirst
   */
  export type PipelinesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipelines
     */
    select?: PipelinesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipelines
     */
    omit?: PipelinesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelinesInclude<ExtArgs> | null
    /**
     * Filter, which Pipelines to fetch.
     */
    where?: PipelinesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pipelines to fetch.
     */
    orderBy?: PipelinesOrderByWithRelationInput | PipelinesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pipelines.
     */
    cursor?: PipelinesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pipelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pipelines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pipelines.
     */
    distinct?: PipelinesScalarFieldEnum | PipelinesScalarFieldEnum[]
  }

  /**
   * Pipelines findFirstOrThrow
   */
  export type PipelinesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipelines
     */
    select?: PipelinesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipelines
     */
    omit?: PipelinesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelinesInclude<ExtArgs> | null
    /**
     * Filter, which Pipelines to fetch.
     */
    where?: PipelinesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pipelines to fetch.
     */
    orderBy?: PipelinesOrderByWithRelationInput | PipelinesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pipelines.
     */
    cursor?: PipelinesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pipelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pipelines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pipelines.
     */
    distinct?: PipelinesScalarFieldEnum | PipelinesScalarFieldEnum[]
  }

  /**
   * Pipelines findMany
   */
  export type PipelinesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipelines
     */
    select?: PipelinesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipelines
     */
    omit?: PipelinesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelinesInclude<ExtArgs> | null
    /**
     * Filter, which Pipelines to fetch.
     */
    where?: PipelinesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pipelines to fetch.
     */
    orderBy?: PipelinesOrderByWithRelationInput | PipelinesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pipelines.
     */
    cursor?: PipelinesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pipelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pipelines.
     */
    skip?: number
    distinct?: PipelinesScalarFieldEnum | PipelinesScalarFieldEnum[]
  }

  /**
   * Pipelines create
   */
  export type PipelinesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipelines
     */
    select?: PipelinesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipelines
     */
    omit?: PipelinesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelinesInclude<ExtArgs> | null
    /**
     * The data needed to create a Pipelines.
     */
    data: XOR<PipelinesCreateInput, PipelinesUncheckedCreateInput>
  }

  /**
   * Pipelines createMany
   */
  export type PipelinesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pipelines.
     */
    data: PipelinesCreateManyInput | PipelinesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Pipelines createManyAndReturn
   */
  export type PipelinesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipelines
     */
    select?: PipelinesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Pipelines
     */
    omit?: PipelinesOmit<ExtArgs> | null
    /**
     * The data used to create many Pipelines.
     */
    data: PipelinesCreateManyInput | PipelinesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelinesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Pipelines update
   */
  export type PipelinesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipelines
     */
    select?: PipelinesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipelines
     */
    omit?: PipelinesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelinesInclude<ExtArgs> | null
    /**
     * The data needed to update a Pipelines.
     */
    data: XOR<PipelinesUpdateInput, PipelinesUncheckedUpdateInput>
    /**
     * Choose, which Pipelines to update.
     */
    where: PipelinesWhereUniqueInput
  }

  /**
   * Pipelines updateMany
   */
  export type PipelinesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pipelines.
     */
    data: XOR<PipelinesUpdateManyMutationInput, PipelinesUncheckedUpdateManyInput>
    /**
     * Filter which Pipelines to update
     */
    where?: PipelinesWhereInput
    /**
     * Limit how many Pipelines to update.
     */
    limit?: number
  }

  /**
   * Pipelines updateManyAndReturn
   */
  export type PipelinesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipelines
     */
    select?: PipelinesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Pipelines
     */
    omit?: PipelinesOmit<ExtArgs> | null
    /**
     * The data used to update Pipelines.
     */
    data: XOR<PipelinesUpdateManyMutationInput, PipelinesUncheckedUpdateManyInput>
    /**
     * Filter which Pipelines to update
     */
    where?: PipelinesWhereInput
    /**
     * Limit how many Pipelines to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelinesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Pipelines upsert
   */
  export type PipelinesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipelines
     */
    select?: PipelinesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipelines
     */
    omit?: PipelinesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelinesInclude<ExtArgs> | null
    /**
     * The filter to search for the Pipelines to update in case it exists.
     */
    where: PipelinesWhereUniqueInput
    /**
     * In case the Pipelines found by the `where` argument doesn't exist, create a new Pipelines with this data.
     */
    create: XOR<PipelinesCreateInput, PipelinesUncheckedCreateInput>
    /**
     * In case the Pipelines was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PipelinesUpdateInput, PipelinesUncheckedUpdateInput>
  }

  /**
   * Pipelines delete
   */
  export type PipelinesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipelines
     */
    select?: PipelinesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipelines
     */
    omit?: PipelinesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelinesInclude<ExtArgs> | null
    /**
     * Filter which Pipelines to delete.
     */
    where: PipelinesWhereUniqueInput
  }

  /**
   * Pipelines deleteMany
   */
  export type PipelinesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pipelines to delete
     */
    where?: PipelinesWhereInput
    /**
     * Limit how many Pipelines to delete.
     */
    limit?: number
  }

  /**
   * Pipelines.Lane
   */
  export type Pipelines$LaneArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lane
     */
    select?: LaneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lane
     */
    omit?: LaneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaneInclude<ExtArgs> | null
    where?: LaneWhereInput
    orderBy?: LaneOrderByWithRelationInput | LaneOrderByWithRelationInput[]
    cursor?: LaneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LaneScalarFieldEnum | LaneScalarFieldEnum[]
  }

  /**
   * Pipelines without action
   */
  export type PipelinesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipelines
     */
    select?: PipelinesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipelines
     */
    omit?: PipelinesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelinesInclude<ExtArgs> | null
  }


  /**
   * Model Triggers
   */

  export type AggregateTriggers = {
    _count: TriggersCountAggregateOutputType | null
    _min: TriggersMinAggregateOutputType | null
    _max: TriggersMaxAggregateOutputType | null
  }

  export type TriggersMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.TriggerTypes | null
    createdAt: Date | null
    updatedAt: Date | null
    subAccountId: string | null
  }

  export type TriggersMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.TriggerTypes | null
    createdAt: Date | null
    updatedAt: Date | null
    subAccountId: string | null
  }

  export type TriggersCountAggregateOutputType = {
    id: number
    name: number
    type: number
    createdAt: number
    updatedAt: number
    subAccountId: number
    _all: number
  }


  export type TriggersMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    subAccountId?: true
  }

  export type TriggersMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    subAccountId?: true
  }

  export type TriggersCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    subAccountId?: true
    _all?: true
  }

  export type TriggersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Triggers to aggregate.
     */
    where?: TriggersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Triggers to fetch.
     */
    orderBy?: TriggersOrderByWithRelationInput | TriggersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TriggersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Triggers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Triggers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Triggers
    **/
    _count?: true | TriggersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TriggersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TriggersMaxAggregateInputType
  }

  export type GetTriggersAggregateType<T extends TriggersAggregateArgs> = {
        [P in keyof T & keyof AggregateTriggers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTriggers[P]>
      : GetScalarType<T[P], AggregateTriggers[P]>
  }




  export type TriggersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TriggersWhereInput
    orderBy?: TriggersOrderByWithAggregationInput | TriggersOrderByWithAggregationInput[]
    by: TriggersScalarFieldEnum[] | TriggersScalarFieldEnum
    having?: TriggersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TriggersCountAggregateInputType | true
    _min?: TriggersMinAggregateInputType
    _max?: TriggersMaxAggregateInputType
  }

  export type TriggersGroupByOutputType = {
    id: string
    name: string
    type: $Enums.TriggerTypes
    createdAt: Date
    updatedAt: Date
    subAccountId: string
    _count: TriggersCountAggregateOutputType | null
    _min: TriggersMinAggregateOutputType | null
    _max: TriggersMaxAggregateOutputType | null
  }

  type GetTriggersGroupByPayload<T extends TriggersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TriggersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TriggersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TriggersGroupByOutputType[P]>
            : GetScalarType<T[P], TriggersGroupByOutputType[P]>
        }
      >
    >


  export type TriggersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subAccountId?: boolean
    SubAccounts?: boolean | SubAccountsDefaultArgs<ExtArgs>
    Automations?: boolean | Triggers$AutomationsArgs<ExtArgs>
    _count?: boolean | TriggersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["triggers"]>

  export type TriggersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subAccountId?: boolean
    SubAccounts?: boolean | SubAccountsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["triggers"]>

  export type TriggersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subAccountId?: boolean
    SubAccounts?: boolean | SubAccountsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["triggers"]>

  export type TriggersSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subAccountId?: boolean
  }

  export type TriggersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "createdAt" | "updatedAt" | "subAccountId", ExtArgs["result"]["triggers"]>
  export type TriggersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SubAccounts?: boolean | SubAccountsDefaultArgs<ExtArgs>
    Automations?: boolean | Triggers$AutomationsArgs<ExtArgs>
    _count?: boolean | TriggersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TriggersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SubAccounts?: boolean | SubAccountsDefaultArgs<ExtArgs>
  }
  export type TriggersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SubAccounts?: boolean | SubAccountsDefaultArgs<ExtArgs>
  }

  export type $TriggersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Triggers"
    objects: {
      SubAccounts: Prisma.$SubAccountsPayload<ExtArgs>
      Automations: Prisma.$AutomationsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: $Enums.TriggerTypes
      createdAt: Date
      updatedAt: Date
      subAccountId: string
    }, ExtArgs["result"]["triggers"]>
    composites: {}
  }

  type TriggersGetPayload<S extends boolean | null | undefined | TriggersDefaultArgs> = $Result.GetResult<Prisma.$TriggersPayload, S>

  type TriggersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TriggersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TriggersCountAggregateInputType | true
    }

  export interface TriggersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Triggers'], meta: { name: 'Triggers' } }
    /**
     * Find zero or one Triggers that matches the filter.
     * @param {TriggersFindUniqueArgs} args - Arguments to find a Triggers
     * @example
     * // Get one Triggers
     * const triggers = await prisma.triggers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TriggersFindUniqueArgs>(args: SelectSubset<T, TriggersFindUniqueArgs<ExtArgs>>): Prisma__TriggersClient<$Result.GetResult<Prisma.$TriggersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Triggers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TriggersFindUniqueOrThrowArgs} args - Arguments to find a Triggers
     * @example
     * // Get one Triggers
     * const triggers = await prisma.triggers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TriggersFindUniqueOrThrowArgs>(args: SelectSubset<T, TriggersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TriggersClient<$Result.GetResult<Prisma.$TriggersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Triggers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriggersFindFirstArgs} args - Arguments to find a Triggers
     * @example
     * // Get one Triggers
     * const triggers = await prisma.triggers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TriggersFindFirstArgs>(args?: SelectSubset<T, TriggersFindFirstArgs<ExtArgs>>): Prisma__TriggersClient<$Result.GetResult<Prisma.$TriggersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Triggers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriggersFindFirstOrThrowArgs} args - Arguments to find a Triggers
     * @example
     * // Get one Triggers
     * const triggers = await prisma.triggers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TriggersFindFirstOrThrowArgs>(args?: SelectSubset<T, TriggersFindFirstOrThrowArgs<ExtArgs>>): Prisma__TriggersClient<$Result.GetResult<Prisma.$TriggersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Triggers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriggersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Triggers
     * const triggers = await prisma.triggers.findMany()
     * 
     * // Get first 10 Triggers
     * const triggers = await prisma.triggers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const triggersWithIdOnly = await prisma.triggers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TriggersFindManyArgs>(args?: SelectSubset<T, TriggersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TriggersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Triggers.
     * @param {TriggersCreateArgs} args - Arguments to create a Triggers.
     * @example
     * // Create one Triggers
     * const Triggers = await prisma.triggers.create({
     *   data: {
     *     // ... data to create a Triggers
     *   }
     * })
     * 
     */
    create<T extends TriggersCreateArgs>(args: SelectSubset<T, TriggersCreateArgs<ExtArgs>>): Prisma__TriggersClient<$Result.GetResult<Prisma.$TriggersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Triggers.
     * @param {TriggersCreateManyArgs} args - Arguments to create many Triggers.
     * @example
     * // Create many Triggers
     * const triggers = await prisma.triggers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TriggersCreateManyArgs>(args?: SelectSubset<T, TriggersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Triggers and returns the data saved in the database.
     * @param {TriggersCreateManyAndReturnArgs} args - Arguments to create many Triggers.
     * @example
     * // Create many Triggers
     * const triggers = await prisma.triggers.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Triggers and only return the `id`
     * const triggersWithIdOnly = await prisma.triggers.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TriggersCreateManyAndReturnArgs>(args?: SelectSubset<T, TriggersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TriggersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Triggers.
     * @param {TriggersDeleteArgs} args - Arguments to delete one Triggers.
     * @example
     * // Delete one Triggers
     * const Triggers = await prisma.triggers.delete({
     *   where: {
     *     // ... filter to delete one Triggers
     *   }
     * })
     * 
     */
    delete<T extends TriggersDeleteArgs>(args: SelectSubset<T, TriggersDeleteArgs<ExtArgs>>): Prisma__TriggersClient<$Result.GetResult<Prisma.$TriggersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Triggers.
     * @param {TriggersUpdateArgs} args - Arguments to update one Triggers.
     * @example
     * // Update one Triggers
     * const triggers = await prisma.triggers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TriggersUpdateArgs>(args: SelectSubset<T, TriggersUpdateArgs<ExtArgs>>): Prisma__TriggersClient<$Result.GetResult<Prisma.$TriggersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Triggers.
     * @param {TriggersDeleteManyArgs} args - Arguments to filter Triggers to delete.
     * @example
     * // Delete a few Triggers
     * const { count } = await prisma.triggers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TriggersDeleteManyArgs>(args?: SelectSubset<T, TriggersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Triggers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriggersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Triggers
     * const triggers = await prisma.triggers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TriggersUpdateManyArgs>(args: SelectSubset<T, TriggersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Triggers and returns the data updated in the database.
     * @param {TriggersUpdateManyAndReturnArgs} args - Arguments to update many Triggers.
     * @example
     * // Update many Triggers
     * const triggers = await prisma.triggers.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Triggers and only return the `id`
     * const triggersWithIdOnly = await prisma.triggers.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TriggersUpdateManyAndReturnArgs>(args: SelectSubset<T, TriggersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TriggersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Triggers.
     * @param {TriggersUpsertArgs} args - Arguments to update or create a Triggers.
     * @example
     * // Update or create a Triggers
     * const triggers = await prisma.triggers.upsert({
     *   create: {
     *     // ... data to create a Triggers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Triggers we want to update
     *   }
     * })
     */
    upsert<T extends TriggersUpsertArgs>(args: SelectSubset<T, TriggersUpsertArgs<ExtArgs>>): Prisma__TriggersClient<$Result.GetResult<Prisma.$TriggersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Triggers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriggersCountArgs} args - Arguments to filter Triggers to count.
     * @example
     * // Count the number of Triggers
     * const count = await prisma.triggers.count({
     *   where: {
     *     // ... the filter for the Triggers we want to count
     *   }
     * })
    **/
    count<T extends TriggersCountArgs>(
      args?: Subset<T, TriggersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TriggersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Triggers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriggersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TriggersAggregateArgs>(args: Subset<T, TriggersAggregateArgs>): Prisma.PrismaPromise<GetTriggersAggregateType<T>>

    /**
     * Group by Triggers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TriggersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TriggersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TriggersGroupByArgs['orderBy'] }
        : { orderBy?: TriggersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TriggersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTriggersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Triggers model
   */
  readonly fields: TriggersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Triggers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TriggersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    SubAccounts<T extends SubAccountsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubAccountsDefaultArgs<ExtArgs>>): Prisma__SubAccountsClient<$Result.GetResult<Prisma.$SubAccountsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Automations<T extends Triggers$AutomationsArgs<ExtArgs> = {}>(args?: Subset<T, Triggers$AutomationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Triggers model
   */
  interface TriggersFieldRefs {
    readonly id: FieldRef<"Triggers", 'String'>
    readonly name: FieldRef<"Triggers", 'String'>
    readonly type: FieldRef<"Triggers", 'TriggerTypes'>
    readonly createdAt: FieldRef<"Triggers", 'DateTime'>
    readonly updatedAt: FieldRef<"Triggers", 'DateTime'>
    readonly subAccountId: FieldRef<"Triggers", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Triggers findUnique
   */
  export type TriggersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Triggers
     */
    select?: TriggersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Triggers
     */
    omit?: TriggersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriggersInclude<ExtArgs> | null
    /**
     * Filter, which Triggers to fetch.
     */
    where: TriggersWhereUniqueInput
  }

  /**
   * Triggers findUniqueOrThrow
   */
  export type TriggersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Triggers
     */
    select?: TriggersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Triggers
     */
    omit?: TriggersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriggersInclude<ExtArgs> | null
    /**
     * Filter, which Triggers to fetch.
     */
    where: TriggersWhereUniqueInput
  }

  /**
   * Triggers findFirst
   */
  export type TriggersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Triggers
     */
    select?: TriggersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Triggers
     */
    omit?: TriggersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriggersInclude<ExtArgs> | null
    /**
     * Filter, which Triggers to fetch.
     */
    where?: TriggersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Triggers to fetch.
     */
    orderBy?: TriggersOrderByWithRelationInput | TriggersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Triggers.
     */
    cursor?: TriggersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Triggers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Triggers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Triggers.
     */
    distinct?: TriggersScalarFieldEnum | TriggersScalarFieldEnum[]
  }

  /**
   * Triggers findFirstOrThrow
   */
  export type TriggersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Triggers
     */
    select?: TriggersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Triggers
     */
    omit?: TriggersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriggersInclude<ExtArgs> | null
    /**
     * Filter, which Triggers to fetch.
     */
    where?: TriggersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Triggers to fetch.
     */
    orderBy?: TriggersOrderByWithRelationInput | TriggersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Triggers.
     */
    cursor?: TriggersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Triggers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Triggers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Triggers.
     */
    distinct?: TriggersScalarFieldEnum | TriggersScalarFieldEnum[]
  }

  /**
   * Triggers findMany
   */
  export type TriggersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Triggers
     */
    select?: TriggersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Triggers
     */
    omit?: TriggersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriggersInclude<ExtArgs> | null
    /**
     * Filter, which Triggers to fetch.
     */
    where?: TriggersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Triggers to fetch.
     */
    orderBy?: TriggersOrderByWithRelationInput | TriggersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Triggers.
     */
    cursor?: TriggersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Triggers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Triggers.
     */
    skip?: number
    distinct?: TriggersScalarFieldEnum | TriggersScalarFieldEnum[]
  }

  /**
   * Triggers create
   */
  export type TriggersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Triggers
     */
    select?: TriggersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Triggers
     */
    omit?: TriggersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriggersInclude<ExtArgs> | null
    /**
     * The data needed to create a Triggers.
     */
    data: XOR<TriggersCreateInput, TriggersUncheckedCreateInput>
  }

  /**
   * Triggers createMany
   */
  export type TriggersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Triggers.
     */
    data: TriggersCreateManyInput | TriggersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Triggers createManyAndReturn
   */
  export type TriggersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Triggers
     */
    select?: TriggersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Triggers
     */
    omit?: TriggersOmit<ExtArgs> | null
    /**
     * The data used to create many Triggers.
     */
    data: TriggersCreateManyInput | TriggersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriggersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Triggers update
   */
  export type TriggersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Triggers
     */
    select?: TriggersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Triggers
     */
    omit?: TriggersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriggersInclude<ExtArgs> | null
    /**
     * The data needed to update a Triggers.
     */
    data: XOR<TriggersUpdateInput, TriggersUncheckedUpdateInput>
    /**
     * Choose, which Triggers to update.
     */
    where: TriggersWhereUniqueInput
  }

  /**
   * Triggers updateMany
   */
  export type TriggersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Triggers.
     */
    data: XOR<TriggersUpdateManyMutationInput, TriggersUncheckedUpdateManyInput>
    /**
     * Filter which Triggers to update
     */
    where?: TriggersWhereInput
    /**
     * Limit how many Triggers to update.
     */
    limit?: number
  }

  /**
   * Triggers updateManyAndReturn
   */
  export type TriggersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Triggers
     */
    select?: TriggersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Triggers
     */
    omit?: TriggersOmit<ExtArgs> | null
    /**
     * The data used to update Triggers.
     */
    data: XOR<TriggersUpdateManyMutationInput, TriggersUncheckedUpdateManyInput>
    /**
     * Filter which Triggers to update
     */
    where?: TriggersWhereInput
    /**
     * Limit how many Triggers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriggersIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Triggers upsert
   */
  export type TriggersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Triggers
     */
    select?: TriggersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Triggers
     */
    omit?: TriggersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriggersInclude<ExtArgs> | null
    /**
     * The filter to search for the Triggers to update in case it exists.
     */
    where: TriggersWhereUniqueInput
    /**
     * In case the Triggers found by the `where` argument doesn't exist, create a new Triggers with this data.
     */
    create: XOR<TriggersCreateInput, TriggersUncheckedCreateInput>
    /**
     * In case the Triggers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TriggersUpdateInput, TriggersUncheckedUpdateInput>
  }

  /**
   * Triggers delete
   */
  export type TriggersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Triggers
     */
    select?: TriggersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Triggers
     */
    omit?: TriggersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriggersInclude<ExtArgs> | null
    /**
     * Filter which Triggers to delete.
     */
    where: TriggersWhereUniqueInput
  }

  /**
   * Triggers deleteMany
   */
  export type TriggersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Triggers to delete
     */
    where?: TriggersWhereInput
    /**
     * Limit how many Triggers to delete.
     */
    limit?: number
  }

  /**
   * Triggers.Automations
   */
  export type Triggers$AutomationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automations
     */
    select?: AutomationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Automations
     */
    omit?: AutomationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationsInclude<ExtArgs> | null
    where?: AutomationsWhereInput
    orderBy?: AutomationsOrderByWithRelationInput | AutomationsOrderByWithRelationInput[]
    cursor?: AutomationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AutomationsScalarFieldEnum | AutomationsScalarFieldEnum[]
  }

  /**
   * Triggers without action
   */
  export type TriggersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Triggers
     */
    select?: TriggersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Triggers
     */
    omit?: TriggersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriggersInclude<ExtArgs> | null
  }


  /**
   * Model Automations
   */

  export type AggregateAutomations = {
    _count: AutomationsCountAggregateOutputType | null
    _min: AutomationsMinAggregateOutputType | null
    _max: AutomationsMaxAggregateOutputType | null
  }

  export type AutomationsMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    triggerId: string | null
    published: boolean | null
    subAccountId: string | null
  }

  export type AutomationsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    triggerId: string | null
    published: boolean | null
    subAccountId: string | null
  }

  export type AutomationsCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    triggerId: number
    published: number
    subAccountId: number
    _all: number
  }


  export type AutomationsMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    triggerId?: true
    published?: true
    subAccountId?: true
  }

  export type AutomationsMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    triggerId?: true
    published?: true
    subAccountId?: true
  }

  export type AutomationsCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    triggerId?: true
    published?: true
    subAccountId?: true
    _all?: true
  }

  export type AutomationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Automations to aggregate.
     */
    where?: AutomationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Automations to fetch.
     */
    orderBy?: AutomationsOrderByWithRelationInput | AutomationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AutomationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Automations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Automations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Automations
    **/
    _count?: true | AutomationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AutomationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AutomationsMaxAggregateInputType
  }

  export type GetAutomationsAggregateType<T extends AutomationsAggregateArgs> = {
        [P in keyof T & keyof AggregateAutomations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAutomations[P]>
      : GetScalarType<T[P], AggregateAutomations[P]>
  }




  export type AutomationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutomationsWhereInput
    orderBy?: AutomationsOrderByWithAggregationInput | AutomationsOrderByWithAggregationInput[]
    by: AutomationsScalarFieldEnum[] | AutomationsScalarFieldEnum
    having?: AutomationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AutomationsCountAggregateInputType | true
    _min?: AutomationsMinAggregateInputType
    _max?: AutomationsMaxAggregateInputType
  }

  export type AutomationsGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    updatedAt: Date
    triggerId: string | null
    published: boolean
    subAccountId: string
    _count: AutomationsCountAggregateOutputType | null
    _min: AutomationsMinAggregateOutputType | null
    _max: AutomationsMaxAggregateOutputType | null
  }

  type GetAutomationsGroupByPayload<T extends AutomationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AutomationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AutomationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AutomationsGroupByOutputType[P]>
            : GetScalarType<T[P], AutomationsGroupByOutputType[P]>
        }
      >
    >


  export type AutomationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    triggerId?: boolean
    published?: boolean
    subAccountId?: boolean
    Trigger?: boolean | Automations$TriggerArgs<ExtArgs>
    SubAccounts?: boolean | SubAccountsDefaultArgs<ExtArgs>
    Actions?: boolean | Automations$ActionsArgs<ExtArgs>
    AutomationInstance?: boolean | Automations$AutomationInstanceArgs<ExtArgs>
    _count?: boolean | AutomationsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["automations"]>

  export type AutomationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    triggerId?: boolean
    published?: boolean
    subAccountId?: boolean
    Trigger?: boolean | Automations$TriggerArgs<ExtArgs>
    SubAccounts?: boolean | SubAccountsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["automations"]>

  export type AutomationsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    triggerId?: boolean
    published?: boolean
    subAccountId?: boolean
    Trigger?: boolean | Automations$TriggerArgs<ExtArgs>
    SubAccounts?: boolean | SubAccountsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["automations"]>

  export type AutomationsSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    triggerId?: boolean
    published?: boolean
    subAccountId?: boolean
  }

  export type AutomationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "updatedAt" | "triggerId" | "published" | "subAccountId", ExtArgs["result"]["automations"]>
  export type AutomationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Trigger?: boolean | Automations$TriggerArgs<ExtArgs>
    SubAccounts?: boolean | SubAccountsDefaultArgs<ExtArgs>
    Actions?: boolean | Automations$ActionsArgs<ExtArgs>
    AutomationInstance?: boolean | Automations$AutomationInstanceArgs<ExtArgs>
    _count?: boolean | AutomationsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AutomationsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Trigger?: boolean | Automations$TriggerArgs<ExtArgs>
    SubAccounts?: boolean | SubAccountsDefaultArgs<ExtArgs>
  }
  export type AutomationsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Trigger?: boolean | Automations$TriggerArgs<ExtArgs>
    SubAccounts?: boolean | SubAccountsDefaultArgs<ExtArgs>
  }

  export type $AutomationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Automations"
    objects: {
      Trigger: Prisma.$TriggersPayload<ExtArgs> | null
      SubAccounts: Prisma.$SubAccountsPayload<ExtArgs>
      Actions: Prisma.$ActionsPayload<ExtArgs>[]
      AutomationInstance: Prisma.$AutomationInstancePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
      updatedAt: Date
      triggerId: string | null
      published: boolean
      subAccountId: string
    }, ExtArgs["result"]["automations"]>
    composites: {}
  }

  type AutomationsGetPayload<S extends boolean | null | undefined | AutomationsDefaultArgs> = $Result.GetResult<Prisma.$AutomationsPayload, S>

  type AutomationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AutomationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AutomationsCountAggregateInputType | true
    }

  export interface AutomationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Automations'], meta: { name: 'Automations' } }
    /**
     * Find zero or one Automations that matches the filter.
     * @param {AutomationsFindUniqueArgs} args - Arguments to find a Automations
     * @example
     * // Get one Automations
     * const automations = await prisma.automations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AutomationsFindUniqueArgs>(args: SelectSubset<T, AutomationsFindUniqueArgs<ExtArgs>>): Prisma__AutomationsClient<$Result.GetResult<Prisma.$AutomationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Automations that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AutomationsFindUniqueOrThrowArgs} args - Arguments to find a Automations
     * @example
     * // Get one Automations
     * const automations = await prisma.automations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AutomationsFindUniqueOrThrowArgs>(args: SelectSubset<T, AutomationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AutomationsClient<$Result.GetResult<Prisma.$AutomationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Automations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationsFindFirstArgs} args - Arguments to find a Automations
     * @example
     * // Get one Automations
     * const automations = await prisma.automations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AutomationsFindFirstArgs>(args?: SelectSubset<T, AutomationsFindFirstArgs<ExtArgs>>): Prisma__AutomationsClient<$Result.GetResult<Prisma.$AutomationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Automations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationsFindFirstOrThrowArgs} args - Arguments to find a Automations
     * @example
     * // Get one Automations
     * const automations = await prisma.automations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AutomationsFindFirstOrThrowArgs>(args?: SelectSubset<T, AutomationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__AutomationsClient<$Result.GetResult<Prisma.$AutomationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Automations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Automations
     * const automations = await prisma.automations.findMany()
     * 
     * // Get first 10 Automations
     * const automations = await prisma.automations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const automationsWithIdOnly = await prisma.automations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AutomationsFindManyArgs>(args?: SelectSubset<T, AutomationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Automations.
     * @param {AutomationsCreateArgs} args - Arguments to create a Automations.
     * @example
     * // Create one Automations
     * const Automations = await prisma.automations.create({
     *   data: {
     *     // ... data to create a Automations
     *   }
     * })
     * 
     */
    create<T extends AutomationsCreateArgs>(args: SelectSubset<T, AutomationsCreateArgs<ExtArgs>>): Prisma__AutomationsClient<$Result.GetResult<Prisma.$AutomationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Automations.
     * @param {AutomationsCreateManyArgs} args - Arguments to create many Automations.
     * @example
     * // Create many Automations
     * const automations = await prisma.automations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AutomationsCreateManyArgs>(args?: SelectSubset<T, AutomationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Automations and returns the data saved in the database.
     * @param {AutomationsCreateManyAndReturnArgs} args - Arguments to create many Automations.
     * @example
     * // Create many Automations
     * const automations = await prisma.automations.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Automations and only return the `id`
     * const automationsWithIdOnly = await prisma.automations.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AutomationsCreateManyAndReturnArgs>(args?: SelectSubset<T, AutomationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Automations.
     * @param {AutomationsDeleteArgs} args - Arguments to delete one Automations.
     * @example
     * // Delete one Automations
     * const Automations = await prisma.automations.delete({
     *   where: {
     *     // ... filter to delete one Automations
     *   }
     * })
     * 
     */
    delete<T extends AutomationsDeleteArgs>(args: SelectSubset<T, AutomationsDeleteArgs<ExtArgs>>): Prisma__AutomationsClient<$Result.GetResult<Prisma.$AutomationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Automations.
     * @param {AutomationsUpdateArgs} args - Arguments to update one Automations.
     * @example
     * // Update one Automations
     * const automations = await prisma.automations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AutomationsUpdateArgs>(args: SelectSubset<T, AutomationsUpdateArgs<ExtArgs>>): Prisma__AutomationsClient<$Result.GetResult<Prisma.$AutomationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Automations.
     * @param {AutomationsDeleteManyArgs} args - Arguments to filter Automations to delete.
     * @example
     * // Delete a few Automations
     * const { count } = await prisma.automations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AutomationsDeleteManyArgs>(args?: SelectSubset<T, AutomationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Automations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Automations
     * const automations = await prisma.automations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AutomationsUpdateManyArgs>(args: SelectSubset<T, AutomationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Automations and returns the data updated in the database.
     * @param {AutomationsUpdateManyAndReturnArgs} args - Arguments to update many Automations.
     * @example
     * // Update many Automations
     * const automations = await prisma.automations.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Automations and only return the `id`
     * const automationsWithIdOnly = await prisma.automations.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AutomationsUpdateManyAndReturnArgs>(args: SelectSubset<T, AutomationsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Automations.
     * @param {AutomationsUpsertArgs} args - Arguments to update or create a Automations.
     * @example
     * // Update or create a Automations
     * const automations = await prisma.automations.upsert({
     *   create: {
     *     // ... data to create a Automations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Automations we want to update
     *   }
     * })
     */
    upsert<T extends AutomationsUpsertArgs>(args: SelectSubset<T, AutomationsUpsertArgs<ExtArgs>>): Prisma__AutomationsClient<$Result.GetResult<Prisma.$AutomationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Automations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationsCountArgs} args - Arguments to filter Automations to count.
     * @example
     * // Count the number of Automations
     * const count = await prisma.automations.count({
     *   where: {
     *     // ... the filter for the Automations we want to count
     *   }
     * })
    **/
    count<T extends AutomationsCountArgs>(
      args?: Subset<T, AutomationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AutomationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Automations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AutomationsAggregateArgs>(args: Subset<T, AutomationsAggregateArgs>): Prisma.PrismaPromise<GetAutomationsAggregateType<T>>

    /**
     * Group by Automations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AutomationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AutomationsGroupByArgs['orderBy'] }
        : { orderBy?: AutomationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AutomationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAutomationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Automations model
   */
  readonly fields: AutomationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Automations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AutomationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Trigger<T extends Automations$TriggerArgs<ExtArgs> = {}>(args?: Subset<T, Automations$TriggerArgs<ExtArgs>>): Prisma__TriggersClient<$Result.GetResult<Prisma.$TriggersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    SubAccounts<T extends SubAccountsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubAccountsDefaultArgs<ExtArgs>>): Prisma__SubAccountsClient<$Result.GetResult<Prisma.$SubAccountsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Actions<T extends Automations$ActionsArgs<ExtArgs> = {}>(args?: Subset<T, Automations$ActionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    AutomationInstance<T extends Automations$AutomationInstanceArgs<ExtArgs> = {}>(args?: Subset<T, Automations$AutomationInstanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationInstancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Automations model
   */
  interface AutomationsFieldRefs {
    readonly id: FieldRef<"Automations", 'String'>
    readonly name: FieldRef<"Automations", 'String'>
    readonly createdAt: FieldRef<"Automations", 'DateTime'>
    readonly updatedAt: FieldRef<"Automations", 'DateTime'>
    readonly triggerId: FieldRef<"Automations", 'String'>
    readonly published: FieldRef<"Automations", 'Boolean'>
    readonly subAccountId: FieldRef<"Automations", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Automations findUnique
   */
  export type AutomationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automations
     */
    select?: AutomationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Automations
     */
    omit?: AutomationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationsInclude<ExtArgs> | null
    /**
     * Filter, which Automations to fetch.
     */
    where: AutomationsWhereUniqueInput
  }

  /**
   * Automations findUniqueOrThrow
   */
  export type AutomationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automations
     */
    select?: AutomationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Automations
     */
    omit?: AutomationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationsInclude<ExtArgs> | null
    /**
     * Filter, which Automations to fetch.
     */
    where: AutomationsWhereUniqueInput
  }

  /**
   * Automations findFirst
   */
  export type AutomationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automations
     */
    select?: AutomationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Automations
     */
    omit?: AutomationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationsInclude<ExtArgs> | null
    /**
     * Filter, which Automations to fetch.
     */
    where?: AutomationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Automations to fetch.
     */
    orderBy?: AutomationsOrderByWithRelationInput | AutomationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Automations.
     */
    cursor?: AutomationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Automations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Automations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Automations.
     */
    distinct?: AutomationsScalarFieldEnum | AutomationsScalarFieldEnum[]
  }

  /**
   * Automations findFirstOrThrow
   */
  export type AutomationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automations
     */
    select?: AutomationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Automations
     */
    omit?: AutomationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationsInclude<ExtArgs> | null
    /**
     * Filter, which Automations to fetch.
     */
    where?: AutomationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Automations to fetch.
     */
    orderBy?: AutomationsOrderByWithRelationInput | AutomationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Automations.
     */
    cursor?: AutomationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Automations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Automations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Automations.
     */
    distinct?: AutomationsScalarFieldEnum | AutomationsScalarFieldEnum[]
  }

  /**
   * Automations findMany
   */
  export type AutomationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automations
     */
    select?: AutomationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Automations
     */
    omit?: AutomationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationsInclude<ExtArgs> | null
    /**
     * Filter, which Automations to fetch.
     */
    where?: AutomationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Automations to fetch.
     */
    orderBy?: AutomationsOrderByWithRelationInput | AutomationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Automations.
     */
    cursor?: AutomationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Automations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Automations.
     */
    skip?: number
    distinct?: AutomationsScalarFieldEnum | AutomationsScalarFieldEnum[]
  }

  /**
   * Automations create
   */
  export type AutomationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automations
     */
    select?: AutomationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Automations
     */
    omit?: AutomationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationsInclude<ExtArgs> | null
    /**
     * The data needed to create a Automations.
     */
    data: XOR<AutomationsCreateInput, AutomationsUncheckedCreateInput>
  }

  /**
   * Automations createMany
   */
  export type AutomationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Automations.
     */
    data: AutomationsCreateManyInput | AutomationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Automations createManyAndReturn
   */
  export type AutomationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automations
     */
    select?: AutomationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Automations
     */
    omit?: AutomationsOmit<ExtArgs> | null
    /**
     * The data used to create many Automations.
     */
    data: AutomationsCreateManyInput | AutomationsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Automations update
   */
  export type AutomationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automations
     */
    select?: AutomationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Automations
     */
    omit?: AutomationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationsInclude<ExtArgs> | null
    /**
     * The data needed to update a Automations.
     */
    data: XOR<AutomationsUpdateInput, AutomationsUncheckedUpdateInput>
    /**
     * Choose, which Automations to update.
     */
    where: AutomationsWhereUniqueInput
  }

  /**
   * Automations updateMany
   */
  export type AutomationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Automations.
     */
    data: XOR<AutomationsUpdateManyMutationInput, AutomationsUncheckedUpdateManyInput>
    /**
     * Filter which Automations to update
     */
    where?: AutomationsWhereInput
    /**
     * Limit how many Automations to update.
     */
    limit?: number
  }

  /**
   * Automations updateManyAndReturn
   */
  export type AutomationsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automations
     */
    select?: AutomationsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Automations
     */
    omit?: AutomationsOmit<ExtArgs> | null
    /**
     * The data used to update Automations.
     */
    data: XOR<AutomationsUpdateManyMutationInput, AutomationsUncheckedUpdateManyInput>
    /**
     * Filter which Automations to update
     */
    where?: AutomationsWhereInput
    /**
     * Limit how many Automations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Automations upsert
   */
  export type AutomationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automations
     */
    select?: AutomationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Automations
     */
    omit?: AutomationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationsInclude<ExtArgs> | null
    /**
     * The filter to search for the Automations to update in case it exists.
     */
    where: AutomationsWhereUniqueInput
    /**
     * In case the Automations found by the `where` argument doesn't exist, create a new Automations with this data.
     */
    create: XOR<AutomationsCreateInput, AutomationsUncheckedCreateInput>
    /**
     * In case the Automations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AutomationsUpdateInput, AutomationsUncheckedUpdateInput>
  }

  /**
   * Automations delete
   */
  export type AutomationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automations
     */
    select?: AutomationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Automations
     */
    omit?: AutomationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationsInclude<ExtArgs> | null
    /**
     * Filter which Automations to delete.
     */
    where: AutomationsWhereUniqueInput
  }

  /**
   * Automations deleteMany
   */
  export type AutomationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Automations to delete
     */
    where?: AutomationsWhereInput
    /**
     * Limit how many Automations to delete.
     */
    limit?: number
  }

  /**
   * Automations.Trigger
   */
  export type Automations$TriggerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Triggers
     */
    select?: TriggersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Triggers
     */
    omit?: TriggersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TriggersInclude<ExtArgs> | null
    where?: TriggersWhereInput
  }

  /**
   * Automations.Actions
   */
  export type Automations$ActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Actions
     */
    select?: ActionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Actions
     */
    omit?: ActionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionsInclude<ExtArgs> | null
    where?: ActionsWhereInput
    orderBy?: ActionsOrderByWithRelationInput | ActionsOrderByWithRelationInput[]
    cursor?: ActionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActionsScalarFieldEnum | ActionsScalarFieldEnum[]
  }

  /**
   * Automations.AutomationInstance
   */
  export type Automations$AutomationInstanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationInstance
     */
    select?: AutomationInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationInstance
     */
    omit?: AutomationInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInstanceInclude<ExtArgs> | null
    where?: AutomationInstanceWhereInput
    orderBy?: AutomationInstanceOrderByWithRelationInput | AutomationInstanceOrderByWithRelationInput[]
    cursor?: AutomationInstanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AutomationInstanceScalarFieldEnum | AutomationInstanceScalarFieldEnum[]
  }

  /**
   * Automations without action
   */
  export type AutomationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Automations
     */
    select?: AutomationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Automations
     */
    omit?: AutomationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationsInclude<ExtArgs> | null
  }


  /**
   * Model AutomationInstance
   */

  export type AggregateAutomationInstance = {
    _count: AutomationInstanceCountAggregateOutputType | null
    _min: AutomationInstanceMinAggregateOutputType | null
    _max: AutomationInstanceMaxAggregateOutputType | null
  }

  export type AutomationInstanceMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    automationId: string | null
    active: boolean | null
  }

  export type AutomationInstanceMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    automationId: string | null
    active: boolean | null
  }

  export type AutomationInstanceCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    automationId: number
    active: number
    _all: number
  }


  export type AutomationInstanceMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    automationId?: true
    active?: true
  }

  export type AutomationInstanceMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    automationId?: true
    active?: true
  }

  export type AutomationInstanceCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    automationId?: true
    active?: true
    _all?: true
  }

  export type AutomationInstanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AutomationInstance to aggregate.
     */
    where?: AutomationInstanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutomationInstances to fetch.
     */
    orderBy?: AutomationInstanceOrderByWithRelationInput | AutomationInstanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AutomationInstanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutomationInstances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutomationInstances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AutomationInstances
    **/
    _count?: true | AutomationInstanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AutomationInstanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AutomationInstanceMaxAggregateInputType
  }

  export type GetAutomationInstanceAggregateType<T extends AutomationInstanceAggregateArgs> = {
        [P in keyof T & keyof AggregateAutomationInstance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAutomationInstance[P]>
      : GetScalarType<T[P], AggregateAutomationInstance[P]>
  }




  export type AutomationInstanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutomationInstanceWhereInput
    orderBy?: AutomationInstanceOrderByWithAggregationInput | AutomationInstanceOrderByWithAggregationInput[]
    by: AutomationInstanceScalarFieldEnum[] | AutomationInstanceScalarFieldEnum
    having?: AutomationInstanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AutomationInstanceCountAggregateInputType | true
    _min?: AutomationInstanceMinAggregateInputType
    _max?: AutomationInstanceMaxAggregateInputType
  }

  export type AutomationInstanceGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    automationId: string
    active: boolean
    _count: AutomationInstanceCountAggregateOutputType | null
    _min: AutomationInstanceMinAggregateOutputType | null
    _max: AutomationInstanceMaxAggregateOutputType | null
  }

  type GetAutomationInstanceGroupByPayload<T extends AutomationInstanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AutomationInstanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AutomationInstanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AutomationInstanceGroupByOutputType[P]>
            : GetScalarType<T[P], AutomationInstanceGroupByOutputType[P]>
        }
      >
    >


  export type AutomationInstanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    automationId?: boolean
    active?: boolean
    Automations?: boolean | AutomationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["automationInstance"]>

  export type AutomationInstanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    automationId?: boolean
    active?: boolean
    Automations?: boolean | AutomationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["automationInstance"]>

  export type AutomationInstanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    automationId?: boolean
    active?: boolean
    Automations?: boolean | AutomationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["automationInstance"]>

  export type AutomationInstanceSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    automationId?: boolean
    active?: boolean
  }

  export type AutomationInstanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "automationId" | "active", ExtArgs["result"]["automationInstance"]>
  export type AutomationInstanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Automations?: boolean | AutomationsDefaultArgs<ExtArgs>
  }
  export type AutomationInstanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Automations?: boolean | AutomationsDefaultArgs<ExtArgs>
  }
  export type AutomationInstanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Automations?: boolean | AutomationsDefaultArgs<ExtArgs>
  }

  export type $AutomationInstancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AutomationInstance"
    objects: {
      Automations: Prisma.$AutomationsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      automationId: string
      active: boolean
    }, ExtArgs["result"]["automationInstance"]>
    composites: {}
  }

  type AutomationInstanceGetPayload<S extends boolean | null | undefined | AutomationInstanceDefaultArgs> = $Result.GetResult<Prisma.$AutomationInstancePayload, S>

  type AutomationInstanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AutomationInstanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AutomationInstanceCountAggregateInputType | true
    }

  export interface AutomationInstanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AutomationInstance'], meta: { name: 'AutomationInstance' } }
    /**
     * Find zero or one AutomationInstance that matches the filter.
     * @param {AutomationInstanceFindUniqueArgs} args - Arguments to find a AutomationInstance
     * @example
     * // Get one AutomationInstance
     * const automationInstance = await prisma.automationInstance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AutomationInstanceFindUniqueArgs>(args: SelectSubset<T, AutomationInstanceFindUniqueArgs<ExtArgs>>): Prisma__AutomationInstanceClient<$Result.GetResult<Prisma.$AutomationInstancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AutomationInstance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AutomationInstanceFindUniqueOrThrowArgs} args - Arguments to find a AutomationInstance
     * @example
     * // Get one AutomationInstance
     * const automationInstance = await prisma.automationInstance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AutomationInstanceFindUniqueOrThrowArgs>(args: SelectSubset<T, AutomationInstanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AutomationInstanceClient<$Result.GetResult<Prisma.$AutomationInstancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AutomationInstance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationInstanceFindFirstArgs} args - Arguments to find a AutomationInstance
     * @example
     * // Get one AutomationInstance
     * const automationInstance = await prisma.automationInstance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AutomationInstanceFindFirstArgs>(args?: SelectSubset<T, AutomationInstanceFindFirstArgs<ExtArgs>>): Prisma__AutomationInstanceClient<$Result.GetResult<Prisma.$AutomationInstancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AutomationInstance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationInstanceFindFirstOrThrowArgs} args - Arguments to find a AutomationInstance
     * @example
     * // Get one AutomationInstance
     * const automationInstance = await prisma.automationInstance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AutomationInstanceFindFirstOrThrowArgs>(args?: SelectSubset<T, AutomationInstanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__AutomationInstanceClient<$Result.GetResult<Prisma.$AutomationInstancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AutomationInstances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationInstanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AutomationInstances
     * const automationInstances = await prisma.automationInstance.findMany()
     * 
     * // Get first 10 AutomationInstances
     * const automationInstances = await prisma.automationInstance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const automationInstanceWithIdOnly = await prisma.automationInstance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AutomationInstanceFindManyArgs>(args?: SelectSubset<T, AutomationInstanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationInstancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AutomationInstance.
     * @param {AutomationInstanceCreateArgs} args - Arguments to create a AutomationInstance.
     * @example
     * // Create one AutomationInstance
     * const AutomationInstance = await prisma.automationInstance.create({
     *   data: {
     *     // ... data to create a AutomationInstance
     *   }
     * })
     * 
     */
    create<T extends AutomationInstanceCreateArgs>(args: SelectSubset<T, AutomationInstanceCreateArgs<ExtArgs>>): Prisma__AutomationInstanceClient<$Result.GetResult<Prisma.$AutomationInstancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AutomationInstances.
     * @param {AutomationInstanceCreateManyArgs} args - Arguments to create many AutomationInstances.
     * @example
     * // Create many AutomationInstances
     * const automationInstance = await prisma.automationInstance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AutomationInstanceCreateManyArgs>(args?: SelectSubset<T, AutomationInstanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AutomationInstances and returns the data saved in the database.
     * @param {AutomationInstanceCreateManyAndReturnArgs} args - Arguments to create many AutomationInstances.
     * @example
     * // Create many AutomationInstances
     * const automationInstance = await prisma.automationInstance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AutomationInstances and only return the `id`
     * const automationInstanceWithIdOnly = await prisma.automationInstance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AutomationInstanceCreateManyAndReturnArgs>(args?: SelectSubset<T, AutomationInstanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationInstancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AutomationInstance.
     * @param {AutomationInstanceDeleteArgs} args - Arguments to delete one AutomationInstance.
     * @example
     * // Delete one AutomationInstance
     * const AutomationInstance = await prisma.automationInstance.delete({
     *   where: {
     *     // ... filter to delete one AutomationInstance
     *   }
     * })
     * 
     */
    delete<T extends AutomationInstanceDeleteArgs>(args: SelectSubset<T, AutomationInstanceDeleteArgs<ExtArgs>>): Prisma__AutomationInstanceClient<$Result.GetResult<Prisma.$AutomationInstancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AutomationInstance.
     * @param {AutomationInstanceUpdateArgs} args - Arguments to update one AutomationInstance.
     * @example
     * // Update one AutomationInstance
     * const automationInstance = await prisma.automationInstance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AutomationInstanceUpdateArgs>(args: SelectSubset<T, AutomationInstanceUpdateArgs<ExtArgs>>): Prisma__AutomationInstanceClient<$Result.GetResult<Prisma.$AutomationInstancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AutomationInstances.
     * @param {AutomationInstanceDeleteManyArgs} args - Arguments to filter AutomationInstances to delete.
     * @example
     * // Delete a few AutomationInstances
     * const { count } = await prisma.automationInstance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AutomationInstanceDeleteManyArgs>(args?: SelectSubset<T, AutomationInstanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AutomationInstances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationInstanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AutomationInstances
     * const automationInstance = await prisma.automationInstance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AutomationInstanceUpdateManyArgs>(args: SelectSubset<T, AutomationInstanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AutomationInstances and returns the data updated in the database.
     * @param {AutomationInstanceUpdateManyAndReturnArgs} args - Arguments to update many AutomationInstances.
     * @example
     * // Update many AutomationInstances
     * const automationInstance = await prisma.automationInstance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AutomationInstances and only return the `id`
     * const automationInstanceWithIdOnly = await prisma.automationInstance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AutomationInstanceUpdateManyAndReturnArgs>(args: SelectSubset<T, AutomationInstanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutomationInstancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AutomationInstance.
     * @param {AutomationInstanceUpsertArgs} args - Arguments to update or create a AutomationInstance.
     * @example
     * // Update or create a AutomationInstance
     * const automationInstance = await prisma.automationInstance.upsert({
     *   create: {
     *     // ... data to create a AutomationInstance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AutomationInstance we want to update
     *   }
     * })
     */
    upsert<T extends AutomationInstanceUpsertArgs>(args: SelectSubset<T, AutomationInstanceUpsertArgs<ExtArgs>>): Prisma__AutomationInstanceClient<$Result.GetResult<Prisma.$AutomationInstancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AutomationInstances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationInstanceCountArgs} args - Arguments to filter AutomationInstances to count.
     * @example
     * // Count the number of AutomationInstances
     * const count = await prisma.automationInstance.count({
     *   where: {
     *     // ... the filter for the AutomationInstances we want to count
     *   }
     * })
    **/
    count<T extends AutomationInstanceCountArgs>(
      args?: Subset<T, AutomationInstanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AutomationInstanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AutomationInstance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationInstanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AutomationInstanceAggregateArgs>(args: Subset<T, AutomationInstanceAggregateArgs>): Prisma.PrismaPromise<GetAutomationInstanceAggregateType<T>>

    /**
     * Group by AutomationInstance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutomationInstanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AutomationInstanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AutomationInstanceGroupByArgs['orderBy'] }
        : { orderBy?: AutomationInstanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AutomationInstanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAutomationInstanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AutomationInstance model
   */
  readonly fields: AutomationInstanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AutomationInstance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AutomationInstanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Automations<T extends AutomationsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AutomationsDefaultArgs<ExtArgs>>): Prisma__AutomationsClient<$Result.GetResult<Prisma.$AutomationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AutomationInstance model
   */
  interface AutomationInstanceFieldRefs {
    readonly id: FieldRef<"AutomationInstance", 'String'>
    readonly createdAt: FieldRef<"AutomationInstance", 'DateTime'>
    readonly updatedAt: FieldRef<"AutomationInstance", 'DateTime'>
    readonly automationId: FieldRef<"AutomationInstance", 'String'>
    readonly active: FieldRef<"AutomationInstance", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * AutomationInstance findUnique
   */
  export type AutomationInstanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationInstance
     */
    select?: AutomationInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationInstance
     */
    omit?: AutomationInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInstanceInclude<ExtArgs> | null
    /**
     * Filter, which AutomationInstance to fetch.
     */
    where: AutomationInstanceWhereUniqueInput
  }

  /**
   * AutomationInstance findUniqueOrThrow
   */
  export type AutomationInstanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationInstance
     */
    select?: AutomationInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationInstance
     */
    omit?: AutomationInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInstanceInclude<ExtArgs> | null
    /**
     * Filter, which AutomationInstance to fetch.
     */
    where: AutomationInstanceWhereUniqueInput
  }

  /**
   * AutomationInstance findFirst
   */
  export type AutomationInstanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationInstance
     */
    select?: AutomationInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationInstance
     */
    omit?: AutomationInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInstanceInclude<ExtArgs> | null
    /**
     * Filter, which AutomationInstance to fetch.
     */
    where?: AutomationInstanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutomationInstances to fetch.
     */
    orderBy?: AutomationInstanceOrderByWithRelationInput | AutomationInstanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AutomationInstances.
     */
    cursor?: AutomationInstanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutomationInstances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutomationInstances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AutomationInstances.
     */
    distinct?: AutomationInstanceScalarFieldEnum | AutomationInstanceScalarFieldEnum[]
  }

  /**
   * AutomationInstance findFirstOrThrow
   */
  export type AutomationInstanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationInstance
     */
    select?: AutomationInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationInstance
     */
    omit?: AutomationInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInstanceInclude<ExtArgs> | null
    /**
     * Filter, which AutomationInstance to fetch.
     */
    where?: AutomationInstanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutomationInstances to fetch.
     */
    orderBy?: AutomationInstanceOrderByWithRelationInput | AutomationInstanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AutomationInstances.
     */
    cursor?: AutomationInstanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutomationInstances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutomationInstances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AutomationInstances.
     */
    distinct?: AutomationInstanceScalarFieldEnum | AutomationInstanceScalarFieldEnum[]
  }

  /**
   * AutomationInstance findMany
   */
  export type AutomationInstanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationInstance
     */
    select?: AutomationInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationInstance
     */
    omit?: AutomationInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInstanceInclude<ExtArgs> | null
    /**
     * Filter, which AutomationInstances to fetch.
     */
    where?: AutomationInstanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutomationInstances to fetch.
     */
    orderBy?: AutomationInstanceOrderByWithRelationInput | AutomationInstanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AutomationInstances.
     */
    cursor?: AutomationInstanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutomationInstances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutomationInstances.
     */
    skip?: number
    distinct?: AutomationInstanceScalarFieldEnum | AutomationInstanceScalarFieldEnum[]
  }

  /**
   * AutomationInstance create
   */
  export type AutomationInstanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationInstance
     */
    select?: AutomationInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationInstance
     */
    omit?: AutomationInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInstanceInclude<ExtArgs> | null
    /**
     * The data needed to create a AutomationInstance.
     */
    data: XOR<AutomationInstanceCreateInput, AutomationInstanceUncheckedCreateInput>
  }

  /**
   * AutomationInstance createMany
   */
  export type AutomationInstanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AutomationInstances.
     */
    data: AutomationInstanceCreateManyInput | AutomationInstanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AutomationInstance createManyAndReturn
   */
  export type AutomationInstanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationInstance
     */
    select?: AutomationInstanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationInstance
     */
    omit?: AutomationInstanceOmit<ExtArgs> | null
    /**
     * The data used to create many AutomationInstances.
     */
    data: AutomationInstanceCreateManyInput | AutomationInstanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInstanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AutomationInstance update
   */
  export type AutomationInstanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationInstance
     */
    select?: AutomationInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationInstance
     */
    omit?: AutomationInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInstanceInclude<ExtArgs> | null
    /**
     * The data needed to update a AutomationInstance.
     */
    data: XOR<AutomationInstanceUpdateInput, AutomationInstanceUncheckedUpdateInput>
    /**
     * Choose, which AutomationInstance to update.
     */
    where: AutomationInstanceWhereUniqueInput
  }

  /**
   * AutomationInstance updateMany
   */
  export type AutomationInstanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AutomationInstances.
     */
    data: XOR<AutomationInstanceUpdateManyMutationInput, AutomationInstanceUncheckedUpdateManyInput>
    /**
     * Filter which AutomationInstances to update
     */
    where?: AutomationInstanceWhereInput
    /**
     * Limit how many AutomationInstances to update.
     */
    limit?: number
  }

  /**
   * AutomationInstance updateManyAndReturn
   */
  export type AutomationInstanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationInstance
     */
    select?: AutomationInstanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationInstance
     */
    omit?: AutomationInstanceOmit<ExtArgs> | null
    /**
     * The data used to update AutomationInstances.
     */
    data: XOR<AutomationInstanceUpdateManyMutationInput, AutomationInstanceUncheckedUpdateManyInput>
    /**
     * Filter which AutomationInstances to update
     */
    where?: AutomationInstanceWhereInput
    /**
     * Limit how many AutomationInstances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInstanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AutomationInstance upsert
   */
  export type AutomationInstanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationInstance
     */
    select?: AutomationInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationInstance
     */
    omit?: AutomationInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInstanceInclude<ExtArgs> | null
    /**
     * The filter to search for the AutomationInstance to update in case it exists.
     */
    where: AutomationInstanceWhereUniqueInput
    /**
     * In case the AutomationInstance found by the `where` argument doesn't exist, create a new AutomationInstance with this data.
     */
    create: XOR<AutomationInstanceCreateInput, AutomationInstanceUncheckedCreateInput>
    /**
     * In case the AutomationInstance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AutomationInstanceUpdateInput, AutomationInstanceUncheckedUpdateInput>
  }

  /**
   * AutomationInstance delete
   */
  export type AutomationInstanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationInstance
     */
    select?: AutomationInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationInstance
     */
    omit?: AutomationInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInstanceInclude<ExtArgs> | null
    /**
     * Filter which AutomationInstance to delete.
     */
    where: AutomationInstanceWhereUniqueInput
  }

  /**
   * AutomationInstance deleteMany
   */
  export type AutomationInstanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AutomationInstances to delete
     */
    where?: AutomationInstanceWhereInput
    /**
     * Limit how many AutomationInstances to delete.
     */
    limit?: number
  }

  /**
   * AutomationInstance without action
   */
  export type AutomationInstanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutomationInstance
     */
    select?: AutomationInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutomationInstance
     */
    omit?: AutomationInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutomationInstanceInclude<ExtArgs> | null
  }


  /**
   * Model Actions
   */

  export type AggregateActions = {
    _count: ActionsCountAggregateOutputType | null
    _avg: ActionsAvgAggregateOutputType | null
    _sum: ActionsSumAggregateOutputType | null
    _min: ActionsMinAggregateOutputType | null
    _max: ActionsMaxAggregateOutputType | null
  }

  export type ActionsAvgAggregateOutputType = {
    order: number | null
  }

  export type ActionsSumAggregateOutputType = {
    order: number | null
  }

  export type ActionsMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.ActionType | null
    createdAt: Date | null
    updatedAt: Date | null
    automatedId: string | null
    order: number | null
    laneId: string | null
  }

  export type ActionsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.ActionType | null
    createdAt: Date | null
    updatedAt: Date | null
    automatedId: string | null
    order: number | null
    laneId: string | null
  }

  export type ActionsCountAggregateOutputType = {
    id: number
    name: number
    type: number
    createdAt: number
    updatedAt: number
    automatedId: number
    order: number
    laneId: number
    _all: number
  }


  export type ActionsAvgAggregateInputType = {
    order?: true
  }

  export type ActionsSumAggregateInputType = {
    order?: true
  }

  export type ActionsMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    automatedId?: true
    order?: true
    laneId?: true
  }

  export type ActionsMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    automatedId?: true
    order?: true
    laneId?: true
  }

  export type ActionsCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    automatedId?: true
    order?: true
    laneId?: true
    _all?: true
  }

  export type ActionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Actions to aggregate.
     */
    where?: ActionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Actions to fetch.
     */
    orderBy?: ActionsOrderByWithRelationInput | ActionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Actions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Actions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Actions
    **/
    _count?: true | ActionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActionsMaxAggregateInputType
  }

  export type GetActionsAggregateType<T extends ActionsAggregateArgs> = {
        [P in keyof T & keyof AggregateActions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActions[P]>
      : GetScalarType<T[P], AggregateActions[P]>
  }




  export type ActionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActionsWhereInput
    orderBy?: ActionsOrderByWithAggregationInput | ActionsOrderByWithAggregationInput[]
    by: ActionsScalarFieldEnum[] | ActionsScalarFieldEnum
    having?: ActionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActionsCountAggregateInputType | true
    _avg?: ActionsAvgAggregateInputType
    _sum?: ActionsSumAggregateInputType
    _min?: ActionsMinAggregateInputType
    _max?: ActionsMaxAggregateInputType
  }

  export type ActionsGroupByOutputType = {
    id: string
    name: string
    type: $Enums.ActionType
    createdAt: Date
    updatedAt: Date
    automatedId: string
    order: number
    laneId: string
    _count: ActionsCountAggregateOutputType | null
    _avg: ActionsAvgAggregateOutputType | null
    _sum: ActionsSumAggregateOutputType | null
    _min: ActionsMinAggregateOutputType | null
    _max: ActionsMaxAggregateOutputType | null
  }

  type GetActionsGroupByPayload<T extends ActionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActionsGroupByOutputType[P]>
            : GetScalarType<T[P], ActionsGroupByOutputType[P]>
        }
      >
    >


  export type ActionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    automatedId?: boolean
    order?: boolean
    laneId?: boolean
    Automations?: boolean | AutomationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["actions"]>

  export type ActionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    automatedId?: boolean
    order?: boolean
    laneId?: boolean
    Automations?: boolean | AutomationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["actions"]>

  export type ActionsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    automatedId?: boolean
    order?: boolean
    laneId?: boolean
    Automations?: boolean | AutomationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["actions"]>

  export type ActionsSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    automatedId?: boolean
    order?: boolean
    laneId?: boolean
  }

  export type ActionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "createdAt" | "updatedAt" | "automatedId" | "order" | "laneId", ExtArgs["result"]["actions"]>
  export type ActionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Automations?: boolean | AutomationsDefaultArgs<ExtArgs>
  }
  export type ActionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Automations?: boolean | AutomationsDefaultArgs<ExtArgs>
  }
  export type ActionsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Automations?: boolean | AutomationsDefaultArgs<ExtArgs>
  }

  export type $ActionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Actions"
    objects: {
      Automations: Prisma.$AutomationsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: $Enums.ActionType
      createdAt: Date
      updatedAt: Date
      automatedId: string
      order: number
      laneId: string
    }, ExtArgs["result"]["actions"]>
    composites: {}
  }

  type ActionsGetPayload<S extends boolean | null | undefined | ActionsDefaultArgs> = $Result.GetResult<Prisma.$ActionsPayload, S>

  type ActionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActionsCountAggregateInputType | true
    }

  export interface ActionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Actions'], meta: { name: 'Actions' } }
    /**
     * Find zero or one Actions that matches the filter.
     * @param {ActionsFindUniqueArgs} args - Arguments to find a Actions
     * @example
     * // Get one Actions
     * const actions = await prisma.actions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActionsFindUniqueArgs>(args: SelectSubset<T, ActionsFindUniqueArgs<ExtArgs>>): Prisma__ActionsClient<$Result.GetResult<Prisma.$ActionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Actions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActionsFindUniqueOrThrowArgs} args - Arguments to find a Actions
     * @example
     * // Get one Actions
     * const actions = await prisma.actions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActionsFindUniqueOrThrowArgs>(args: SelectSubset<T, ActionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActionsClient<$Result.GetResult<Prisma.$ActionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Actions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionsFindFirstArgs} args - Arguments to find a Actions
     * @example
     * // Get one Actions
     * const actions = await prisma.actions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActionsFindFirstArgs>(args?: SelectSubset<T, ActionsFindFirstArgs<ExtArgs>>): Prisma__ActionsClient<$Result.GetResult<Prisma.$ActionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Actions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionsFindFirstOrThrowArgs} args - Arguments to find a Actions
     * @example
     * // Get one Actions
     * const actions = await prisma.actions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActionsFindFirstOrThrowArgs>(args?: SelectSubset<T, ActionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActionsClient<$Result.GetResult<Prisma.$ActionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Actions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Actions
     * const actions = await prisma.actions.findMany()
     * 
     * // Get first 10 Actions
     * const actions = await prisma.actions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const actionsWithIdOnly = await prisma.actions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActionsFindManyArgs>(args?: SelectSubset<T, ActionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Actions.
     * @param {ActionsCreateArgs} args - Arguments to create a Actions.
     * @example
     * // Create one Actions
     * const Actions = await prisma.actions.create({
     *   data: {
     *     // ... data to create a Actions
     *   }
     * })
     * 
     */
    create<T extends ActionsCreateArgs>(args: SelectSubset<T, ActionsCreateArgs<ExtArgs>>): Prisma__ActionsClient<$Result.GetResult<Prisma.$ActionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Actions.
     * @param {ActionsCreateManyArgs} args - Arguments to create many Actions.
     * @example
     * // Create many Actions
     * const actions = await prisma.actions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActionsCreateManyArgs>(args?: SelectSubset<T, ActionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Actions and returns the data saved in the database.
     * @param {ActionsCreateManyAndReturnArgs} args - Arguments to create many Actions.
     * @example
     * // Create many Actions
     * const actions = await prisma.actions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Actions and only return the `id`
     * const actionsWithIdOnly = await prisma.actions.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActionsCreateManyAndReturnArgs>(args?: SelectSubset<T, ActionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Actions.
     * @param {ActionsDeleteArgs} args - Arguments to delete one Actions.
     * @example
     * // Delete one Actions
     * const Actions = await prisma.actions.delete({
     *   where: {
     *     // ... filter to delete one Actions
     *   }
     * })
     * 
     */
    delete<T extends ActionsDeleteArgs>(args: SelectSubset<T, ActionsDeleteArgs<ExtArgs>>): Prisma__ActionsClient<$Result.GetResult<Prisma.$ActionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Actions.
     * @param {ActionsUpdateArgs} args - Arguments to update one Actions.
     * @example
     * // Update one Actions
     * const actions = await prisma.actions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActionsUpdateArgs>(args: SelectSubset<T, ActionsUpdateArgs<ExtArgs>>): Prisma__ActionsClient<$Result.GetResult<Prisma.$ActionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Actions.
     * @param {ActionsDeleteManyArgs} args - Arguments to filter Actions to delete.
     * @example
     * // Delete a few Actions
     * const { count } = await prisma.actions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActionsDeleteManyArgs>(args?: SelectSubset<T, ActionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Actions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Actions
     * const actions = await prisma.actions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActionsUpdateManyArgs>(args: SelectSubset<T, ActionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Actions and returns the data updated in the database.
     * @param {ActionsUpdateManyAndReturnArgs} args - Arguments to update many Actions.
     * @example
     * // Update many Actions
     * const actions = await prisma.actions.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Actions and only return the `id`
     * const actionsWithIdOnly = await prisma.actions.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ActionsUpdateManyAndReturnArgs>(args: SelectSubset<T, ActionsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Actions.
     * @param {ActionsUpsertArgs} args - Arguments to update or create a Actions.
     * @example
     * // Update or create a Actions
     * const actions = await prisma.actions.upsert({
     *   create: {
     *     // ... data to create a Actions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Actions we want to update
     *   }
     * })
     */
    upsert<T extends ActionsUpsertArgs>(args: SelectSubset<T, ActionsUpsertArgs<ExtArgs>>): Prisma__ActionsClient<$Result.GetResult<Prisma.$ActionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Actions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionsCountArgs} args - Arguments to filter Actions to count.
     * @example
     * // Count the number of Actions
     * const count = await prisma.actions.count({
     *   where: {
     *     // ... the filter for the Actions we want to count
     *   }
     * })
    **/
    count<T extends ActionsCountArgs>(
      args?: Subset<T, ActionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Actions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActionsAggregateArgs>(args: Subset<T, ActionsAggregateArgs>): Prisma.PrismaPromise<GetActionsAggregateType<T>>

    /**
     * Group by Actions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActionsGroupByArgs['orderBy'] }
        : { orderBy?: ActionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Actions model
   */
  readonly fields: ActionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Actions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Automations<T extends AutomationsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AutomationsDefaultArgs<ExtArgs>>): Prisma__AutomationsClient<$Result.GetResult<Prisma.$AutomationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Actions model
   */
  interface ActionsFieldRefs {
    readonly id: FieldRef<"Actions", 'String'>
    readonly name: FieldRef<"Actions", 'String'>
    readonly type: FieldRef<"Actions", 'ActionType'>
    readonly createdAt: FieldRef<"Actions", 'DateTime'>
    readonly updatedAt: FieldRef<"Actions", 'DateTime'>
    readonly automatedId: FieldRef<"Actions", 'String'>
    readonly order: FieldRef<"Actions", 'Int'>
    readonly laneId: FieldRef<"Actions", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Actions findUnique
   */
  export type ActionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Actions
     */
    select?: ActionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Actions
     */
    omit?: ActionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionsInclude<ExtArgs> | null
    /**
     * Filter, which Actions to fetch.
     */
    where: ActionsWhereUniqueInput
  }

  /**
   * Actions findUniqueOrThrow
   */
  export type ActionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Actions
     */
    select?: ActionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Actions
     */
    omit?: ActionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionsInclude<ExtArgs> | null
    /**
     * Filter, which Actions to fetch.
     */
    where: ActionsWhereUniqueInput
  }

  /**
   * Actions findFirst
   */
  export type ActionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Actions
     */
    select?: ActionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Actions
     */
    omit?: ActionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionsInclude<ExtArgs> | null
    /**
     * Filter, which Actions to fetch.
     */
    where?: ActionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Actions to fetch.
     */
    orderBy?: ActionsOrderByWithRelationInput | ActionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Actions.
     */
    cursor?: ActionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Actions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Actions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Actions.
     */
    distinct?: ActionsScalarFieldEnum | ActionsScalarFieldEnum[]
  }

  /**
   * Actions findFirstOrThrow
   */
  export type ActionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Actions
     */
    select?: ActionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Actions
     */
    omit?: ActionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionsInclude<ExtArgs> | null
    /**
     * Filter, which Actions to fetch.
     */
    where?: ActionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Actions to fetch.
     */
    orderBy?: ActionsOrderByWithRelationInput | ActionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Actions.
     */
    cursor?: ActionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Actions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Actions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Actions.
     */
    distinct?: ActionsScalarFieldEnum | ActionsScalarFieldEnum[]
  }

  /**
   * Actions findMany
   */
  export type ActionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Actions
     */
    select?: ActionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Actions
     */
    omit?: ActionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionsInclude<ExtArgs> | null
    /**
     * Filter, which Actions to fetch.
     */
    where?: ActionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Actions to fetch.
     */
    orderBy?: ActionsOrderByWithRelationInput | ActionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Actions.
     */
    cursor?: ActionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Actions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Actions.
     */
    skip?: number
    distinct?: ActionsScalarFieldEnum | ActionsScalarFieldEnum[]
  }

  /**
   * Actions create
   */
  export type ActionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Actions
     */
    select?: ActionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Actions
     */
    omit?: ActionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionsInclude<ExtArgs> | null
    /**
     * The data needed to create a Actions.
     */
    data: XOR<ActionsCreateInput, ActionsUncheckedCreateInput>
  }

  /**
   * Actions createMany
   */
  export type ActionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Actions.
     */
    data: ActionsCreateManyInput | ActionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Actions createManyAndReturn
   */
  export type ActionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Actions
     */
    select?: ActionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Actions
     */
    omit?: ActionsOmit<ExtArgs> | null
    /**
     * The data used to create many Actions.
     */
    data: ActionsCreateManyInput | ActionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Actions update
   */
  export type ActionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Actions
     */
    select?: ActionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Actions
     */
    omit?: ActionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionsInclude<ExtArgs> | null
    /**
     * The data needed to update a Actions.
     */
    data: XOR<ActionsUpdateInput, ActionsUncheckedUpdateInput>
    /**
     * Choose, which Actions to update.
     */
    where: ActionsWhereUniqueInput
  }

  /**
   * Actions updateMany
   */
  export type ActionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Actions.
     */
    data: XOR<ActionsUpdateManyMutationInput, ActionsUncheckedUpdateManyInput>
    /**
     * Filter which Actions to update
     */
    where?: ActionsWhereInput
    /**
     * Limit how many Actions to update.
     */
    limit?: number
  }

  /**
   * Actions updateManyAndReturn
   */
  export type ActionsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Actions
     */
    select?: ActionsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Actions
     */
    omit?: ActionsOmit<ExtArgs> | null
    /**
     * The data used to update Actions.
     */
    data: XOR<ActionsUpdateManyMutationInput, ActionsUncheckedUpdateManyInput>
    /**
     * Filter which Actions to update
     */
    where?: ActionsWhereInput
    /**
     * Limit how many Actions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Actions upsert
   */
  export type ActionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Actions
     */
    select?: ActionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Actions
     */
    omit?: ActionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionsInclude<ExtArgs> | null
    /**
     * The filter to search for the Actions to update in case it exists.
     */
    where: ActionsWhereUniqueInput
    /**
     * In case the Actions found by the `where` argument doesn't exist, create a new Actions with this data.
     */
    create: XOR<ActionsCreateInput, ActionsUncheckedCreateInput>
    /**
     * In case the Actions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActionsUpdateInput, ActionsUncheckedUpdateInput>
  }

  /**
   * Actions delete
   */
  export type ActionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Actions
     */
    select?: ActionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Actions
     */
    omit?: ActionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionsInclude<ExtArgs> | null
    /**
     * Filter which Actions to delete.
     */
    where: ActionsWhereUniqueInput
  }

  /**
   * Actions deleteMany
   */
  export type ActionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Actions to delete
     */
    where?: ActionsWhereInput
    /**
     * Limit how many Actions to delete.
     */
    limit?: number
  }

  /**
   * Actions without action
   */
  export type ActionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Actions
     */
    select?: ActionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Actions
     */
    omit?: ActionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionsInclude<ExtArgs> | null
  }


  /**
   * Model Contacts
   */

  export type AggregateContacts = {
    _count: ContactsCountAggregateOutputType | null
    _min: ContactsMinAggregateOutputType | null
    _max: ContactsMaxAggregateOutputType | null
  }

  export type ContactsMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    createdAt: Date | null
    updatedAt: Date | null
    subAccountId: string | null
  }

  export type ContactsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    createdAt: Date | null
    updatedAt: Date | null
    subAccountId: string | null
  }

  export type ContactsCountAggregateOutputType = {
    id: number
    name: number
    email: number
    createdAt: number
    updatedAt: number
    subAccountId: number
    _all: number
  }


  export type ContactsMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    createdAt?: true
    updatedAt?: true
    subAccountId?: true
  }

  export type ContactsMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    createdAt?: true
    updatedAt?: true
    subAccountId?: true
  }

  export type ContactsCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    createdAt?: true
    updatedAt?: true
    subAccountId?: true
    _all?: true
  }

  export type ContactsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contacts to aggregate.
     */
    where?: ContactsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactsOrderByWithRelationInput | ContactsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contacts
    **/
    _count?: true | ContactsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactsMaxAggregateInputType
  }

  export type GetContactsAggregateType<T extends ContactsAggregateArgs> = {
        [P in keyof T & keyof AggregateContacts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContacts[P]>
      : GetScalarType<T[P], AggregateContacts[P]>
  }




  export type ContactsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactsWhereInput
    orderBy?: ContactsOrderByWithAggregationInput | ContactsOrderByWithAggregationInput[]
    by: ContactsScalarFieldEnum[] | ContactsScalarFieldEnum
    having?: ContactsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactsCountAggregateInputType | true
    _min?: ContactsMinAggregateInputType
    _max?: ContactsMaxAggregateInputType
  }

  export type ContactsGroupByOutputType = {
    id: string
    name: string
    email: string
    createdAt: Date
    updatedAt: Date
    subAccountId: string
    _count: ContactsCountAggregateOutputType | null
    _min: ContactsMinAggregateOutputType | null
    _max: ContactsMaxAggregateOutputType | null
  }

  type GetContactsGroupByPayload<T extends ContactsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactsGroupByOutputType[P]>
            : GetScalarType<T[P], ContactsGroupByOutputType[P]>
        }
      >
    >


  export type ContactsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subAccountId?: boolean
    SubAccounts?: boolean | SubAccountsDefaultArgs<ExtArgs>
    Tickets?: boolean | Contacts$TicketsArgs<ExtArgs>
    _count?: boolean | ContactsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contacts"]>

  export type ContactsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subAccountId?: boolean
    SubAccounts?: boolean | SubAccountsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contacts"]>

  export type ContactsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subAccountId?: boolean
    SubAccounts?: boolean | SubAccountsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contacts"]>

  export type ContactsSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subAccountId?: boolean
  }

  export type ContactsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "createdAt" | "updatedAt" | "subAccountId", ExtArgs["result"]["contacts"]>
  export type ContactsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SubAccounts?: boolean | SubAccountsDefaultArgs<ExtArgs>
    Tickets?: boolean | Contacts$TicketsArgs<ExtArgs>
    _count?: boolean | ContactsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ContactsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SubAccounts?: boolean | SubAccountsDefaultArgs<ExtArgs>
  }
  export type ContactsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SubAccounts?: boolean | SubAccountsDefaultArgs<ExtArgs>
  }

  export type $ContactsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contacts"
    objects: {
      SubAccounts: Prisma.$SubAccountsPayload<ExtArgs>
      Tickets: Prisma.$TicketsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      createdAt: Date
      updatedAt: Date
      subAccountId: string
    }, ExtArgs["result"]["contacts"]>
    composites: {}
  }

  type ContactsGetPayload<S extends boolean | null | undefined | ContactsDefaultArgs> = $Result.GetResult<Prisma.$ContactsPayload, S>

  type ContactsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactsCountAggregateInputType | true
    }

  export interface ContactsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contacts'], meta: { name: 'Contacts' } }
    /**
     * Find zero or one Contacts that matches the filter.
     * @param {ContactsFindUniqueArgs} args - Arguments to find a Contacts
     * @example
     * // Get one Contacts
     * const contacts = await prisma.contacts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactsFindUniqueArgs>(args: SelectSubset<T, ContactsFindUniqueArgs<ExtArgs>>): Prisma__ContactsClient<$Result.GetResult<Prisma.$ContactsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Contacts that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactsFindUniqueOrThrowArgs} args - Arguments to find a Contacts
     * @example
     * // Get one Contacts
     * const contacts = await prisma.contacts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactsFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactsClient<$Result.GetResult<Prisma.$ContactsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactsFindFirstArgs} args - Arguments to find a Contacts
     * @example
     * // Get one Contacts
     * const contacts = await prisma.contacts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactsFindFirstArgs>(args?: SelectSubset<T, ContactsFindFirstArgs<ExtArgs>>): Prisma__ContactsClient<$Result.GetResult<Prisma.$ContactsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contacts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactsFindFirstOrThrowArgs} args - Arguments to find a Contacts
     * @example
     * // Get one Contacts
     * const contacts = await prisma.contacts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactsFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactsClient<$Result.GetResult<Prisma.$ContactsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contacts
     * const contacts = await prisma.contacts.findMany()
     * 
     * // Get first 10 Contacts
     * const contacts = await prisma.contacts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactsWithIdOnly = await prisma.contacts.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactsFindManyArgs>(args?: SelectSubset<T, ContactsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Contacts.
     * @param {ContactsCreateArgs} args - Arguments to create a Contacts.
     * @example
     * // Create one Contacts
     * const Contacts = await prisma.contacts.create({
     *   data: {
     *     // ... data to create a Contacts
     *   }
     * })
     * 
     */
    create<T extends ContactsCreateArgs>(args: SelectSubset<T, ContactsCreateArgs<ExtArgs>>): Prisma__ContactsClient<$Result.GetResult<Prisma.$ContactsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Contacts.
     * @param {ContactsCreateManyArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contacts = await prisma.contacts.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactsCreateManyArgs>(args?: SelectSubset<T, ContactsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contacts and returns the data saved in the database.
     * @param {ContactsCreateManyAndReturnArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contacts = await prisma.contacts.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contacts and only return the `id`
     * const contactsWithIdOnly = await prisma.contacts.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContactsCreateManyAndReturnArgs>(args?: SelectSubset<T, ContactsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Contacts.
     * @param {ContactsDeleteArgs} args - Arguments to delete one Contacts.
     * @example
     * // Delete one Contacts
     * const Contacts = await prisma.contacts.delete({
     *   where: {
     *     // ... filter to delete one Contacts
     *   }
     * })
     * 
     */
    delete<T extends ContactsDeleteArgs>(args: SelectSubset<T, ContactsDeleteArgs<ExtArgs>>): Prisma__ContactsClient<$Result.GetResult<Prisma.$ContactsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Contacts.
     * @param {ContactsUpdateArgs} args - Arguments to update one Contacts.
     * @example
     * // Update one Contacts
     * const contacts = await prisma.contacts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactsUpdateArgs>(args: SelectSubset<T, ContactsUpdateArgs<ExtArgs>>): Prisma__ContactsClient<$Result.GetResult<Prisma.$ContactsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Contacts.
     * @param {ContactsDeleteManyArgs} args - Arguments to filter Contacts to delete.
     * @example
     * // Delete a few Contacts
     * const { count } = await prisma.contacts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactsDeleteManyArgs>(args?: SelectSubset<T, ContactsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contacts
     * const contacts = await prisma.contacts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactsUpdateManyArgs>(args: SelectSubset<T, ContactsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts and returns the data updated in the database.
     * @param {ContactsUpdateManyAndReturnArgs} args - Arguments to update many Contacts.
     * @example
     * // Update many Contacts
     * const contacts = await prisma.contacts.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Contacts and only return the `id`
     * const contactsWithIdOnly = await prisma.contacts.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContactsUpdateManyAndReturnArgs>(args: SelectSubset<T, ContactsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Contacts.
     * @param {ContactsUpsertArgs} args - Arguments to update or create a Contacts.
     * @example
     * // Update or create a Contacts
     * const contacts = await prisma.contacts.upsert({
     *   create: {
     *     // ... data to create a Contacts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contacts we want to update
     *   }
     * })
     */
    upsert<T extends ContactsUpsertArgs>(args: SelectSubset<T, ContactsUpsertArgs<ExtArgs>>): Prisma__ContactsClient<$Result.GetResult<Prisma.$ContactsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactsCountArgs} args - Arguments to filter Contacts to count.
     * @example
     * // Count the number of Contacts
     * const count = await prisma.contacts.count({
     *   where: {
     *     // ... the filter for the Contacts we want to count
     *   }
     * })
    **/
    count<T extends ContactsCountArgs>(
      args?: Subset<T, ContactsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactsAggregateArgs>(args: Subset<T, ContactsAggregateArgs>): Prisma.PrismaPromise<GetContactsAggregateType<T>>

    /**
     * Group by Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactsGroupByArgs['orderBy'] }
        : { orderBy?: ContactsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contacts model
   */
  readonly fields: ContactsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contacts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    SubAccounts<T extends SubAccountsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubAccountsDefaultArgs<ExtArgs>>): Prisma__SubAccountsClient<$Result.GetResult<Prisma.$SubAccountsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Tickets<T extends Contacts$TicketsArgs<ExtArgs> = {}>(args?: Subset<T, Contacts$TicketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contacts model
   */
  interface ContactsFieldRefs {
    readonly id: FieldRef<"Contacts", 'String'>
    readonly name: FieldRef<"Contacts", 'String'>
    readonly email: FieldRef<"Contacts", 'String'>
    readonly createdAt: FieldRef<"Contacts", 'DateTime'>
    readonly updatedAt: FieldRef<"Contacts", 'DateTime'>
    readonly subAccountId: FieldRef<"Contacts", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Contacts findUnique
   */
  export type ContactsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contacts
     */
    select?: ContactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contacts
     */
    omit?: ContactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactsInclude<ExtArgs> | null
    /**
     * Filter, which Contacts to fetch.
     */
    where: ContactsWhereUniqueInput
  }

  /**
   * Contacts findUniqueOrThrow
   */
  export type ContactsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contacts
     */
    select?: ContactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contacts
     */
    omit?: ContactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactsInclude<ExtArgs> | null
    /**
     * Filter, which Contacts to fetch.
     */
    where: ContactsWhereUniqueInput
  }

  /**
   * Contacts findFirst
   */
  export type ContactsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contacts
     */
    select?: ContactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contacts
     */
    omit?: ContactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactsInclude<ExtArgs> | null
    /**
     * Filter, which Contacts to fetch.
     */
    where?: ContactsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactsOrderByWithRelationInput | ContactsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactsScalarFieldEnum | ContactsScalarFieldEnum[]
  }

  /**
   * Contacts findFirstOrThrow
   */
  export type ContactsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contacts
     */
    select?: ContactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contacts
     */
    omit?: ContactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactsInclude<ExtArgs> | null
    /**
     * Filter, which Contacts to fetch.
     */
    where?: ContactsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactsOrderByWithRelationInput | ContactsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactsScalarFieldEnum | ContactsScalarFieldEnum[]
  }

  /**
   * Contacts findMany
   */
  export type ContactsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contacts
     */
    select?: ContactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contacts
     */
    omit?: ContactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactsInclude<ExtArgs> | null
    /**
     * Filter, which Contacts to fetch.
     */
    where?: ContactsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactsOrderByWithRelationInput | ContactsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contacts.
     */
    cursor?: ContactsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    distinct?: ContactsScalarFieldEnum | ContactsScalarFieldEnum[]
  }

  /**
   * Contacts create
   */
  export type ContactsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contacts
     */
    select?: ContactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contacts
     */
    omit?: ContactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactsInclude<ExtArgs> | null
    /**
     * The data needed to create a Contacts.
     */
    data: XOR<ContactsCreateInput, ContactsUncheckedCreateInput>
  }

  /**
   * Contacts createMany
   */
  export type ContactsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contacts.
     */
    data: ContactsCreateManyInput | ContactsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contacts createManyAndReturn
   */
  export type ContactsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contacts
     */
    select?: ContactsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contacts
     */
    omit?: ContactsOmit<ExtArgs> | null
    /**
     * The data used to create many Contacts.
     */
    data: ContactsCreateManyInput | ContactsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Contacts update
   */
  export type ContactsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contacts
     */
    select?: ContactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contacts
     */
    omit?: ContactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactsInclude<ExtArgs> | null
    /**
     * The data needed to update a Contacts.
     */
    data: XOR<ContactsUpdateInput, ContactsUncheckedUpdateInput>
    /**
     * Choose, which Contacts to update.
     */
    where: ContactsWhereUniqueInput
  }

  /**
   * Contacts updateMany
   */
  export type ContactsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactsUpdateManyMutationInput, ContactsUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactsWhereInput
    /**
     * Limit how many Contacts to update.
     */
    limit?: number
  }

  /**
   * Contacts updateManyAndReturn
   */
  export type ContactsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contacts
     */
    select?: ContactsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contacts
     */
    omit?: ContactsOmit<ExtArgs> | null
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactsUpdateManyMutationInput, ContactsUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactsWhereInput
    /**
     * Limit how many Contacts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Contacts upsert
   */
  export type ContactsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contacts
     */
    select?: ContactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contacts
     */
    omit?: ContactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactsInclude<ExtArgs> | null
    /**
     * The filter to search for the Contacts to update in case it exists.
     */
    where: ContactsWhereUniqueInput
    /**
     * In case the Contacts found by the `where` argument doesn't exist, create a new Contacts with this data.
     */
    create: XOR<ContactsCreateInput, ContactsUncheckedCreateInput>
    /**
     * In case the Contacts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactsUpdateInput, ContactsUncheckedUpdateInput>
  }

  /**
   * Contacts delete
   */
  export type ContactsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contacts
     */
    select?: ContactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contacts
     */
    omit?: ContactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactsInclude<ExtArgs> | null
    /**
     * Filter which Contacts to delete.
     */
    where: ContactsWhereUniqueInput
  }

  /**
   * Contacts deleteMany
   */
  export type ContactsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contacts to delete
     */
    where?: ContactsWhereInput
    /**
     * Limit how many Contacts to delete.
     */
    limit?: number
  }

  /**
   * Contacts.Tickets
   */
  export type Contacts$TicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tickets
     */
    select?: TicketsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tickets
     */
    omit?: TicketsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketsInclude<ExtArgs> | null
    where?: TicketsWhereInput
    orderBy?: TicketsOrderByWithRelationInput | TicketsOrderByWithRelationInput[]
    cursor?: TicketsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketsScalarFieldEnum | TicketsScalarFieldEnum[]
  }

  /**
   * Contacts without action
   */
  export type ContactsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contacts
     */
    select?: ContactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contacts
     */
    omit?: ContactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactsInclude<ExtArgs> | null
  }


  /**
   * Model Media
   */

  export type AggregateMedia = {
    _count: MediaCountAggregateOutputType | null
    _min: MediaMinAggregateOutputType | null
    _max: MediaMaxAggregateOutputType | null
  }

  export type MediaMinAggregateOutputType = {
    id: string | null
    type: string | null
    name: string | null
    link: string | null
    subAccountId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MediaMaxAggregateOutputType = {
    id: string | null
    type: string | null
    name: string | null
    link: string | null
    subAccountId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MediaCountAggregateOutputType = {
    id: number
    type: number
    name: number
    link: number
    subAccountId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MediaMinAggregateInputType = {
    id?: true
    type?: true
    name?: true
    link?: true
    subAccountId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MediaMaxAggregateInputType = {
    id?: true
    type?: true
    name?: true
    link?: true
    subAccountId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MediaCountAggregateInputType = {
    id?: true
    type?: true
    name?: true
    link?: true
    subAccountId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MediaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Media to aggregate.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Media
    **/
    _count?: true | MediaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MediaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MediaMaxAggregateInputType
  }

  export type GetMediaAggregateType<T extends MediaAggregateArgs> = {
        [P in keyof T & keyof AggregateMedia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedia[P]>
      : GetScalarType<T[P], AggregateMedia[P]>
  }




  export type MediaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaWhereInput
    orderBy?: MediaOrderByWithAggregationInput | MediaOrderByWithAggregationInput[]
    by: MediaScalarFieldEnum[] | MediaScalarFieldEnum
    having?: MediaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MediaCountAggregateInputType | true
    _min?: MediaMinAggregateInputType
    _max?: MediaMaxAggregateInputType
  }

  export type MediaGroupByOutputType = {
    id: string
    type: string | null
    name: string
    link: string
    subAccountId: string
    createdAt: Date
    updatedAt: Date
    _count: MediaCountAggregateOutputType | null
    _min: MediaMinAggregateOutputType | null
    _max: MediaMaxAggregateOutputType | null
  }

  type GetMediaGroupByPayload<T extends MediaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MediaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MediaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MediaGroupByOutputType[P]>
            : GetScalarType<T[P], MediaGroupByOutputType[P]>
        }
      >
    >


  export type MediaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    name?: boolean
    link?: boolean
    subAccountId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    SubAccounts?: boolean | SubAccountsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["media"]>

  export type MediaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    name?: boolean
    link?: boolean
    subAccountId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    SubAccounts?: boolean | SubAccountsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["media"]>

  export type MediaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    name?: boolean
    link?: boolean
    subAccountId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    SubAccounts?: boolean | SubAccountsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["media"]>

  export type MediaSelectScalar = {
    id?: boolean
    type?: boolean
    name?: boolean
    link?: boolean
    subAccountId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MediaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "name" | "link" | "subAccountId" | "createdAt" | "updatedAt", ExtArgs["result"]["media"]>
  export type MediaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SubAccounts?: boolean | SubAccountsDefaultArgs<ExtArgs>
  }
  export type MediaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SubAccounts?: boolean | SubAccountsDefaultArgs<ExtArgs>
  }
  export type MediaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SubAccounts?: boolean | SubAccountsDefaultArgs<ExtArgs>
  }

  export type $MediaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Media"
    objects: {
      SubAccounts: Prisma.$SubAccountsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string | null
      name: string
      link: string
      subAccountId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["media"]>
    composites: {}
  }

  type MediaGetPayload<S extends boolean | null | undefined | MediaDefaultArgs> = $Result.GetResult<Prisma.$MediaPayload, S>

  type MediaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MediaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MediaCountAggregateInputType | true
    }

  export interface MediaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Media'], meta: { name: 'Media' } }
    /**
     * Find zero or one Media that matches the filter.
     * @param {MediaFindUniqueArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MediaFindUniqueArgs>(args: SelectSubset<T, MediaFindUniqueArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Media that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MediaFindUniqueOrThrowArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MediaFindUniqueOrThrowArgs>(args: SelectSubset<T, MediaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Media that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindFirstArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MediaFindFirstArgs>(args?: SelectSubset<T, MediaFindFirstArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Media that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindFirstOrThrowArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MediaFindFirstOrThrowArgs>(args?: SelectSubset<T, MediaFindFirstOrThrowArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Media that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Media
     * const media = await prisma.media.findMany()
     * 
     * // Get first 10 Media
     * const media = await prisma.media.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mediaWithIdOnly = await prisma.media.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MediaFindManyArgs>(args?: SelectSubset<T, MediaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Media.
     * @param {MediaCreateArgs} args - Arguments to create a Media.
     * @example
     * // Create one Media
     * const Media = await prisma.media.create({
     *   data: {
     *     // ... data to create a Media
     *   }
     * })
     * 
     */
    create<T extends MediaCreateArgs>(args: SelectSubset<T, MediaCreateArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Media.
     * @param {MediaCreateManyArgs} args - Arguments to create many Media.
     * @example
     * // Create many Media
     * const media = await prisma.media.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MediaCreateManyArgs>(args?: SelectSubset<T, MediaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Media and returns the data saved in the database.
     * @param {MediaCreateManyAndReturnArgs} args - Arguments to create many Media.
     * @example
     * // Create many Media
     * const media = await prisma.media.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Media and only return the `id`
     * const mediaWithIdOnly = await prisma.media.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MediaCreateManyAndReturnArgs>(args?: SelectSubset<T, MediaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Media.
     * @param {MediaDeleteArgs} args - Arguments to delete one Media.
     * @example
     * // Delete one Media
     * const Media = await prisma.media.delete({
     *   where: {
     *     // ... filter to delete one Media
     *   }
     * })
     * 
     */
    delete<T extends MediaDeleteArgs>(args: SelectSubset<T, MediaDeleteArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Media.
     * @param {MediaUpdateArgs} args - Arguments to update one Media.
     * @example
     * // Update one Media
     * const media = await prisma.media.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MediaUpdateArgs>(args: SelectSubset<T, MediaUpdateArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Media.
     * @param {MediaDeleteManyArgs} args - Arguments to filter Media to delete.
     * @example
     * // Delete a few Media
     * const { count } = await prisma.media.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MediaDeleteManyArgs>(args?: SelectSubset<T, MediaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Media
     * const media = await prisma.media.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MediaUpdateManyArgs>(args: SelectSubset<T, MediaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Media and returns the data updated in the database.
     * @param {MediaUpdateManyAndReturnArgs} args - Arguments to update many Media.
     * @example
     * // Update many Media
     * const media = await prisma.media.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Media and only return the `id`
     * const mediaWithIdOnly = await prisma.media.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MediaUpdateManyAndReturnArgs>(args: SelectSubset<T, MediaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Media.
     * @param {MediaUpsertArgs} args - Arguments to update or create a Media.
     * @example
     * // Update or create a Media
     * const media = await prisma.media.upsert({
     *   create: {
     *     // ... data to create a Media
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Media we want to update
     *   }
     * })
     */
    upsert<T extends MediaUpsertArgs>(args: SelectSubset<T, MediaUpsertArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaCountArgs} args - Arguments to filter Media to count.
     * @example
     * // Count the number of Media
     * const count = await prisma.media.count({
     *   where: {
     *     // ... the filter for the Media we want to count
     *   }
     * })
    **/
    count<T extends MediaCountArgs>(
      args?: Subset<T, MediaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MediaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MediaAggregateArgs>(args: Subset<T, MediaAggregateArgs>): Prisma.PrismaPromise<GetMediaAggregateType<T>>

    /**
     * Group by Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MediaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MediaGroupByArgs['orderBy'] }
        : { orderBy?: MediaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MediaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMediaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Media model
   */
  readonly fields: MediaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Media.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MediaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    SubAccounts<T extends SubAccountsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubAccountsDefaultArgs<ExtArgs>>): Prisma__SubAccountsClient<$Result.GetResult<Prisma.$SubAccountsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Media model
   */
  interface MediaFieldRefs {
    readonly id: FieldRef<"Media", 'String'>
    readonly type: FieldRef<"Media", 'String'>
    readonly name: FieldRef<"Media", 'String'>
    readonly link: FieldRef<"Media", 'String'>
    readonly subAccountId: FieldRef<"Media", 'String'>
    readonly createdAt: FieldRef<"Media", 'DateTime'>
    readonly updatedAt: FieldRef<"Media", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Media findUnique
   */
  export type MediaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media findUniqueOrThrow
   */
  export type MediaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media findFirst
   */
  export type MediaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Media.
     */
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media findFirstOrThrow
   */
  export type MediaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Media.
     */
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media findMany
   */
  export type MediaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media create
   */
  export type MediaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * The data needed to create a Media.
     */
    data: XOR<MediaCreateInput, MediaUncheckedCreateInput>
  }

  /**
   * Media createMany
   */
  export type MediaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Media.
     */
    data: MediaCreateManyInput | MediaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Media createManyAndReturn
   */
  export type MediaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * The data used to create many Media.
     */
    data: MediaCreateManyInput | MediaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Media update
   */
  export type MediaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * The data needed to update a Media.
     */
    data: XOR<MediaUpdateInput, MediaUncheckedUpdateInput>
    /**
     * Choose, which Media to update.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media updateMany
   */
  export type MediaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Media.
     */
    data: XOR<MediaUpdateManyMutationInput, MediaUncheckedUpdateManyInput>
    /**
     * Filter which Media to update
     */
    where?: MediaWhereInput
    /**
     * Limit how many Media to update.
     */
    limit?: number
  }

  /**
   * Media updateManyAndReturn
   */
  export type MediaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * The data used to update Media.
     */
    data: XOR<MediaUpdateManyMutationInput, MediaUncheckedUpdateManyInput>
    /**
     * Filter which Media to update
     */
    where?: MediaWhereInput
    /**
     * Limit how many Media to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Media upsert
   */
  export type MediaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * The filter to search for the Media to update in case it exists.
     */
    where: MediaWhereUniqueInput
    /**
     * In case the Media found by the `where` argument doesn't exist, create a new Media with this data.
     */
    create: XOR<MediaCreateInput, MediaUncheckedCreateInput>
    /**
     * In case the Media was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MediaUpdateInput, MediaUncheckedUpdateInput>
  }

  /**
   * Media delete
   */
  export type MediaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter which Media to delete.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media deleteMany
   */
  export type MediaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Media to delete
     */
    where?: MediaWhereInput
    /**
     * Limit how many Media to delete.
     */
    limit?: number
  }

  /**
   * Media without action
   */
  export type MediaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
  }


  /**
   * Model Lane
   */

  export type AggregateLane = {
    _count: LaneCountAggregateOutputType | null
    _avg: LaneAvgAggregateOutputType | null
    _sum: LaneSumAggregateOutputType | null
    _min: LaneMinAggregateOutputType | null
    _max: LaneMaxAggregateOutputType | null
  }

  export type LaneAvgAggregateOutputType = {
    order: number | null
  }

  export type LaneSumAggregateOutputType = {
    order: number | null
  }

  export type LaneMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    pipelineId: string | null
    order: number | null
  }

  export type LaneMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    pipelineId: string | null
    order: number | null
  }

  export type LaneCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    pipelineId: number
    order: number
    _all: number
  }


  export type LaneAvgAggregateInputType = {
    order?: true
  }

  export type LaneSumAggregateInputType = {
    order?: true
  }

  export type LaneMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    pipelineId?: true
    order?: true
  }

  export type LaneMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    pipelineId?: true
    order?: true
  }

  export type LaneCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    pipelineId?: true
    order?: true
    _all?: true
  }

  export type LaneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lane to aggregate.
     */
    where?: LaneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lanes to fetch.
     */
    orderBy?: LaneOrderByWithRelationInput | LaneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LaneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lanes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lanes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lanes
    **/
    _count?: true | LaneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LaneAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LaneSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LaneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LaneMaxAggregateInputType
  }

  export type GetLaneAggregateType<T extends LaneAggregateArgs> = {
        [P in keyof T & keyof AggregateLane]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLane[P]>
      : GetScalarType<T[P], AggregateLane[P]>
  }




  export type LaneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LaneWhereInput
    orderBy?: LaneOrderByWithAggregationInput | LaneOrderByWithAggregationInput[]
    by: LaneScalarFieldEnum[] | LaneScalarFieldEnum
    having?: LaneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LaneCountAggregateInputType | true
    _avg?: LaneAvgAggregateInputType
    _sum?: LaneSumAggregateInputType
    _min?: LaneMinAggregateInputType
    _max?: LaneMaxAggregateInputType
  }

  export type LaneGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    updatedAt: Date
    pipelineId: string
    order: number
    _count: LaneCountAggregateOutputType | null
    _avg: LaneAvgAggregateOutputType | null
    _sum: LaneSumAggregateOutputType | null
    _min: LaneMinAggregateOutputType | null
    _max: LaneMaxAggregateOutputType | null
  }

  type GetLaneGroupByPayload<T extends LaneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LaneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LaneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LaneGroupByOutputType[P]>
            : GetScalarType<T[P], LaneGroupByOutputType[P]>
        }
      >
    >


  export type LaneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pipelineId?: boolean
    order?: boolean
    Pipeline?: boolean | PipelinesDefaultArgs<ExtArgs>
    Tickets?: boolean | Lane$TicketsArgs<ExtArgs>
    _count?: boolean | LaneCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lane"]>

  export type LaneSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pipelineId?: boolean
    order?: boolean
    Pipeline?: boolean | PipelinesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lane"]>

  export type LaneSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pipelineId?: boolean
    order?: boolean
    Pipeline?: boolean | PipelinesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lane"]>

  export type LaneSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pipelineId?: boolean
    order?: boolean
  }

  export type LaneOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "updatedAt" | "pipelineId" | "order", ExtArgs["result"]["lane"]>
  export type LaneInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Pipeline?: boolean | PipelinesDefaultArgs<ExtArgs>
    Tickets?: boolean | Lane$TicketsArgs<ExtArgs>
    _count?: boolean | LaneCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LaneIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Pipeline?: boolean | PipelinesDefaultArgs<ExtArgs>
  }
  export type LaneIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Pipeline?: boolean | PipelinesDefaultArgs<ExtArgs>
  }

  export type $LanePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lane"
    objects: {
      Pipeline: Prisma.$PipelinesPayload<ExtArgs>
      Tickets: Prisma.$TicketsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
      updatedAt: Date
      pipelineId: string
      order: number
    }, ExtArgs["result"]["lane"]>
    composites: {}
  }

  type LaneGetPayload<S extends boolean | null | undefined | LaneDefaultArgs> = $Result.GetResult<Prisma.$LanePayload, S>

  type LaneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LaneFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LaneCountAggregateInputType | true
    }

  export interface LaneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lane'], meta: { name: 'Lane' } }
    /**
     * Find zero or one Lane that matches the filter.
     * @param {LaneFindUniqueArgs} args - Arguments to find a Lane
     * @example
     * // Get one Lane
     * const lane = await prisma.lane.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LaneFindUniqueArgs>(args: SelectSubset<T, LaneFindUniqueArgs<ExtArgs>>): Prisma__LaneClient<$Result.GetResult<Prisma.$LanePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Lane that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LaneFindUniqueOrThrowArgs} args - Arguments to find a Lane
     * @example
     * // Get one Lane
     * const lane = await prisma.lane.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LaneFindUniqueOrThrowArgs>(args: SelectSubset<T, LaneFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LaneClient<$Result.GetResult<Prisma.$LanePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lane that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaneFindFirstArgs} args - Arguments to find a Lane
     * @example
     * // Get one Lane
     * const lane = await prisma.lane.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LaneFindFirstArgs>(args?: SelectSubset<T, LaneFindFirstArgs<ExtArgs>>): Prisma__LaneClient<$Result.GetResult<Prisma.$LanePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lane that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaneFindFirstOrThrowArgs} args - Arguments to find a Lane
     * @example
     * // Get one Lane
     * const lane = await prisma.lane.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LaneFindFirstOrThrowArgs>(args?: SelectSubset<T, LaneFindFirstOrThrowArgs<ExtArgs>>): Prisma__LaneClient<$Result.GetResult<Prisma.$LanePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Lanes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaneFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lanes
     * const lanes = await prisma.lane.findMany()
     * 
     * // Get first 10 Lanes
     * const lanes = await prisma.lane.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const laneWithIdOnly = await prisma.lane.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LaneFindManyArgs>(args?: SelectSubset<T, LaneFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Lane.
     * @param {LaneCreateArgs} args - Arguments to create a Lane.
     * @example
     * // Create one Lane
     * const Lane = await prisma.lane.create({
     *   data: {
     *     // ... data to create a Lane
     *   }
     * })
     * 
     */
    create<T extends LaneCreateArgs>(args: SelectSubset<T, LaneCreateArgs<ExtArgs>>): Prisma__LaneClient<$Result.GetResult<Prisma.$LanePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Lanes.
     * @param {LaneCreateManyArgs} args - Arguments to create many Lanes.
     * @example
     * // Create many Lanes
     * const lane = await prisma.lane.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LaneCreateManyArgs>(args?: SelectSubset<T, LaneCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Lanes and returns the data saved in the database.
     * @param {LaneCreateManyAndReturnArgs} args - Arguments to create many Lanes.
     * @example
     * // Create many Lanes
     * const lane = await prisma.lane.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Lanes and only return the `id`
     * const laneWithIdOnly = await prisma.lane.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LaneCreateManyAndReturnArgs>(args?: SelectSubset<T, LaneCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Lane.
     * @param {LaneDeleteArgs} args - Arguments to delete one Lane.
     * @example
     * // Delete one Lane
     * const Lane = await prisma.lane.delete({
     *   where: {
     *     // ... filter to delete one Lane
     *   }
     * })
     * 
     */
    delete<T extends LaneDeleteArgs>(args: SelectSubset<T, LaneDeleteArgs<ExtArgs>>): Prisma__LaneClient<$Result.GetResult<Prisma.$LanePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Lane.
     * @param {LaneUpdateArgs} args - Arguments to update one Lane.
     * @example
     * // Update one Lane
     * const lane = await prisma.lane.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LaneUpdateArgs>(args: SelectSubset<T, LaneUpdateArgs<ExtArgs>>): Prisma__LaneClient<$Result.GetResult<Prisma.$LanePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Lanes.
     * @param {LaneDeleteManyArgs} args - Arguments to filter Lanes to delete.
     * @example
     * // Delete a few Lanes
     * const { count } = await prisma.lane.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LaneDeleteManyArgs>(args?: SelectSubset<T, LaneDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lanes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lanes
     * const lane = await prisma.lane.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LaneUpdateManyArgs>(args: SelectSubset<T, LaneUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lanes and returns the data updated in the database.
     * @param {LaneUpdateManyAndReturnArgs} args - Arguments to update many Lanes.
     * @example
     * // Update many Lanes
     * const lane = await prisma.lane.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Lanes and only return the `id`
     * const laneWithIdOnly = await prisma.lane.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LaneUpdateManyAndReturnArgs>(args: SelectSubset<T, LaneUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LanePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Lane.
     * @param {LaneUpsertArgs} args - Arguments to update or create a Lane.
     * @example
     * // Update or create a Lane
     * const lane = await prisma.lane.upsert({
     *   create: {
     *     // ... data to create a Lane
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lane we want to update
     *   }
     * })
     */
    upsert<T extends LaneUpsertArgs>(args: SelectSubset<T, LaneUpsertArgs<ExtArgs>>): Prisma__LaneClient<$Result.GetResult<Prisma.$LanePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Lanes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaneCountArgs} args - Arguments to filter Lanes to count.
     * @example
     * // Count the number of Lanes
     * const count = await prisma.lane.count({
     *   where: {
     *     // ... the filter for the Lanes we want to count
     *   }
     * })
    **/
    count<T extends LaneCountArgs>(
      args?: Subset<T, LaneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LaneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lane.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LaneAggregateArgs>(args: Subset<T, LaneAggregateArgs>): Prisma.PrismaPromise<GetLaneAggregateType<T>>

    /**
     * Group by Lane.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LaneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LaneGroupByArgs['orderBy'] }
        : { orderBy?: LaneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LaneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLaneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lane model
   */
  readonly fields: LaneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lane.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LaneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Pipeline<T extends PipelinesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PipelinesDefaultArgs<ExtArgs>>): Prisma__PipelinesClient<$Result.GetResult<Prisma.$PipelinesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Tickets<T extends Lane$TicketsArgs<ExtArgs> = {}>(args?: Subset<T, Lane$TicketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lane model
   */
  interface LaneFieldRefs {
    readonly id: FieldRef<"Lane", 'String'>
    readonly name: FieldRef<"Lane", 'String'>
    readonly createdAt: FieldRef<"Lane", 'DateTime'>
    readonly updatedAt: FieldRef<"Lane", 'DateTime'>
    readonly pipelineId: FieldRef<"Lane", 'String'>
    readonly order: FieldRef<"Lane", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Lane findUnique
   */
  export type LaneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lane
     */
    select?: LaneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lane
     */
    omit?: LaneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaneInclude<ExtArgs> | null
    /**
     * Filter, which Lane to fetch.
     */
    where: LaneWhereUniqueInput
  }

  /**
   * Lane findUniqueOrThrow
   */
  export type LaneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lane
     */
    select?: LaneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lane
     */
    omit?: LaneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaneInclude<ExtArgs> | null
    /**
     * Filter, which Lane to fetch.
     */
    where: LaneWhereUniqueInput
  }

  /**
   * Lane findFirst
   */
  export type LaneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lane
     */
    select?: LaneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lane
     */
    omit?: LaneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaneInclude<ExtArgs> | null
    /**
     * Filter, which Lane to fetch.
     */
    where?: LaneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lanes to fetch.
     */
    orderBy?: LaneOrderByWithRelationInput | LaneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lanes.
     */
    cursor?: LaneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lanes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lanes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lanes.
     */
    distinct?: LaneScalarFieldEnum | LaneScalarFieldEnum[]
  }

  /**
   * Lane findFirstOrThrow
   */
  export type LaneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lane
     */
    select?: LaneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lane
     */
    omit?: LaneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaneInclude<ExtArgs> | null
    /**
     * Filter, which Lane to fetch.
     */
    where?: LaneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lanes to fetch.
     */
    orderBy?: LaneOrderByWithRelationInput | LaneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lanes.
     */
    cursor?: LaneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lanes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lanes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lanes.
     */
    distinct?: LaneScalarFieldEnum | LaneScalarFieldEnum[]
  }

  /**
   * Lane findMany
   */
  export type LaneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lane
     */
    select?: LaneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lane
     */
    omit?: LaneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaneInclude<ExtArgs> | null
    /**
     * Filter, which Lanes to fetch.
     */
    where?: LaneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lanes to fetch.
     */
    orderBy?: LaneOrderByWithRelationInput | LaneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lanes.
     */
    cursor?: LaneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lanes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lanes.
     */
    skip?: number
    distinct?: LaneScalarFieldEnum | LaneScalarFieldEnum[]
  }

  /**
   * Lane create
   */
  export type LaneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lane
     */
    select?: LaneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lane
     */
    omit?: LaneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaneInclude<ExtArgs> | null
    /**
     * The data needed to create a Lane.
     */
    data: XOR<LaneCreateInput, LaneUncheckedCreateInput>
  }

  /**
   * Lane createMany
   */
  export type LaneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Lanes.
     */
    data: LaneCreateManyInput | LaneCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lane createManyAndReturn
   */
  export type LaneCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lane
     */
    select?: LaneSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lane
     */
    omit?: LaneOmit<ExtArgs> | null
    /**
     * The data used to create many Lanes.
     */
    data: LaneCreateManyInput | LaneCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaneIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lane update
   */
  export type LaneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lane
     */
    select?: LaneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lane
     */
    omit?: LaneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaneInclude<ExtArgs> | null
    /**
     * The data needed to update a Lane.
     */
    data: XOR<LaneUpdateInput, LaneUncheckedUpdateInput>
    /**
     * Choose, which Lane to update.
     */
    where: LaneWhereUniqueInput
  }

  /**
   * Lane updateMany
   */
  export type LaneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Lanes.
     */
    data: XOR<LaneUpdateManyMutationInput, LaneUncheckedUpdateManyInput>
    /**
     * Filter which Lanes to update
     */
    where?: LaneWhereInput
    /**
     * Limit how many Lanes to update.
     */
    limit?: number
  }

  /**
   * Lane updateManyAndReturn
   */
  export type LaneUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lane
     */
    select?: LaneSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lane
     */
    omit?: LaneOmit<ExtArgs> | null
    /**
     * The data used to update Lanes.
     */
    data: XOR<LaneUpdateManyMutationInput, LaneUncheckedUpdateManyInput>
    /**
     * Filter which Lanes to update
     */
    where?: LaneWhereInput
    /**
     * Limit how many Lanes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaneIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lane upsert
   */
  export type LaneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lane
     */
    select?: LaneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lane
     */
    omit?: LaneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaneInclude<ExtArgs> | null
    /**
     * The filter to search for the Lane to update in case it exists.
     */
    where: LaneWhereUniqueInput
    /**
     * In case the Lane found by the `where` argument doesn't exist, create a new Lane with this data.
     */
    create: XOR<LaneCreateInput, LaneUncheckedCreateInput>
    /**
     * In case the Lane was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LaneUpdateInput, LaneUncheckedUpdateInput>
  }

  /**
   * Lane delete
   */
  export type LaneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lane
     */
    select?: LaneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lane
     */
    omit?: LaneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaneInclude<ExtArgs> | null
    /**
     * Filter which Lane to delete.
     */
    where: LaneWhereUniqueInput
  }

  /**
   * Lane deleteMany
   */
  export type LaneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lanes to delete
     */
    where?: LaneWhereInput
    /**
     * Limit how many Lanes to delete.
     */
    limit?: number
  }

  /**
   * Lane.Tickets
   */
  export type Lane$TicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tickets
     */
    select?: TicketsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tickets
     */
    omit?: TicketsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketsInclude<ExtArgs> | null
    where?: TicketsWhereInput
    orderBy?: TicketsOrderByWithRelationInput | TicketsOrderByWithRelationInput[]
    cursor?: TicketsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketsScalarFieldEnum | TicketsScalarFieldEnum[]
  }

  /**
   * Lane without action
   */
  export type LaneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lane
     */
    select?: LaneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lane
     */
    omit?: LaneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LaneInclude<ExtArgs> | null
  }


  /**
   * Model Tickets
   */

  export type AggregateTickets = {
    _count: TicketsCountAggregateOutputType | null
    _avg: TicketsAvgAggregateOutputType | null
    _sum: TicketsSumAggregateOutputType | null
    _min: TicketsMinAggregateOutputType | null
    _max: TicketsMaxAggregateOutputType | null
  }

  export type TicketsAvgAggregateOutputType = {
    order: number | null
    value: Decimal | null
  }

  export type TicketsSumAggregateOutputType = {
    order: number | null
    value: Decimal | null
  }

  export type TicketsMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    lineId: string | null
    order: number | null
    value: Decimal | null
    description: string | null
    userId: string | null
    contactId: string | null
  }

  export type TicketsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    lineId: string | null
    order: number | null
    value: Decimal | null
    description: string | null
    userId: string | null
    contactId: string | null
  }

  export type TicketsCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    lineId: number
    order: number
    value: number
    description: number
    userId: number
    contactId: number
    _all: number
  }


  export type TicketsAvgAggregateInputType = {
    order?: true
    value?: true
  }

  export type TicketsSumAggregateInputType = {
    order?: true
    value?: true
  }

  export type TicketsMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    lineId?: true
    order?: true
    value?: true
    description?: true
    userId?: true
    contactId?: true
  }

  export type TicketsMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    lineId?: true
    order?: true
    value?: true
    description?: true
    userId?: true
    contactId?: true
  }

  export type TicketsCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    lineId?: true
    order?: true
    value?: true
    description?: true
    userId?: true
    contactId?: true
    _all?: true
  }

  export type TicketsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tickets to aggregate.
     */
    where?: TicketsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketsOrderByWithRelationInput | TicketsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tickets
    **/
    _count?: true | TicketsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TicketsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TicketsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketsMaxAggregateInputType
  }

  export type GetTicketsAggregateType<T extends TicketsAggregateArgs> = {
        [P in keyof T & keyof AggregateTickets]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTickets[P]>
      : GetScalarType<T[P], AggregateTickets[P]>
  }




  export type TicketsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketsWhereInput
    orderBy?: TicketsOrderByWithAggregationInput | TicketsOrderByWithAggregationInput[]
    by: TicketsScalarFieldEnum[] | TicketsScalarFieldEnum
    having?: TicketsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketsCountAggregateInputType | true
    _avg?: TicketsAvgAggregateInputType
    _sum?: TicketsSumAggregateInputType
    _min?: TicketsMinAggregateInputType
    _max?: TicketsMaxAggregateInputType
  }

  export type TicketsGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    updatedAt: Date
    lineId: string
    order: number
    value: Decimal | null
    description: string | null
    userId: string | null
    contactId: string | null
    _count: TicketsCountAggregateOutputType | null
    _avg: TicketsAvgAggregateOutputType | null
    _sum: TicketsSumAggregateOutputType | null
    _min: TicketsMinAggregateOutputType | null
    _max: TicketsMaxAggregateOutputType | null
  }

  type GetTicketsGroupByPayload<T extends TicketsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketsGroupByOutputType[P]>
            : GetScalarType<T[P], TicketsGroupByOutputType[P]>
        }
      >
    >


  export type TicketsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lineId?: boolean
    order?: boolean
    value?: boolean
    description?: boolean
    userId?: boolean
    contactId?: boolean
    Lane?: boolean | LaneDefaultArgs<ExtArgs>
    tags?: boolean | Tickets$tagsArgs<ExtArgs>
    Users?: boolean | Tickets$UsersArgs<ExtArgs>
    Contacts?: boolean | Tickets$ContactsArgs<ExtArgs>
    _count?: boolean | TicketsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tickets"]>

  export type TicketsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lineId?: boolean
    order?: boolean
    value?: boolean
    description?: boolean
    userId?: boolean
    contactId?: boolean
    Lane?: boolean | LaneDefaultArgs<ExtArgs>
    Users?: boolean | Tickets$UsersArgs<ExtArgs>
    Contacts?: boolean | Tickets$ContactsArgs<ExtArgs>
  }, ExtArgs["result"]["tickets"]>

  export type TicketsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lineId?: boolean
    order?: boolean
    value?: boolean
    description?: boolean
    userId?: boolean
    contactId?: boolean
    Lane?: boolean | LaneDefaultArgs<ExtArgs>
    Users?: boolean | Tickets$UsersArgs<ExtArgs>
    Contacts?: boolean | Tickets$ContactsArgs<ExtArgs>
  }, ExtArgs["result"]["tickets"]>

  export type TicketsSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lineId?: boolean
    order?: boolean
    value?: boolean
    description?: boolean
    userId?: boolean
    contactId?: boolean
  }

  export type TicketsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "updatedAt" | "lineId" | "order" | "value" | "description" | "userId" | "contactId", ExtArgs["result"]["tickets"]>
  export type TicketsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Lane?: boolean | LaneDefaultArgs<ExtArgs>
    tags?: boolean | Tickets$tagsArgs<ExtArgs>
    Users?: boolean | Tickets$UsersArgs<ExtArgs>
    Contacts?: boolean | Tickets$ContactsArgs<ExtArgs>
    _count?: boolean | TicketsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TicketsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Lane?: boolean | LaneDefaultArgs<ExtArgs>
    Users?: boolean | Tickets$UsersArgs<ExtArgs>
    Contacts?: boolean | Tickets$ContactsArgs<ExtArgs>
  }
  export type TicketsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Lane?: boolean | LaneDefaultArgs<ExtArgs>
    Users?: boolean | Tickets$UsersArgs<ExtArgs>
    Contacts?: boolean | Tickets$ContactsArgs<ExtArgs>
  }

  export type $TicketsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tickets"
    objects: {
      Lane: Prisma.$LanePayload<ExtArgs>
      tags: Prisma.$TagsPayload<ExtArgs>[]
      Users: Prisma.$UsersPayload<ExtArgs> | null
      Contacts: Prisma.$ContactsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
      updatedAt: Date
      lineId: string
      order: number
      value: Prisma.Decimal | null
      description: string | null
      userId: string | null
      contactId: string | null
    }, ExtArgs["result"]["tickets"]>
    composites: {}
  }

  type TicketsGetPayload<S extends boolean | null | undefined | TicketsDefaultArgs> = $Result.GetResult<Prisma.$TicketsPayload, S>

  type TicketsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TicketsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TicketsCountAggregateInputType | true
    }

  export interface TicketsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tickets'], meta: { name: 'Tickets' } }
    /**
     * Find zero or one Tickets that matches the filter.
     * @param {TicketsFindUniqueArgs} args - Arguments to find a Tickets
     * @example
     * // Get one Tickets
     * const tickets = await prisma.tickets.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketsFindUniqueArgs>(args: SelectSubset<T, TicketsFindUniqueArgs<ExtArgs>>): Prisma__TicketsClient<$Result.GetResult<Prisma.$TicketsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tickets that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TicketsFindUniqueOrThrowArgs} args - Arguments to find a Tickets
     * @example
     * // Get one Tickets
     * const tickets = await prisma.tickets.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketsFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketsClient<$Result.GetResult<Prisma.$TicketsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tickets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketsFindFirstArgs} args - Arguments to find a Tickets
     * @example
     * // Get one Tickets
     * const tickets = await prisma.tickets.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketsFindFirstArgs>(args?: SelectSubset<T, TicketsFindFirstArgs<ExtArgs>>): Prisma__TicketsClient<$Result.GetResult<Prisma.$TicketsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tickets that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketsFindFirstOrThrowArgs} args - Arguments to find a Tickets
     * @example
     * // Get one Tickets
     * const tickets = await prisma.tickets.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketsFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketsFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketsClient<$Result.GetResult<Prisma.$TicketsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tickets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tickets
     * const tickets = await prisma.tickets.findMany()
     * 
     * // Get first 10 Tickets
     * const tickets = await prisma.tickets.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketsWithIdOnly = await prisma.tickets.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TicketsFindManyArgs>(args?: SelectSubset<T, TicketsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tickets.
     * @param {TicketsCreateArgs} args - Arguments to create a Tickets.
     * @example
     * // Create one Tickets
     * const Tickets = await prisma.tickets.create({
     *   data: {
     *     // ... data to create a Tickets
     *   }
     * })
     * 
     */
    create<T extends TicketsCreateArgs>(args: SelectSubset<T, TicketsCreateArgs<ExtArgs>>): Prisma__TicketsClient<$Result.GetResult<Prisma.$TicketsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tickets.
     * @param {TicketsCreateManyArgs} args - Arguments to create many Tickets.
     * @example
     * // Create many Tickets
     * const tickets = await prisma.tickets.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketsCreateManyArgs>(args?: SelectSubset<T, TicketsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tickets and returns the data saved in the database.
     * @param {TicketsCreateManyAndReturnArgs} args - Arguments to create many Tickets.
     * @example
     * // Create many Tickets
     * const tickets = await prisma.tickets.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tickets and only return the `id`
     * const ticketsWithIdOnly = await prisma.tickets.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TicketsCreateManyAndReturnArgs>(args?: SelectSubset<T, TicketsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tickets.
     * @param {TicketsDeleteArgs} args - Arguments to delete one Tickets.
     * @example
     * // Delete one Tickets
     * const Tickets = await prisma.tickets.delete({
     *   where: {
     *     // ... filter to delete one Tickets
     *   }
     * })
     * 
     */
    delete<T extends TicketsDeleteArgs>(args: SelectSubset<T, TicketsDeleteArgs<ExtArgs>>): Prisma__TicketsClient<$Result.GetResult<Prisma.$TicketsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tickets.
     * @param {TicketsUpdateArgs} args - Arguments to update one Tickets.
     * @example
     * // Update one Tickets
     * const tickets = await prisma.tickets.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketsUpdateArgs>(args: SelectSubset<T, TicketsUpdateArgs<ExtArgs>>): Prisma__TicketsClient<$Result.GetResult<Prisma.$TicketsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tickets.
     * @param {TicketsDeleteManyArgs} args - Arguments to filter Tickets to delete.
     * @example
     * // Delete a few Tickets
     * const { count } = await prisma.tickets.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketsDeleteManyArgs>(args?: SelectSubset<T, TicketsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tickets
     * const tickets = await prisma.tickets.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketsUpdateManyArgs>(args: SelectSubset<T, TicketsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tickets and returns the data updated in the database.
     * @param {TicketsUpdateManyAndReturnArgs} args - Arguments to update many Tickets.
     * @example
     * // Update many Tickets
     * const tickets = await prisma.tickets.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tickets and only return the `id`
     * const ticketsWithIdOnly = await prisma.tickets.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TicketsUpdateManyAndReturnArgs>(args: SelectSubset<T, TicketsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tickets.
     * @param {TicketsUpsertArgs} args - Arguments to update or create a Tickets.
     * @example
     * // Update or create a Tickets
     * const tickets = await prisma.tickets.upsert({
     *   create: {
     *     // ... data to create a Tickets
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tickets we want to update
     *   }
     * })
     */
    upsert<T extends TicketsUpsertArgs>(args: SelectSubset<T, TicketsUpsertArgs<ExtArgs>>): Prisma__TicketsClient<$Result.GetResult<Prisma.$TicketsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketsCountArgs} args - Arguments to filter Tickets to count.
     * @example
     * // Count the number of Tickets
     * const count = await prisma.tickets.count({
     *   where: {
     *     // ... the filter for the Tickets we want to count
     *   }
     * })
    **/
    count<T extends TicketsCountArgs>(
      args?: Subset<T, TicketsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketsAggregateArgs>(args: Subset<T, TicketsAggregateArgs>): Prisma.PrismaPromise<GetTicketsAggregateType<T>>

    /**
     * Group by Tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketsGroupByArgs['orderBy'] }
        : { orderBy?: TicketsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tickets model
   */
  readonly fields: TicketsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tickets.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Lane<T extends LaneDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LaneDefaultArgs<ExtArgs>>): Prisma__LaneClient<$Result.GetResult<Prisma.$LanePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tags<T extends Tickets$tagsArgs<ExtArgs> = {}>(args?: Subset<T, Tickets$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Users<T extends Tickets$UsersArgs<ExtArgs> = {}>(args?: Subset<T, Tickets$UsersArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Contacts<T extends Tickets$ContactsArgs<ExtArgs> = {}>(args?: Subset<T, Tickets$ContactsArgs<ExtArgs>>): Prisma__ContactsClient<$Result.GetResult<Prisma.$ContactsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tickets model
   */
  interface TicketsFieldRefs {
    readonly id: FieldRef<"Tickets", 'String'>
    readonly name: FieldRef<"Tickets", 'String'>
    readonly createdAt: FieldRef<"Tickets", 'DateTime'>
    readonly updatedAt: FieldRef<"Tickets", 'DateTime'>
    readonly lineId: FieldRef<"Tickets", 'String'>
    readonly order: FieldRef<"Tickets", 'Int'>
    readonly value: FieldRef<"Tickets", 'Decimal'>
    readonly description: FieldRef<"Tickets", 'String'>
    readonly userId: FieldRef<"Tickets", 'String'>
    readonly contactId: FieldRef<"Tickets", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Tickets findUnique
   */
  export type TicketsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tickets
     */
    select?: TicketsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tickets
     */
    omit?: TicketsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketsInclude<ExtArgs> | null
    /**
     * Filter, which Tickets to fetch.
     */
    where: TicketsWhereUniqueInput
  }

  /**
   * Tickets findUniqueOrThrow
   */
  export type TicketsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tickets
     */
    select?: TicketsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tickets
     */
    omit?: TicketsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketsInclude<ExtArgs> | null
    /**
     * Filter, which Tickets to fetch.
     */
    where: TicketsWhereUniqueInput
  }

  /**
   * Tickets findFirst
   */
  export type TicketsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tickets
     */
    select?: TicketsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tickets
     */
    omit?: TicketsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketsInclude<ExtArgs> | null
    /**
     * Filter, which Tickets to fetch.
     */
    where?: TicketsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketsOrderByWithRelationInput | TicketsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tickets.
     */
    cursor?: TicketsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tickets.
     */
    distinct?: TicketsScalarFieldEnum | TicketsScalarFieldEnum[]
  }

  /**
   * Tickets findFirstOrThrow
   */
  export type TicketsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tickets
     */
    select?: TicketsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tickets
     */
    omit?: TicketsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketsInclude<ExtArgs> | null
    /**
     * Filter, which Tickets to fetch.
     */
    where?: TicketsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketsOrderByWithRelationInput | TicketsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tickets.
     */
    cursor?: TicketsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tickets.
     */
    distinct?: TicketsScalarFieldEnum | TicketsScalarFieldEnum[]
  }

  /**
   * Tickets findMany
   */
  export type TicketsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tickets
     */
    select?: TicketsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tickets
     */
    omit?: TicketsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketsInclude<ExtArgs> | null
    /**
     * Filter, which Tickets to fetch.
     */
    where?: TicketsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketsOrderByWithRelationInput | TicketsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tickets.
     */
    cursor?: TicketsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    distinct?: TicketsScalarFieldEnum | TicketsScalarFieldEnum[]
  }

  /**
   * Tickets create
   */
  export type TicketsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tickets
     */
    select?: TicketsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tickets
     */
    omit?: TicketsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketsInclude<ExtArgs> | null
    /**
     * The data needed to create a Tickets.
     */
    data: XOR<TicketsCreateInput, TicketsUncheckedCreateInput>
  }

  /**
   * Tickets createMany
   */
  export type TicketsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tickets.
     */
    data: TicketsCreateManyInput | TicketsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tickets createManyAndReturn
   */
  export type TicketsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tickets
     */
    select?: TicketsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tickets
     */
    omit?: TicketsOmit<ExtArgs> | null
    /**
     * The data used to create many Tickets.
     */
    data: TicketsCreateManyInput | TicketsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tickets update
   */
  export type TicketsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tickets
     */
    select?: TicketsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tickets
     */
    omit?: TicketsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketsInclude<ExtArgs> | null
    /**
     * The data needed to update a Tickets.
     */
    data: XOR<TicketsUpdateInput, TicketsUncheckedUpdateInput>
    /**
     * Choose, which Tickets to update.
     */
    where: TicketsWhereUniqueInput
  }

  /**
   * Tickets updateMany
   */
  export type TicketsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tickets.
     */
    data: XOR<TicketsUpdateManyMutationInput, TicketsUncheckedUpdateManyInput>
    /**
     * Filter which Tickets to update
     */
    where?: TicketsWhereInput
    /**
     * Limit how many Tickets to update.
     */
    limit?: number
  }

  /**
   * Tickets updateManyAndReturn
   */
  export type TicketsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tickets
     */
    select?: TicketsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tickets
     */
    omit?: TicketsOmit<ExtArgs> | null
    /**
     * The data used to update Tickets.
     */
    data: XOR<TicketsUpdateManyMutationInput, TicketsUncheckedUpdateManyInput>
    /**
     * Filter which Tickets to update
     */
    where?: TicketsWhereInput
    /**
     * Limit how many Tickets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tickets upsert
   */
  export type TicketsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tickets
     */
    select?: TicketsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tickets
     */
    omit?: TicketsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketsInclude<ExtArgs> | null
    /**
     * The filter to search for the Tickets to update in case it exists.
     */
    where: TicketsWhereUniqueInput
    /**
     * In case the Tickets found by the `where` argument doesn't exist, create a new Tickets with this data.
     */
    create: XOR<TicketsCreateInput, TicketsUncheckedCreateInput>
    /**
     * In case the Tickets was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketsUpdateInput, TicketsUncheckedUpdateInput>
  }

  /**
   * Tickets delete
   */
  export type TicketsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tickets
     */
    select?: TicketsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tickets
     */
    omit?: TicketsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketsInclude<ExtArgs> | null
    /**
     * Filter which Tickets to delete.
     */
    where: TicketsWhereUniqueInput
  }

  /**
   * Tickets deleteMany
   */
  export type TicketsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tickets to delete
     */
    where?: TicketsWhereInput
    /**
     * Limit how many Tickets to delete.
     */
    limit?: number
  }

  /**
   * Tickets.tags
   */
  export type Tickets$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsInclude<ExtArgs> | null
    where?: TagsWhereInput
    orderBy?: TagsOrderByWithRelationInput | TagsOrderByWithRelationInput[]
    cursor?: TagsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagsScalarFieldEnum | TagsScalarFieldEnum[]
  }

  /**
   * Tickets.Users
   */
  export type Tickets$UsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Users
     */
    omit?: UsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    where?: UsersWhereInput
  }

  /**
   * Tickets.Contacts
   */
  export type Tickets$ContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contacts
     */
    select?: ContactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contacts
     */
    omit?: ContactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactsInclude<ExtArgs> | null
    where?: ContactsWhereInput
  }

  /**
   * Tickets without action
   */
  export type TicketsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tickets
     */
    select?: TicketsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tickets
     */
    omit?: TicketsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketsInclude<ExtArgs> | null
  }


  /**
   * Model Tags
   */

  export type AggregateTags = {
    _count: TagsCountAggregateOutputType | null
    _min: TagsMinAggregateOutputType | null
    _max: TagsMaxAggregateOutputType | null
  }

  export type TagsMinAggregateOutputType = {
    id: string | null
    nane: string | null
    color: string | null
    createdAt: Date | null
    updatedAt: Date | null
    subAccountId: string | null
  }

  export type TagsMaxAggregateOutputType = {
    id: string | null
    nane: string | null
    color: string | null
    createdAt: Date | null
    updatedAt: Date | null
    subAccountId: string | null
  }

  export type TagsCountAggregateOutputType = {
    id: number
    nane: number
    color: number
    createdAt: number
    updatedAt: number
    subAccountId: number
    _all: number
  }


  export type TagsMinAggregateInputType = {
    id?: true
    nane?: true
    color?: true
    createdAt?: true
    updatedAt?: true
    subAccountId?: true
  }

  export type TagsMaxAggregateInputType = {
    id?: true
    nane?: true
    color?: true
    createdAt?: true
    updatedAt?: true
    subAccountId?: true
  }

  export type TagsCountAggregateInputType = {
    id?: true
    nane?: true
    color?: true
    createdAt?: true
    updatedAt?: true
    subAccountId?: true
    _all?: true
  }

  export type TagsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to aggregate.
     */
    where?: TagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagsOrderByWithRelationInput | TagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagsMaxAggregateInputType
  }

  export type GetTagsAggregateType<T extends TagsAggregateArgs> = {
        [P in keyof T & keyof AggregateTags]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTags[P]>
      : GetScalarType<T[P], AggregateTags[P]>
  }




  export type TagsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagsWhereInput
    orderBy?: TagsOrderByWithAggregationInput | TagsOrderByWithAggregationInput[]
    by: TagsScalarFieldEnum[] | TagsScalarFieldEnum
    having?: TagsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagsCountAggregateInputType | true
    _min?: TagsMinAggregateInputType
    _max?: TagsMaxAggregateInputType
  }

  export type TagsGroupByOutputType = {
    id: string
    nane: string
    color: string
    createdAt: Date
    updatedAt: Date
    subAccountId: string
    _count: TagsCountAggregateOutputType | null
    _min: TagsMinAggregateOutputType | null
    _max: TagsMaxAggregateOutputType | null
  }

  type GetTagsGroupByPayload<T extends TagsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagsGroupByOutputType[P]>
            : GetScalarType<T[P], TagsGroupByOutputType[P]>
        }
      >
    >


  export type TagsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nane?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subAccountId?: boolean
    SubAccounts?: boolean | SubAccountsDefaultArgs<ExtArgs>
    Tickets?: boolean | Tags$TicketsArgs<ExtArgs>
    _count?: boolean | TagsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tags"]>

  export type TagsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nane?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subAccountId?: boolean
    SubAccounts?: boolean | SubAccountsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tags"]>

  export type TagsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nane?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subAccountId?: boolean
    SubAccounts?: boolean | SubAccountsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tags"]>

  export type TagsSelectScalar = {
    id?: boolean
    nane?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subAccountId?: boolean
  }

  export type TagsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nane" | "color" | "createdAt" | "updatedAt" | "subAccountId", ExtArgs["result"]["tags"]>
  export type TagsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SubAccounts?: boolean | SubAccountsDefaultArgs<ExtArgs>
    Tickets?: boolean | Tags$TicketsArgs<ExtArgs>
    _count?: boolean | TagsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TagsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SubAccounts?: boolean | SubAccountsDefaultArgs<ExtArgs>
  }
  export type TagsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SubAccounts?: boolean | SubAccountsDefaultArgs<ExtArgs>
  }

  export type $TagsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tags"
    objects: {
      SubAccounts: Prisma.$SubAccountsPayload<ExtArgs>
      Tickets: Prisma.$TicketsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nane: string
      color: string
      createdAt: Date
      updatedAt: Date
      subAccountId: string
    }, ExtArgs["result"]["tags"]>
    composites: {}
  }

  type TagsGetPayload<S extends boolean | null | undefined | TagsDefaultArgs> = $Result.GetResult<Prisma.$TagsPayload, S>

  type TagsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TagsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TagsCountAggregateInputType | true
    }

  export interface TagsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tags'], meta: { name: 'Tags' } }
    /**
     * Find zero or one Tags that matches the filter.
     * @param {TagsFindUniqueArgs} args - Arguments to find a Tags
     * @example
     * // Get one Tags
     * const tags = await prisma.tags.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TagsFindUniqueArgs>(args: SelectSubset<T, TagsFindUniqueArgs<ExtArgs>>): Prisma__TagsClient<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tags that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TagsFindUniqueOrThrowArgs} args - Arguments to find a Tags
     * @example
     * // Get one Tags
     * const tags = await prisma.tags.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TagsFindUniqueOrThrowArgs>(args: SelectSubset<T, TagsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TagsClient<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsFindFirstArgs} args - Arguments to find a Tags
     * @example
     * // Get one Tags
     * const tags = await prisma.tags.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TagsFindFirstArgs>(args?: SelectSubset<T, TagsFindFirstArgs<ExtArgs>>): Prisma__TagsClient<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tags that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsFindFirstOrThrowArgs} args - Arguments to find a Tags
     * @example
     * // Get one Tags
     * const tags = await prisma.tags.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TagsFindFirstOrThrowArgs>(args?: SelectSubset<T, TagsFindFirstOrThrowArgs<ExtArgs>>): Prisma__TagsClient<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tags.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tags.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagsWithIdOnly = await prisma.tags.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TagsFindManyArgs>(args?: SelectSubset<T, TagsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tags.
     * @param {TagsCreateArgs} args - Arguments to create a Tags.
     * @example
     * // Create one Tags
     * const Tags = await prisma.tags.create({
     *   data: {
     *     // ... data to create a Tags
     *   }
     * })
     * 
     */
    create<T extends TagsCreateArgs>(args: SelectSubset<T, TagsCreateArgs<ExtArgs>>): Prisma__TagsClient<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tags.
     * @param {TagsCreateManyArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tags = await prisma.tags.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TagsCreateManyArgs>(args?: SelectSubset<T, TagsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tags and returns the data saved in the database.
     * @param {TagsCreateManyAndReturnArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tags = await prisma.tags.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tags and only return the `id`
     * const tagsWithIdOnly = await prisma.tags.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TagsCreateManyAndReturnArgs>(args?: SelectSubset<T, TagsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tags.
     * @param {TagsDeleteArgs} args - Arguments to delete one Tags.
     * @example
     * // Delete one Tags
     * const Tags = await prisma.tags.delete({
     *   where: {
     *     // ... filter to delete one Tags
     *   }
     * })
     * 
     */
    delete<T extends TagsDeleteArgs>(args: SelectSubset<T, TagsDeleteArgs<ExtArgs>>): Prisma__TagsClient<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tags.
     * @param {TagsUpdateArgs} args - Arguments to update one Tags.
     * @example
     * // Update one Tags
     * const tags = await prisma.tags.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TagsUpdateArgs>(args: SelectSubset<T, TagsUpdateArgs<ExtArgs>>): Prisma__TagsClient<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tags.
     * @param {TagsDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tags.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TagsDeleteManyArgs>(args?: SelectSubset<T, TagsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tags = await prisma.tags.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TagsUpdateManyArgs>(args: SelectSubset<T, TagsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags and returns the data updated in the database.
     * @param {TagsUpdateManyAndReturnArgs} args - Arguments to update many Tags.
     * @example
     * // Update many Tags
     * const tags = await prisma.tags.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tags and only return the `id`
     * const tagsWithIdOnly = await prisma.tags.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TagsUpdateManyAndReturnArgs>(args: SelectSubset<T, TagsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tags.
     * @param {TagsUpsertArgs} args - Arguments to update or create a Tags.
     * @example
     * // Update or create a Tags
     * const tags = await prisma.tags.upsert({
     *   create: {
     *     // ... data to create a Tags
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tags we want to update
     *   }
     * })
     */
    upsert<T extends TagsUpsertArgs>(args: SelectSubset<T, TagsUpsertArgs<ExtArgs>>): Prisma__TagsClient<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tags.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagsCountArgs>(
      args?: Subset<T, TagsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagsAggregateArgs>(args: Subset<T, TagsAggregateArgs>): Prisma.PrismaPromise<GetTagsAggregateType<T>>

    /**
     * Group by Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagsGroupByArgs['orderBy'] }
        : { orderBy?: TagsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tags model
   */
  readonly fields: TagsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tags.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    SubAccounts<T extends SubAccountsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubAccountsDefaultArgs<ExtArgs>>): Prisma__SubAccountsClient<$Result.GetResult<Prisma.$SubAccountsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Tickets<T extends Tags$TicketsArgs<ExtArgs> = {}>(args?: Subset<T, Tags$TicketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tags model
   */
  interface TagsFieldRefs {
    readonly id: FieldRef<"Tags", 'String'>
    readonly nane: FieldRef<"Tags", 'String'>
    readonly color: FieldRef<"Tags", 'String'>
    readonly createdAt: FieldRef<"Tags", 'DateTime'>
    readonly updatedAt: FieldRef<"Tags", 'DateTime'>
    readonly subAccountId: FieldRef<"Tags", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Tags findUnique
   */
  export type TagsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where: TagsWhereUniqueInput
  }

  /**
   * Tags findUniqueOrThrow
   */
  export type TagsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where: TagsWhereUniqueInput
  }

  /**
   * Tags findFirst
   */
  export type TagsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagsOrderByWithRelationInput | TagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagsScalarFieldEnum | TagsScalarFieldEnum[]
  }

  /**
   * Tags findFirstOrThrow
   */
  export type TagsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagsOrderByWithRelationInput | TagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagsScalarFieldEnum | TagsScalarFieldEnum[]
  }

  /**
   * Tags findMany
   */
  export type TagsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagsOrderByWithRelationInput | TagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     */
    cursor?: TagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    distinct?: TagsScalarFieldEnum | TagsScalarFieldEnum[]
  }

  /**
   * Tags create
   */
  export type TagsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsInclude<ExtArgs> | null
    /**
     * The data needed to create a Tags.
     */
    data: XOR<TagsCreateInput, TagsUncheckedCreateInput>
  }

  /**
   * Tags createMany
   */
  export type TagsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tags.
     */
    data: TagsCreateManyInput | TagsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tags createManyAndReturn
   */
  export type TagsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * The data used to create many Tags.
     */
    data: TagsCreateManyInput | TagsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tags update
   */
  export type TagsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsInclude<ExtArgs> | null
    /**
     * The data needed to update a Tags.
     */
    data: XOR<TagsUpdateInput, TagsUncheckedUpdateInput>
    /**
     * Choose, which Tags to update.
     */
    where: TagsWhereUniqueInput
  }

  /**
   * Tags updateMany
   */
  export type TagsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tags.
     */
    data: XOR<TagsUpdateManyMutationInput, TagsUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagsWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tags updateManyAndReturn
   */
  export type TagsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * The data used to update Tags.
     */
    data: XOR<TagsUpdateManyMutationInput, TagsUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagsWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tags upsert
   */
  export type TagsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsInclude<ExtArgs> | null
    /**
     * The filter to search for the Tags to update in case it exists.
     */
    where: TagsWhereUniqueInput
    /**
     * In case the Tags found by the `where` argument doesn't exist, create a new Tags with this data.
     */
    create: XOR<TagsCreateInput, TagsUncheckedCreateInput>
    /**
     * In case the Tags was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagsUpdateInput, TagsUncheckedUpdateInput>
  }

  /**
   * Tags delete
   */
  export type TagsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsInclude<ExtArgs> | null
    /**
     * Filter which Tags to delete.
     */
    where: TagsWhereUniqueInput
  }

  /**
   * Tags deleteMany
   */
  export type TagsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to delete
     */
    where?: TagsWhereInput
    /**
     * Limit how many Tags to delete.
     */
    limit?: number
  }

  /**
   * Tags.Tickets
   */
  export type Tags$TicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tickets
     */
    select?: TicketsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tickets
     */
    omit?: TicketsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketsInclude<ExtArgs> | null
    where?: TicketsWhereInput
    orderBy?: TicketsOrderByWithRelationInput | TicketsOrderByWithRelationInput[]
    cursor?: TicketsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketsScalarFieldEnum | TicketsScalarFieldEnum[]
  }

  /**
   * Tags without action
   */
  export type TagsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsInclude<ExtArgs> | null
  }


  /**
   * Model SubAccountSidebarOption
   */

  export type AggregateSubAccountSidebarOption = {
    _count: SubAccountSidebarOptionCountAggregateOutputType | null
    _min: SubAccountSidebarOptionMinAggregateOutputType | null
    _max: SubAccountSidebarOptionMaxAggregateOutputType | null
  }

  export type SubAccountSidebarOptionMinAggregateOutputType = {
    id: string | null
    name: string | null
    link: string | null
    icon: $Enums.Icon | null
    createdAt: Date | null
    updatedAt: Date | null
    subAccountId: string | null
    subAccount: string | null
  }

  export type SubAccountSidebarOptionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    link: string | null
    icon: $Enums.Icon | null
    createdAt: Date | null
    updatedAt: Date | null
    subAccountId: string | null
    subAccount: string | null
  }

  export type SubAccountSidebarOptionCountAggregateOutputType = {
    id: number
    name: number
    link: number
    icon: number
    createdAt: number
    updatedAt: number
    subAccountId: number
    subAccount: number
    _all: number
  }


  export type SubAccountSidebarOptionMinAggregateInputType = {
    id?: true
    name?: true
    link?: true
    icon?: true
    createdAt?: true
    updatedAt?: true
    subAccountId?: true
    subAccount?: true
  }

  export type SubAccountSidebarOptionMaxAggregateInputType = {
    id?: true
    name?: true
    link?: true
    icon?: true
    createdAt?: true
    updatedAt?: true
    subAccountId?: true
    subAccount?: true
  }

  export type SubAccountSidebarOptionCountAggregateInputType = {
    id?: true
    name?: true
    link?: true
    icon?: true
    createdAt?: true
    updatedAt?: true
    subAccountId?: true
    subAccount?: true
    _all?: true
  }

  export type SubAccountSidebarOptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubAccountSidebarOption to aggregate.
     */
    where?: SubAccountSidebarOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubAccountSidebarOptions to fetch.
     */
    orderBy?: SubAccountSidebarOptionOrderByWithRelationInput | SubAccountSidebarOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubAccountSidebarOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubAccountSidebarOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubAccountSidebarOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubAccountSidebarOptions
    **/
    _count?: true | SubAccountSidebarOptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubAccountSidebarOptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubAccountSidebarOptionMaxAggregateInputType
  }

  export type GetSubAccountSidebarOptionAggregateType<T extends SubAccountSidebarOptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubAccountSidebarOption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubAccountSidebarOption[P]>
      : GetScalarType<T[P], AggregateSubAccountSidebarOption[P]>
  }




  export type SubAccountSidebarOptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubAccountSidebarOptionWhereInput
    orderBy?: SubAccountSidebarOptionOrderByWithAggregationInput | SubAccountSidebarOptionOrderByWithAggregationInput[]
    by: SubAccountSidebarOptionScalarFieldEnum[] | SubAccountSidebarOptionScalarFieldEnum
    having?: SubAccountSidebarOptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubAccountSidebarOptionCountAggregateInputType | true
    _min?: SubAccountSidebarOptionMinAggregateInputType
    _max?: SubAccountSidebarOptionMaxAggregateInputType
  }

  export type SubAccountSidebarOptionGroupByOutputType = {
    id: string
    name: string
    link: string
    icon: $Enums.Icon
    createdAt: Date
    updatedAt: Date
    subAccountId: string
    subAccount: string | null
    _count: SubAccountSidebarOptionCountAggregateOutputType | null
    _min: SubAccountSidebarOptionMinAggregateOutputType | null
    _max: SubAccountSidebarOptionMaxAggregateOutputType | null
  }

  type GetSubAccountSidebarOptionGroupByPayload<T extends SubAccountSidebarOptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubAccountSidebarOptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubAccountSidebarOptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubAccountSidebarOptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubAccountSidebarOptionGroupByOutputType[P]>
        }
      >
    >


  export type SubAccountSidebarOptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    link?: boolean
    icon?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subAccountId?: boolean
    subAccount?: boolean
    SubAccount?: boolean | SubAccountSidebarOption$SubAccountArgs<ExtArgs>
  }, ExtArgs["result"]["subAccountSidebarOption"]>

  export type SubAccountSidebarOptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    link?: boolean
    icon?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subAccountId?: boolean
    subAccount?: boolean
    SubAccount?: boolean | SubAccountSidebarOption$SubAccountArgs<ExtArgs>
  }, ExtArgs["result"]["subAccountSidebarOption"]>

  export type SubAccountSidebarOptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    link?: boolean
    icon?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subAccountId?: boolean
    subAccount?: boolean
    SubAccount?: boolean | SubAccountSidebarOption$SubAccountArgs<ExtArgs>
  }, ExtArgs["result"]["subAccountSidebarOption"]>

  export type SubAccountSidebarOptionSelectScalar = {
    id?: boolean
    name?: boolean
    link?: boolean
    icon?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subAccountId?: boolean
    subAccount?: boolean
  }

  export type SubAccountSidebarOptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "link" | "icon" | "createdAt" | "updatedAt" | "subAccountId" | "subAccount", ExtArgs["result"]["subAccountSidebarOption"]>
  export type SubAccountSidebarOptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SubAccount?: boolean | SubAccountSidebarOption$SubAccountArgs<ExtArgs>
  }
  export type SubAccountSidebarOptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SubAccount?: boolean | SubAccountSidebarOption$SubAccountArgs<ExtArgs>
  }
  export type SubAccountSidebarOptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SubAccount?: boolean | SubAccountSidebarOption$SubAccountArgs<ExtArgs>
  }

  export type $SubAccountSidebarOptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubAccountSidebarOption"
    objects: {
      SubAccount: Prisma.$SubAccountsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      link: string
      icon: $Enums.Icon
      createdAt: Date
      updatedAt: Date
      subAccountId: string
      subAccount: string | null
    }, ExtArgs["result"]["subAccountSidebarOption"]>
    composites: {}
  }

  type SubAccountSidebarOptionGetPayload<S extends boolean | null | undefined | SubAccountSidebarOptionDefaultArgs> = $Result.GetResult<Prisma.$SubAccountSidebarOptionPayload, S>

  type SubAccountSidebarOptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubAccountSidebarOptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubAccountSidebarOptionCountAggregateInputType | true
    }

  export interface SubAccountSidebarOptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubAccountSidebarOption'], meta: { name: 'SubAccountSidebarOption' } }
    /**
     * Find zero or one SubAccountSidebarOption that matches the filter.
     * @param {SubAccountSidebarOptionFindUniqueArgs} args - Arguments to find a SubAccountSidebarOption
     * @example
     * // Get one SubAccountSidebarOption
     * const subAccountSidebarOption = await prisma.subAccountSidebarOption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubAccountSidebarOptionFindUniqueArgs>(args: SelectSubset<T, SubAccountSidebarOptionFindUniqueArgs<ExtArgs>>): Prisma__SubAccountSidebarOptionClient<$Result.GetResult<Prisma.$SubAccountSidebarOptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SubAccountSidebarOption that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubAccountSidebarOptionFindUniqueOrThrowArgs} args - Arguments to find a SubAccountSidebarOption
     * @example
     * // Get one SubAccountSidebarOption
     * const subAccountSidebarOption = await prisma.subAccountSidebarOption.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubAccountSidebarOptionFindUniqueOrThrowArgs>(args: SelectSubset<T, SubAccountSidebarOptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubAccountSidebarOptionClient<$Result.GetResult<Prisma.$SubAccountSidebarOptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubAccountSidebarOption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubAccountSidebarOptionFindFirstArgs} args - Arguments to find a SubAccountSidebarOption
     * @example
     * // Get one SubAccountSidebarOption
     * const subAccountSidebarOption = await prisma.subAccountSidebarOption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubAccountSidebarOptionFindFirstArgs>(args?: SelectSubset<T, SubAccountSidebarOptionFindFirstArgs<ExtArgs>>): Prisma__SubAccountSidebarOptionClient<$Result.GetResult<Prisma.$SubAccountSidebarOptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubAccountSidebarOption that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubAccountSidebarOptionFindFirstOrThrowArgs} args - Arguments to find a SubAccountSidebarOption
     * @example
     * // Get one SubAccountSidebarOption
     * const subAccountSidebarOption = await prisma.subAccountSidebarOption.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubAccountSidebarOptionFindFirstOrThrowArgs>(args?: SelectSubset<T, SubAccountSidebarOptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubAccountSidebarOptionClient<$Result.GetResult<Prisma.$SubAccountSidebarOptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SubAccountSidebarOptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubAccountSidebarOptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubAccountSidebarOptions
     * const subAccountSidebarOptions = await prisma.subAccountSidebarOption.findMany()
     * 
     * // Get first 10 SubAccountSidebarOptions
     * const subAccountSidebarOptions = await prisma.subAccountSidebarOption.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subAccountSidebarOptionWithIdOnly = await prisma.subAccountSidebarOption.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubAccountSidebarOptionFindManyArgs>(args?: SelectSubset<T, SubAccountSidebarOptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubAccountSidebarOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SubAccountSidebarOption.
     * @param {SubAccountSidebarOptionCreateArgs} args - Arguments to create a SubAccountSidebarOption.
     * @example
     * // Create one SubAccountSidebarOption
     * const SubAccountSidebarOption = await prisma.subAccountSidebarOption.create({
     *   data: {
     *     // ... data to create a SubAccountSidebarOption
     *   }
     * })
     * 
     */
    create<T extends SubAccountSidebarOptionCreateArgs>(args: SelectSubset<T, SubAccountSidebarOptionCreateArgs<ExtArgs>>): Prisma__SubAccountSidebarOptionClient<$Result.GetResult<Prisma.$SubAccountSidebarOptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SubAccountSidebarOptions.
     * @param {SubAccountSidebarOptionCreateManyArgs} args - Arguments to create many SubAccountSidebarOptions.
     * @example
     * // Create many SubAccountSidebarOptions
     * const subAccountSidebarOption = await prisma.subAccountSidebarOption.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubAccountSidebarOptionCreateManyArgs>(args?: SelectSubset<T, SubAccountSidebarOptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SubAccountSidebarOptions and returns the data saved in the database.
     * @param {SubAccountSidebarOptionCreateManyAndReturnArgs} args - Arguments to create many SubAccountSidebarOptions.
     * @example
     * // Create many SubAccountSidebarOptions
     * const subAccountSidebarOption = await prisma.subAccountSidebarOption.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SubAccountSidebarOptions and only return the `id`
     * const subAccountSidebarOptionWithIdOnly = await prisma.subAccountSidebarOption.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubAccountSidebarOptionCreateManyAndReturnArgs>(args?: SelectSubset<T, SubAccountSidebarOptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubAccountSidebarOptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SubAccountSidebarOption.
     * @param {SubAccountSidebarOptionDeleteArgs} args - Arguments to delete one SubAccountSidebarOption.
     * @example
     * // Delete one SubAccountSidebarOption
     * const SubAccountSidebarOption = await prisma.subAccountSidebarOption.delete({
     *   where: {
     *     // ... filter to delete one SubAccountSidebarOption
     *   }
     * })
     * 
     */
    delete<T extends SubAccountSidebarOptionDeleteArgs>(args: SelectSubset<T, SubAccountSidebarOptionDeleteArgs<ExtArgs>>): Prisma__SubAccountSidebarOptionClient<$Result.GetResult<Prisma.$SubAccountSidebarOptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SubAccountSidebarOption.
     * @param {SubAccountSidebarOptionUpdateArgs} args - Arguments to update one SubAccountSidebarOption.
     * @example
     * // Update one SubAccountSidebarOption
     * const subAccountSidebarOption = await prisma.subAccountSidebarOption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubAccountSidebarOptionUpdateArgs>(args: SelectSubset<T, SubAccountSidebarOptionUpdateArgs<ExtArgs>>): Prisma__SubAccountSidebarOptionClient<$Result.GetResult<Prisma.$SubAccountSidebarOptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SubAccountSidebarOptions.
     * @param {SubAccountSidebarOptionDeleteManyArgs} args - Arguments to filter SubAccountSidebarOptions to delete.
     * @example
     * // Delete a few SubAccountSidebarOptions
     * const { count } = await prisma.subAccountSidebarOption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubAccountSidebarOptionDeleteManyArgs>(args?: SelectSubset<T, SubAccountSidebarOptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubAccountSidebarOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubAccountSidebarOptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubAccountSidebarOptions
     * const subAccountSidebarOption = await prisma.subAccountSidebarOption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubAccountSidebarOptionUpdateManyArgs>(args: SelectSubset<T, SubAccountSidebarOptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubAccountSidebarOptions and returns the data updated in the database.
     * @param {SubAccountSidebarOptionUpdateManyAndReturnArgs} args - Arguments to update many SubAccountSidebarOptions.
     * @example
     * // Update many SubAccountSidebarOptions
     * const subAccountSidebarOption = await prisma.subAccountSidebarOption.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SubAccountSidebarOptions and only return the `id`
     * const subAccountSidebarOptionWithIdOnly = await prisma.subAccountSidebarOption.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubAccountSidebarOptionUpdateManyAndReturnArgs>(args: SelectSubset<T, SubAccountSidebarOptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubAccountSidebarOptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SubAccountSidebarOption.
     * @param {SubAccountSidebarOptionUpsertArgs} args - Arguments to update or create a SubAccountSidebarOption.
     * @example
     * // Update or create a SubAccountSidebarOption
     * const subAccountSidebarOption = await prisma.subAccountSidebarOption.upsert({
     *   create: {
     *     // ... data to create a SubAccountSidebarOption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubAccountSidebarOption we want to update
     *   }
     * })
     */
    upsert<T extends SubAccountSidebarOptionUpsertArgs>(args: SelectSubset<T, SubAccountSidebarOptionUpsertArgs<ExtArgs>>): Prisma__SubAccountSidebarOptionClient<$Result.GetResult<Prisma.$SubAccountSidebarOptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SubAccountSidebarOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubAccountSidebarOptionCountArgs} args - Arguments to filter SubAccountSidebarOptions to count.
     * @example
     * // Count the number of SubAccountSidebarOptions
     * const count = await prisma.subAccountSidebarOption.count({
     *   where: {
     *     // ... the filter for the SubAccountSidebarOptions we want to count
     *   }
     * })
    **/
    count<T extends SubAccountSidebarOptionCountArgs>(
      args?: Subset<T, SubAccountSidebarOptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubAccountSidebarOptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubAccountSidebarOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubAccountSidebarOptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubAccountSidebarOptionAggregateArgs>(args: Subset<T, SubAccountSidebarOptionAggregateArgs>): Prisma.PrismaPromise<GetSubAccountSidebarOptionAggregateType<T>>

    /**
     * Group by SubAccountSidebarOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubAccountSidebarOptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubAccountSidebarOptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubAccountSidebarOptionGroupByArgs['orderBy'] }
        : { orderBy?: SubAccountSidebarOptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubAccountSidebarOptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubAccountSidebarOptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubAccountSidebarOption model
   */
  readonly fields: SubAccountSidebarOptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubAccountSidebarOption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubAccountSidebarOptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    SubAccount<T extends SubAccountSidebarOption$SubAccountArgs<ExtArgs> = {}>(args?: Subset<T, SubAccountSidebarOption$SubAccountArgs<ExtArgs>>): Prisma__SubAccountsClient<$Result.GetResult<Prisma.$SubAccountsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubAccountSidebarOption model
   */
  interface SubAccountSidebarOptionFieldRefs {
    readonly id: FieldRef<"SubAccountSidebarOption", 'String'>
    readonly name: FieldRef<"SubAccountSidebarOption", 'String'>
    readonly link: FieldRef<"SubAccountSidebarOption", 'String'>
    readonly icon: FieldRef<"SubAccountSidebarOption", 'Icon'>
    readonly createdAt: FieldRef<"SubAccountSidebarOption", 'DateTime'>
    readonly updatedAt: FieldRef<"SubAccountSidebarOption", 'DateTime'>
    readonly subAccountId: FieldRef<"SubAccountSidebarOption", 'String'>
    readonly subAccount: FieldRef<"SubAccountSidebarOption", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SubAccountSidebarOption findUnique
   */
  export type SubAccountSidebarOptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccountSidebarOption
     */
    select?: SubAccountSidebarOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccountSidebarOption
     */
    omit?: SubAccountSidebarOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountSidebarOptionInclude<ExtArgs> | null
    /**
     * Filter, which SubAccountSidebarOption to fetch.
     */
    where: SubAccountSidebarOptionWhereUniqueInput
  }

  /**
   * SubAccountSidebarOption findUniqueOrThrow
   */
  export type SubAccountSidebarOptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccountSidebarOption
     */
    select?: SubAccountSidebarOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccountSidebarOption
     */
    omit?: SubAccountSidebarOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountSidebarOptionInclude<ExtArgs> | null
    /**
     * Filter, which SubAccountSidebarOption to fetch.
     */
    where: SubAccountSidebarOptionWhereUniqueInput
  }

  /**
   * SubAccountSidebarOption findFirst
   */
  export type SubAccountSidebarOptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccountSidebarOption
     */
    select?: SubAccountSidebarOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccountSidebarOption
     */
    omit?: SubAccountSidebarOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountSidebarOptionInclude<ExtArgs> | null
    /**
     * Filter, which SubAccountSidebarOption to fetch.
     */
    where?: SubAccountSidebarOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubAccountSidebarOptions to fetch.
     */
    orderBy?: SubAccountSidebarOptionOrderByWithRelationInput | SubAccountSidebarOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubAccountSidebarOptions.
     */
    cursor?: SubAccountSidebarOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubAccountSidebarOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubAccountSidebarOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubAccountSidebarOptions.
     */
    distinct?: SubAccountSidebarOptionScalarFieldEnum | SubAccountSidebarOptionScalarFieldEnum[]
  }

  /**
   * SubAccountSidebarOption findFirstOrThrow
   */
  export type SubAccountSidebarOptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccountSidebarOption
     */
    select?: SubAccountSidebarOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccountSidebarOption
     */
    omit?: SubAccountSidebarOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountSidebarOptionInclude<ExtArgs> | null
    /**
     * Filter, which SubAccountSidebarOption to fetch.
     */
    where?: SubAccountSidebarOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubAccountSidebarOptions to fetch.
     */
    orderBy?: SubAccountSidebarOptionOrderByWithRelationInput | SubAccountSidebarOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubAccountSidebarOptions.
     */
    cursor?: SubAccountSidebarOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubAccountSidebarOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubAccountSidebarOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubAccountSidebarOptions.
     */
    distinct?: SubAccountSidebarOptionScalarFieldEnum | SubAccountSidebarOptionScalarFieldEnum[]
  }

  /**
   * SubAccountSidebarOption findMany
   */
  export type SubAccountSidebarOptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccountSidebarOption
     */
    select?: SubAccountSidebarOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccountSidebarOption
     */
    omit?: SubAccountSidebarOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountSidebarOptionInclude<ExtArgs> | null
    /**
     * Filter, which SubAccountSidebarOptions to fetch.
     */
    where?: SubAccountSidebarOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubAccountSidebarOptions to fetch.
     */
    orderBy?: SubAccountSidebarOptionOrderByWithRelationInput | SubAccountSidebarOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubAccountSidebarOptions.
     */
    cursor?: SubAccountSidebarOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubAccountSidebarOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubAccountSidebarOptions.
     */
    skip?: number
    distinct?: SubAccountSidebarOptionScalarFieldEnum | SubAccountSidebarOptionScalarFieldEnum[]
  }

  /**
   * SubAccountSidebarOption create
   */
  export type SubAccountSidebarOptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccountSidebarOption
     */
    select?: SubAccountSidebarOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccountSidebarOption
     */
    omit?: SubAccountSidebarOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountSidebarOptionInclude<ExtArgs> | null
    /**
     * The data needed to create a SubAccountSidebarOption.
     */
    data: XOR<SubAccountSidebarOptionCreateInput, SubAccountSidebarOptionUncheckedCreateInput>
  }

  /**
   * SubAccountSidebarOption createMany
   */
  export type SubAccountSidebarOptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubAccountSidebarOptions.
     */
    data: SubAccountSidebarOptionCreateManyInput | SubAccountSidebarOptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubAccountSidebarOption createManyAndReturn
   */
  export type SubAccountSidebarOptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccountSidebarOption
     */
    select?: SubAccountSidebarOptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccountSidebarOption
     */
    omit?: SubAccountSidebarOptionOmit<ExtArgs> | null
    /**
     * The data used to create many SubAccountSidebarOptions.
     */
    data: SubAccountSidebarOptionCreateManyInput | SubAccountSidebarOptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountSidebarOptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubAccountSidebarOption update
   */
  export type SubAccountSidebarOptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccountSidebarOption
     */
    select?: SubAccountSidebarOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccountSidebarOption
     */
    omit?: SubAccountSidebarOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountSidebarOptionInclude<ExtArgs> | null
    /**
     * The data needed to update a SubAccountSidebarOption.
     */
    data: XOR<SubAccountSidebarOptionUpdateInput, SubAccountSidebarOptionUncheckedUpdateInput>
    /**
     * Choose, which SubAccountSidebarOption to update.
     */
    where: SubAccountSidebarOptionWhereUniqueInput
  }

  /**
   * SubAccountSidebarOption updateMany
   */
  export type SubAccountSidebarOptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubAccountSidebarOptions.
     */
    data: XOR<SubAccountSidebarOptionUpdateManyMutationInput, SubAccountSidebarOptionUncheckedUpdateManyInput>
    /**
     * Filter which SubAccountSidebarOptions to update
     */
    where?: SubAccountSidebarOptionWhereInput
    /**
     * Limit how many SubAccountSidebarOptions to update.
     */
    limit?: number
  }

  /**
   * SubAccountSidebarOption updateManyAndReturn
   */
  export type SubAccountSidebarOptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccountSidebarOption
     */
    select?: SubAccountSidebarOptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccountSidebarOption
     */
    omit?: SubAccountSidebarOptionOmit<ExtArgs> | null
    /**
     * The data used to update SubAccountSidebarOptions.
     */
    data: XOR<SubAccountSidebarOptionUpdateManyMutationInput, SubAccountSidebarOptionUncheckedUpdateManyInput>
    /**
     * Filter which SubAccountSidebarOptions to update
     */
    where?: SubAccountSidebarOptionWhereInput
    /**
     * Limit how many SubAccountSidebarOptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountSidebarOptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubAccountSidebarOption upsert
   */
  export type SubAccountSidebarOptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccountSidebarOption
     */
    select?: SubAccountSidebarOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccountSidebarOption
     */
    omit?: SubAccountSidebarOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountSidebarOptionInclude<ExtArgs> | null
    /**
     * The filter to search for the SubAccountSidebarOption to update in case it exists.
     */
    where: SubAccountSidebarOptionWhereUniqueInput
    /**
     * In case the SubAccountSidebarOption found by the `where` argument doesn't exist, create a new SubAccountSidebarOption with this data.
     */
    create: XOR<SubAccountSidebarOptionCreateInput, SubAccountSidebarOptionUncheckedCreateInput>
    /**
     * In case the SubAccountSidebarOption was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubAccountSidebarOptionUpdateInput, SubAccountSidebarOptionUncheckedUpdateInput>
  }

  /**
   * SubAccountSidebarOption delete
   */
  export type SubAccountSidebarOptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccountSidebarOption
     */
    select?: SubAccountSidebarOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccountSidebarOption
     */
    omit?: SubAccountSidebarOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountSidebarOptionInclude<ExtArgs> | null
    /**
     * Filter which SubAccountSidebarOption to delete.
     */
    where: SubAccountSidebarOptionWhereUniqueInput
  }

  /**
   * SubAccountSidebarOption deleteMany
   */
  export type SubAccountSidebarOptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubAccountSidebarOptions to delete
     */
    where?: SubAccountSidebarOptionWhereInput
    /**
     * Limit how many SubAccountSidebarOptions to delete.
     */
    limit?: number
  }

  /**
   * SubAccountSidebarOption.SubAccount
   */
  export type SubAccountSidebarOption$SubAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccounts
     */
    select?: SubAccountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccounts
     */
    omit?: SubAccountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountsInclude<ExtArgs> | null
    where?: SubAccountsWhereInput
  }

  /**
   * SubAccountSidebarOption without action
   */
  export type SubAccountSidebarOptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccountSidebarOption
     */
    select?: SubAccountSidebarOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccountSidebarOption
     */
    omit?: SubAccountSidebarOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountSidebarOptionInclude<ExtArgs> | null
  }


  /**
   * Model Invitations
   */

  export type AggregateInvitations = {
    _count: InvitationsCountAggregateOutputType | null
    _min: InvitationsMinAggregateOutputType | null
    _max: InvitationsMaxAggregateOutputType | null
  }

  export type InvitationsMinAggregateOutputType = {
    id: string | null
    email: string | null
    agencyId: string | null
    status: $Enums.InvitationStatus | null
    role: $Enums.Role | null
  }

  export type InvitationsMaxAggregateOutputType = {
    id: string | null
    email: string | null
    agencyId: string | null
    status: $Enums.InvitationStatus | null
    role: $Enums.Role | null
  }

  export type InvitationsCountAggregateOutputType = {
    id: number
    email: number
    agencyId: number
    status: number
    role: number
    _all: number
  }


  export type InvitationsMinAggregateInputType = {
    id?: true
    email?: true
    agencyId?: true
    status?: true
    role?: true
  }

  export type InvitationsMaxAggregateInputType = {
    id?: true
    email?: true
    agencyId?: true
    status?: true
    role?: true
  }

  export type InvitationsCountAggregateInputType = {
    id?: true
    email?: true
    agencyId?: true
    status?: true
    role?: true
    _all?: true
  }

  export type InvitationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invitations to aggregate.
     */
    where?: InvitationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invitations to fetch.
     */
    orderBy?: InvitationsOrderByWithRelationInput | InvitationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvitationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invitations
    **/
    _count?: true | InvitationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvitationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvitationsMaxAggregateInputType
  }

  export type GetInvitationsAggregateType<T extends InvitationsAggregateArgs> = {
        [P in keyof T & keyof AggregateInvitations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvitations[P]>
      : GetScalarType<T[P], AggregateInvitations[P]>
  }




  export type InvitationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvitationsWhereInput
    orderBy?: InvitationsOrderByWithAggregationInput | InvitationsOrderByWithAggregationInput[]
    by: InvitationsScalarFieldEnum[] | InvitationsScalarFieldEnum
    having?: InvitationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvitationsCountAggregateInputType | true
    _min?: InvitationsMinAggregateInputType
    _max?: InvitationsMaxAggregateInputType
  }

  export type InvitationsGroupByOutputType = {
    id: string
    email: string
    agencyId: string
    status: $Enums.InvitationStatus
    role: $Enums.Role
    _count: InvitationsCountAggregateOutputType | null
    _min: InvitationsMinAggregateOutputType | null
    _max: InvitationsMaxAggregateOutputType | null
  }

  type GetInvitationsGroupByPayload<T extends InvitationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvitationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvitationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvitationsGroupByOutputType[P]>
            : GetScalarType<T[P], InvitationsGroupByOutputType[P]>
        }
      >
    >


  export type InvitationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    agencyId?: boolean
    status?: boolean
    role?: boolean
    Agency?: boolean | AgencyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invitations"]>

  export type InvitationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    agencyId?: boolean
    status?: boolean
    role?: boolean
    Agency?: boolean | AgencyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invitations"]>

  export type InvitationsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    agencyId?: boolean
    status?: boolean
    role?: boolean
    Agency?: boolean | AgencyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invitations"]>

  export type InvitationsSelectScalar = {
    id?: boolean
    email?: boolean
    agencyId?: boolean
    status?: boolean
    role?: boolean
  }

  export type InvitationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "agencyId" | "status" | "role", ExtArgs["result"]["invitations"]>
  export type InvitationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Agency?: boolean | AgencyDefaultArgs<ExtArgs>
  }
  export type InvitationsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Agency?: boolean | AgencyDefaultArgs<ExtArgs>
  }
  export type InvitationsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Agency?: boolean | AgencyDefaultArgs<ExtArgs>
  }

  export type $InvitationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invitations"
    objects: {
      Agency: Prisma.$AgencyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      agencyId: string
      status: $Enums.InvitationStatus
      role: $Enums.Role
    }, ExtArgs["result"]["invitations"]>
    composites: {}
  }

  type InvitationsGetPayload<S extends boolean | null | undefined | InvitationsDefaultArgs> = $Result.GetResult<Prisma.$InvitationsPayload, S>

  type InvitationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvitationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvitationsCountAggregateInputType | true
    }

  export interface InvitationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invitations'], meta: { name: 'Invitations' } }
    /**
     * Find zero or one Invitations that matches the filter.
     * @param {InvitationsFindUniqueArgs} args - Arguments to find a Invitations
     * @example
     * // Get one Invitations
     * const invitations = await prisma.invitations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvitationsFindUniqueArgs>(args: SelectSubset<T, InvitationsFindUniqueArgs<ExtArgs>>): Prisma__InvitationsClient<$Result.GetResult<Prisma.$InvitationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invitations that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvitationsFindUniqueOrThrowArgs} args - Arguments to find a Invitations
     * @example
     * // Get one Invitations
     * const invitations = await prisma.invitations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvitationsFindUniqueOrThrowArgs>(args: SelectSubset<T, InvitationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvitationsClient<$Result.GetResult<Prisma.$InvitationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invitations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationsFindFirstArgs} args - Arguments to find a Invitations
     * @example
     * // Get one Invitations
     * const invitations = await prisma.invitations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvitationsFindFirstArgs>(args?: SelectSubset<T, InvitationsFindFirstArgs<ExtArgs>>): Prisma__InvitationsClient<$Result.GetResult<Prisma.$InvitationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invitations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationsFindFirstOrThrowArgs} args - Arguments to find a Invitations
     * @example
     * // Get one Invitations
     * const invitations = await prisma.invitations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvitationsFindFirstOrThrowArgs>(args?: SelectSubset<T, InvitationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvitationsClient<$Result.GetResult<Prisma.$InvitationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invitations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invitations
     * const invitations = await prisma.invitations.findMany()
     * 
     * // Get first 10 Invitations
     * const invitations = await prisma.invitations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invitationsWithIdOnly = await prisma.invitations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvitationsFindManyArgs>(args?: SelectSubset<T, InvitationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invitations.
     * @param {InvitationsCreateArgs} args - Arguments to create a Invitations.
     * @example
     * // Create one Invitations
     * const Invitations = await prisma.invitations.create({
     *   data: {
     *     // ... data to create a Invitations
     *   }
     * })
     * 
     */
    create<T extends InvitationsCreateArgs>(args: SelectSubset<T, InvitationsCreateArgs<ExtArgs>>): Prisma__InvitationsClient<$Result.GetResult<Prisma.$InvitationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invitations.
     * @param {InvitationsCreateManyArgs} args - Arguments to create many Invitations.
     * @example
     * // Create many Invitations
     * const invitations = await prisma.invitations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvitationsCreateManyArgs>(args?: SelectSubset<T, InvitationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invitations and returns the data saved in the database.
     * @param {InvitationsCreateManyAndReturnArgs} args - Arguments to create many Invitations.
     * @example
     * // Create many Invitations
     * const invitations = await prisma.invitations.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invitations and only return the `id`
     * const invitationsWithIdOnly = await prisma.invitations.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvitationsCreateManyAndReturnArgs>(args?: SelectSubset<T, InvitationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Invitations.
     * @param {InvitationsDeleteArgs} args - Arguments to delete one Invitations.
     * @example
     * // Delete one Invitations
     * const Invitations = await prisma.invitations.delete({
     *   where: {
     *     // ... filter to delete one Invitations
     *   }
     * })
     * 
     */
    delete<T extends InvitationsDeleteArgs>(args: SelectSubset<T, InvitationsDeleteArgs<ExtArgs>>): Prisma__InvitationsClient<$Result.GetResult<Prisma.$InvitationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invitations.
     * @param {InvitationsUpdateArgs} args - Arguments to update one Invitations.
     * @example
     * // Update one Invitations
     * const invitations = await prisma.invitations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvitationsUpdateArgs>(args: SelectSubset<T, InvitationsUpdateArgs<ExtArgs>>): Prisma__InvitationsClient<$Result.GetResult<Prisma.$InvitationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invitations.
     * @param {InvitationsDeleteManyArgs} args - Arguments to filter Invitations to delete.
     * @example
     * // Delete a few Invitations
     * const { count } = await prisma.invitations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvitationsDeleteManyArgs>(args?: SelectSubset<T, InvitationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invitations
     * const invitations = await prisma.invitations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvitationsUpdateManyArgs>(args: SelectSubset<T, InvitationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invitations and returns the data updated in the database.
     * @param {InvitationsUpdateManyAndReturnArgs} args - Arguments to update many Invitations.
     * @example
     * // Update many Invitations
     * const invitations = await prisma.invitations.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Invitations and only return the `id`
     * const invitationsWithIdOnly = await prisma.invitations.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvitationsUpdateManyAndReturnArgs>(args: SelectSubset<T, InvitationsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Invitations.
     * @param {InvitationsUpsertArgs} args - Arguments to update or create a Invitations.
     * @example
     * // Update or create a Invitations
     * const invitations = await prisma.invitations.upsert({
     *   create: {
     *     // ... data to create a Invitations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invitations we want to update
     *   }
     * })
     */
    upsert<T extends InvitationsUpsertArgs>(args: SelectSubset<T, InvitationsUpsertArgs<ExtArgs>>): Prisma__InvitationsClient<$Result.GetResult<Prisma.$InvitationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationsCountArgs} args - Arguments to filter Invitations to count.
     * @example
     * // Count the number of Invitations
     * const count = await prisma.invitations.count({
     *   where: {
     *     // ... the filter for the Invitations we want to count
     *   }
     * })
    **/
    count<T extends InvitationsCountArgs>(
      args?: Subset<T, InvitationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvitationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvitationsAggregateArgs>(args: Subset<T, InvitationsAggregateArgs>): Prisma.PrismaPromise<GetInvitationsAggregateType<T>>

    /**
     * Group by Invitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvitationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvitationsGroupByArgs['orderBy'] }
        : { orderBy?: InvitationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvitationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvitationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invitations model
   */
  readonly fields: InvitationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invitations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvitationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Agency<T extends AgencyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgencyDefaultArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invitations model
   */
  interface InvitationsFieldRefs {
    readonly id: FieldRef<"Invitations", 'String'>
    readonly email: FieldRef<"Invitations", 'String'>
    readonly agencyId: FieldRef<"Invitations", 'String'>
    readonly status: FieldRef<"Invitations", 'InvitationStatus'>
    readonly role: FieldRef<"Invitations", 'Role'>
  }
    

  // Custom InputTypes
  /**
   * Invitations findUnique
   */
  export type InvitationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitations
     */
    select?: InvitationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitations
     */
    omit?: InvitationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationsInclude<ExtArgs> | null
    /**
     * Filter, which Invitations to fetch.
     */
    where: InvitationsWhereUniqueInput
  }

  /**
   * Invitations findUniqueOrThrow
   */
  export type InvitationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitations
     */
    select?: InvitationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitations
     */
    omit?: InvitationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationsInclude<ExtArgs> | null
    /**
     * Filter, which Invitations to fetch.
     */
    where: InvitationsWhereUniqueInput
  }

  /**
   * Invitations findFirst
   */
  export type InvitationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitations
     */
    select?: InvitationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitations
     */
    omit?: InvitationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationsInclude<ExtArgs> | null
    /**
     * Filter, which Invitations to fetch.
     */
    where?: InvitationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invitations to fetch.
     */
    orderBy?: InvitationsOrderByWithRelationInput | InvitationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invitations.
     */
    cursor?: InvitationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invitations.
     */
    distinct?: InvitationsScalarFieldEnum | InvitationsScalarFieldEnum[]
  }

  /**
   * Invitations findFirstOrThrow
   */
  export type InvitationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitations
     */
    select?: InvitationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitations
     */
    omit?: InvitationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationsInclude<ExtArgs> | null
    /**
     * Filter, which Invitations to fetch.
     */
    where?: InvitationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invitations to fetch.
     */
    orderBy?: InvitationsOrderByWithRelationInput | InvitationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invitations.
     */
    cursor?: InvitationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invitations.
     */
    distinct?: InvitationsScalarFieldEnum | InvitationsScalarFieldEnum[]
  }

  /**
   * Invitations findMany
   */
  export type InvitationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitations
     */
    select?: InvitationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitations
     */
    omit?: InvitationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationsInclude<ExtArgs> | null
    /**
     * Filter, which Invitations to fetch.
     */
    where?: InvitationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invitations to fetch.
     */
    orderBy?: InvitationsOrderByWithRelationInput | InvitationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invitations.
     */
    cursor?: InvitationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invitations.
     */
    skip?: number
    distinct?: InvitationsScalarFieldEnum | InvitationsScalarFieldEnum[]
  }

  /**
   * Invitations create
   */
  export type InvitationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitations
     */
    select?: InvitationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitations
     */
    omit?: InvitationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationsInclude<ExtArgs> | null
    /**
     * The data needed to create a Invitations.
     */
    data: XOR<InvitationsCreateInput, InvitationsUncheckedCreateInput>
  }

  /**
   * Invitations createMany
   */
  export type InvitationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invitations.
     */
    data: InvitationsCreateManyInput | InvitationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invitations createManyAndReturn
   */
  export type InvitationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitations
     */
    select?: InvitationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invitations
     */
    omit?: InvitationsOmit<ExtArgs> | null
    /**
     * The data used to create many Invitations.
     */
    data: InvitationsCreateManyInput | InvitationsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invitations update
   */
  export type InvitationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitations
     */
    select?: InvitationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitations
     */
    omit?: InvitationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationsInclude<ExtArgs> | null
    /**
     * The data needed to update a Invitations.
     */
    data: XOR<InvitationsUpdateInput, InvitationsUncheckedUpdateInput>
    /**
     * Choose, which Invitations to update.
     */
    where: InvitationsWhereUniqueInput
  }

  /**
   * Invitations updateMany
   */
  export type InvitationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invitations.
     */
    data: XOR<InvitationsUpdateManyMutationInput, InvitationsUncheckedUpdateManyInput>
    /**
     * Filter which Invitations to update
     */
    where?: InvitationsWhereInput
    /**
     * Limit how many Invitations to update.
     */
    limit?: number
  }

  /**
   * Invitations updateManyAndReturn
   */
  export type InvitationsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitations
     */
    select?: InvitationsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invitations
     */
    omit?: InvitationsOmit<ExtArgs> | null
    /**
     * The data used to update Invitations.
     */
    data: XOR<InvitationsUpdateManyMutationInput, InvitationsUncheckedUpdateManyInput>
    /**
     * Filter which Invitations to update
     */
    where?: InvitationsWhereInput
    /**
     * Limit how many Invitations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invitations upsert
   */
  export type InvitationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitations
     */
    select?: InvitationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitations
     */
    omit?: InvitationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationsInclude<ExtArgs> | null
    /**
     * The filter to search for the Invitations to update in case it exists.
     */
    where: InvitationsWhereUniqueInput
    /**
     * In case the Invitations found by the `where` argument doesn't exist, create a new Invitations with this data.
     */
    create: XOR<InvitationsCreateInput, InvitationsUncheckedCreateInput>
    /**
     * In case the Invitations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvitationsUpdateInput, InvitationsUncheckedUpdateInput>
  }

  /**
   * Invitations delete
   */
  export type InvitationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitations
     */
    select?: InvitationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitations
     */
    omit?: InvitationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationsInclude<ExtArgs> | null
    /**
     * Filter which Invitations to delete.
     */
    where: InvitationsWhereUniqueInput
  }

  /**
   * Invitations deleteMany
   */
  export type InvitationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invitations to delete
     */
    where?: InvitationsWhereInput
    /**
     * Limit how many Invitations to delete.
     */
    limit?: number
  }

  /**
   * Invitations without action
   */
  export type InvitationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitations
     */
    select?: InvitationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitations
     */
    omit?: InvitationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationsInclude<ExtArgs> | null
  }


  /**
   * Model Funnels
   */

  export type AggregateFunnels = {
    _count: FunnelsCountAggregateOutputType | null
    _min: FunnelsMinAggregateOutputType | null
    _max: FunnelsMaxAggregateOutputType | null
  }

  export type FunnelsMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    description: string | null
    published: boolean | null
    subDomainName: string | null
    favicon: string | null
    subAccountId: string | null
    liveProducts: string | null
  }

  export type FunnelsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    description: string | null
    published: boolean | null
    subDomainName: string | null
    favicon: string | null
    subAccountId: string | null
    liveProducts: string | null
  }

  export type FunnelsCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    description: number
    published: number
    subDomainName: number
    favicon: number
    subAccountId: number
    liveProducts: number
    _all: number
  }


  export type FunnelsMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    description?: true
    published?: true
    subDomainName?: true
    favicon?: true
    subAccountId?: true
    liveProducts?: true
  }

  export type FunnelsMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    description?: true
    published?: true
    subDomainName?: true
    favicon?: true
    subAccountId?: true
    liveProducts?: true
  }

  export type FunnelsCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    description?: true
    published?: true
    subDomainName?: true
    favicon?: true
    subAccountId?: true
    liveProducts?: true
    _all?: true
  }

  export type FunnelsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Funnels to aggregate.
     */
    where?: FunnelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Funnels to fetch.
     */
    orderBy?: FunnelsOrderByWithRelationInput | FunnelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FunnelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Funnels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Funnels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Funnels
    **/
    _count?: true | FunnelsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FunnelsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FunnelsMaxAggregateInputType
  }

  export type GetFunnelsAggregateType<T extends FunnelsAggregateArgs> = {
        [P in keyof T & keyof AggregateFunnels]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFunnels[P]>
      : GetScalarType<T[P], AggregateFunnels[P]>
  }




  export type FunnelsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FunnelsWhereInput
    orderBy?: FunnelsOrderByWithAggregationInput | FunnelsOrderByWithAggregationInput[]
    by: FunnelsScalarFieldEnum[] | FunnelsScalarFieldEnum
    having?: FunnelsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FunnelsCountAggregateInputType | true
    _min?: FunnelsMinAggregateInputType
    _max?: FunnelsMaxAggregateInputType
  }

  export type FunnelsGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    updatedAt: Date
    description: string | null
    published: boolean
    subDomainName: string | null
    favicon: string | null
    subAccountId: string
    liveProducts: string | null
    _count: FunnelsCountAggregateOutputType | null
    _min: FunnelsMinAggregateOutputType | null
    _max: FunnelsMaxAggregateOutputType | null
  }

  type GetFunnelsGroupByPayload<T extends FunnelsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FunnelsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FunnelsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FunnelsGroupByOutputType[P]>
            : GetScalarType<T[P], FunnelsGroupByOutputType[P]>
        }
      >
    >


  export type FunnelsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    description?: boolean
    published?: boolean
    subDomainName?: boolean
    favicon?: boolean
    subAccountId?: boolean
    liveProducts?: boolean
    SubAccount?: boolean | SubAccountsDefaultArgs<ExtArgs>
    FunelPages?: boolean | Funnels$FunelPagesArgs<ExtArgs>
    className?: boolean | Funnels$classNameArgs<ExtArgs>
    _count?: boolean | FunnelsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["funnels"]>

  export type FunnelsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    description?: boolean
    published?: boolean
    subDomainName?: boolean
    favicon?: boolean
    subAccountId?: boolean
    liveProducts?: boolean
    SubAccount?: boolean | SubAccountsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["funnels"]>

  export type FunnelsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    description?: boolean
    published?: boolean
    subDomainName?: boolean
    favicon?: boolean
    subAccountId?: boolean
    liveProducts?: boolean
    SubAccount?: boolean | SubAccountsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["funnels"]>

  export type FunnelsSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    description?: boolean
    published?: boolean
    subDomainName?: boolean
    favicon?: boolean
    subAccountId?: boolean
    liveProducts?: boolean
  }

  export type FunnelsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "updatedAt" | "description" | "published" | "subDomainName" | "favicon" | "subAccountId" | "liveProducts", ExtArgs["result"]["funnels"]>
  export type FunnelsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SubAccount?: boolean | SubAccountsDefaultArgs<ExtArgs>
    FunelPages?: boolean | Funnels$FunelPagesArgs<ExtArgs>
    className?: boolean | Funnels$classNameArgs<ExtArgs>
    _count?: boolean | FunnelsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FunnelsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SubAccount?: boolean | SubAccountsDefaultArgs<ExtArgs>
  }
  export type FunnelsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SubAccount?: boolean | SubAccountsDefaultArgs<ExtArgs>
  }

  export type $FunnelsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Funnels"
    objects: {
      SubAccount: Prisma.$SubAccountsPayload<ExtArgs>
      FunelPages: Prisma.$FunelPagesPayload<ExtArgs>[]
      className: Prisma.$ClassNamePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
      updatedAt: Date
      description: string | null
      published: boolean
      subDomainName: string | null
      favicon: string | null
      subAccountId: string
      liveProducts: string | null
    }, ExtArgs["result"]["funnels"]>
    composites: {}
  }

  type FunnelsGetPayload<S extends boolean | null | undefined | FunnelsDefaultArgs> = $Result.GetResult<Prisma.$FunnelsPayload, S>

  type FunnelsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FunnelsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FunnelsCountAggregateInputType | true
    }

  export interface FunnelsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Funnels'], meta: { name: 'Funnels' } }
    /**
     * Find zero or one Funnels that matches the filter.
     * @param {FunnelsFindUniqueArgs} args - Arguments to find a Funnels
     * @example
     * // Get one Funnels
     * const funnels = await prisma.funnels.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FunnelsFindUniqueArgs>(args: SelectSubset<T, FunnelsFindUniqueArgs<ExtArgs>>): Prisma__FunnelsClient<$Result.GetResult<Prisma.$FunnelsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Funnels that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FunnelsFindUniqueOrThrowArgs} args - Arguments to find a Funnels
     * @example
     * // Get one Funnels
     * const funnels = await prisma.funnels.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FunnelsFindUniqueOrThrowArgs>(args: SelectSubset<T, FunnelsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FunnelsClient<$Result.GetResult<Prisma.$FunnelsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Funnels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunnelsFindFirstArgs} args - Arguments to find a Funnels
     * @example
     * // Get one Funnels
     * const funnels = await prisma.funnels.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FunnelsFindFirstArgs>(args?: SelectSubset<T, FunnelsFindFirstArgs<ExtArgs>>): Prisma__FunnelsClient<$Result.GetResult<Prisma.$FunnelsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Funnels that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunnelsFindFirstOrThrowArgs} args - Arguments to find a Funnels
     * @example
     * // Get one Funnels
     * const funnels = await prisma.funnels.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FunnelsFindFirstOrThrowArgs>(args?: SelectSubset<T, FunnelsFindFirstOrThrowArgs<ExtArgs>>): Prisma__FunnelsClient<$Result.GetResult<Prisma.$FunnelsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Funnels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunnelsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Funnels
     * const funnels = await prisma.funnels.findMany()
     * 
     * // Get first 10 Funnels
     * const funnels = await prisma.funnels.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const funnelsWithIdOnly = await prisma.funnels.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FunnelsFindManyArgs>(args?: SelectSubset<T, FunnelsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FunnelsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Funnels.
     * @param {FunnelsCreateArgs} args - Arguments to create a Funnels.
     * @example
     * // Create one Funnels
     * const Funnels = await prisma.funnels.create({
     *   data: {
     *     // ... data to create a Funnels
     *   }
     * })
     * 
     */
    create<T extends FunnelsCreateArgs>(args: SelectSubset<T, FunnelsCreateArgs<ExtArgs>>): Prisma__FunnelsClient<$Result.GetResult<Prisma.$FunnelsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Funnels.
     * @param {FunnelsCreateManyArgs} args - Arguments to create many Funnels.
     * @example
     * // Create many Funnels
     * const funnels = await prisma.funnels.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FunnelsCreateManyArgs>(args?: SelectSubset<T, FunnelsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Funnels and returns the data saved in the database.
     * @param {FunnelsCreateManyAndReturnArgs} args - Arguments to create many Funnels.
     * @example
     * // Create many Funnels
     * const funnels = await prisma.funnels.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Funnels and only return the `id`
     * const funnelsWithIdOnly = await prisma.funnels.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FunnelsCreateManyAndReturnArgs>(args?: SelectSubset<T, FunnelsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FunnelsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Funnels.
     * @param {FunnelsDeleteArgs} args - Arguments to delete one Funnels.
     * @example
     * // Delete one Funnels
     * const Funnels = await prisma.funnels.delete({
     *   where: {
     *     // ... filter to delete one Funnels
     *   }
     * })
     * 
     */
    delete<T extends FunnelsDeleteArgs>(args: SelectSubset<T, FunnelsDeleteArgs<ExtArgs>>): Prisma__FunnelsClient<$Result.GetResult<Prisma.$FunnelsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Funnels.
     * @param {FunnelsUpdateArgs} args - Arguments to update one Funnels.
     * @example
     * // Update one Funnels
     * const funnels = await prisma.funnels.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FunnelsUpdateArgs>(args: SelectSubset<T, FunnelsUpdateArgs<ExtArgs>>): Prisma__FunnelsClient<$Result.GetResult<Prisma.$FunnelsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Funnels.
     * @param {FunnelsDeleteManyArgs} args - Arguments to filter Funnels to delete.
     * @example
     * // Delete a few Funnels
     * const { count } = await prisma.funnels.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FunnelsDeleteManyArgs>(args?: SelectSubset<T, FunnelsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Funnels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunnelsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Funnels
     * const funnels = await prisma.funnels.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FunnelsUpdateManyArgs>(args: SelectSubset<T, FunnelsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Funnels and returns the data updated in the database.
     * @param {FunnelsUpdateManyAndReturnArgs} args - Arguments to update many Funnels.
     * @example
     * // Update many Funnels
     * const funnels = await prisma.funnels.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Funnels and only return the `id`
     * const funnelsWithIdOnly = await prisma.funnels.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FunnelsUpdateManyAndReturnArgs>(args: SelectSubset<T, FunnelsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FunnelsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Funnels.
     * @param {FunnelsUpsertArgs} args - Arguments to update or create a Funnels.
     * @example
     * // Update or create a Funnels
     * const funnels = await prisma.funnels.upsert({
     *   create: {
     *     // ... data to create a Funnels
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Funnels we want to update
     *   }
     * })
     */
    upsert<T extends FunnelsUpsertArgs>(args: SelectSubset<T, FunnelsUpsertArgs<ExtArgs>>): Prisma__FunnelsClient<$Result.GetResult<Prisma.$FunnelsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Funnels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunnelsCountArgs} args - Arguments to filter Funnels to count.
     * @example
     * // Count the number of Funnels
     * const count = await prisma.funnels.count({
     *   where: {
     *     // ... the filter for the Funnels we want to count
     *   }
     * })
    **/
    count<T extends FunnelsCountArgs>(
      args?: Subset<T, FunnelsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FunnelsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Funnels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunnelsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FunnelsAggregateArgs>(args: Subset<T, FunnelsAggregateArgs>): Prisma.PrismaPromise<GetFunnelsAggregateType<T>>

    /**
     * Group by Funnels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunnelsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FunnelsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FunnelsGroupByArgs['orderBy'] }
        : { orderBy?: FunnelsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FunnelsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFunnelsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Funnels model
   */
  readonly fields: FunnelsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Funnels.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FunnelsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    SubAccount<T extends SubAccountsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubAccountsDefaultArgs<ExtArgs>>): Prisma__SubAccountsClient<$Result.GetResult<Prisma.$SubAccountsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    FunelPages<T extends Funnels$FunelPagesArgs<ExtArgs> = {}>(args?: Subset<T, Funnels$FunelPagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FunelPagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    className<T extends Funnels$classNameArgs<ExtArgs> = {}>(args?: Subset<T, Funnels$classNameArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassNamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Funnels model
   */
  interface FunnelsFieldRefs {
    readonly id: FieldRef<"Funnels", 'String'>
    readonly name: FieldRef<"Funnels", 'String'>
    readonly createdAt: FieldRef<"Funnels", 'DateTime'>
    readonly updatedAt: FieldRef<"Funnels", 'DateTime'>
    readonly description: FieldRef<"Funnels", 'String'>
    readonly published: FieldRef<"Funnels", 'Boolean'>
    readonly subDomainName: FieldRef<"Funnels", 'String'>
    readonly favicon: FieldRef<"Funnels", 'String'>
    readonly subAccountId: FieldRef<"Funnels", 'String'>
    readonly liveProducts: FieldRef<"Funnels", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Funnels findUnique
   */
  export type FunnelsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Funnels
     */
    select?: FunnelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Funnels
     */
    omit?: FunnelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelsInclude<ExtArgs> | null
    /**
     * Filter, which Funnels to fetch.
     */
    where: FunnelsWhereUniqueInput
  }

  /**
   * Funnels findUniqueOrThrow
   */
  export type FunnelsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Funnels
     */
    select?: FunnelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Funnels
     */
    omit?: FunnelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelsInclude<ExtArgs> | null
    /**
     * Filter, which Funnels to fetch.
     */
    where: FunnelsWhereUniqueInput
  }

  /**
   * Funnels findFirst
   */
  export type FunnelsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Funnels
     */
    select?: FunnelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Funnels
     */
    omit?: FunnelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelsInclude<ExtArgs> | null
    /**
     * Filter, which Funnels to fetch.
     */
    where?: FunnelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Funnels to fetch.
     */
    orderBy?: FunnelsOrderByWithRelationInput | FunnelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Funnels.
     */
    cursor?: FunnelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Funnels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Funnels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Funnels.
     */
    distinct?: FunnelsScalarFieldEnum | FunnelsScalarFieldEnum[]
  }

  /**
   * Funnels findFirstOrThrow
   */
  export type FunnelsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Funnels
     */
    select?: FunnelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Funnels
     */
    omit?: FunnelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelsInclude<ExtArgs> | null
    /**
     * Filter, which Funnels to fetch.
     */
    where?: FunnelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Funnels to fetch.
     */
    orderBy?: FunnelsOrderByWithRelationInput | FunnelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Funnels.
     */
    cursor?: FunnelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Funnels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Funnels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Funnels.
     */
    distinct?: FunnelsScalarFieldEnum | FunnelsScalarFieldEnum[]
  }

  /**
   * Funnels findMany
   */
  export type FunnelsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Funnels
     */
    select?: FunnelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Funnels
     */
    omit?: FunnelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelsInclude<ExtArgs> | null
    /**
     * Filter, which Funnels to fetch.
     */
    where?: FunnelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Funnels to fetch.
     */
    orderBy?: FunnelsOrderByWithRelationInput | FunnelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Funnels.
     */
    cursor?: FunnelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Funnels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Funnels.
     */
    skip?: number
    distinct?: FunnelsScalarFieldEnum | FunnelsScalarFieldEnum[]
  }

  /**
   * Funnels create
   */
  export type FunnelsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Funnels
     */
    select?: FunnelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Funnels
     */
    omit?: FunnelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelsInclude<ExtArgs> | null
    /**
     * The data needed to create a Funnels.
     */
    data: XOR<FunnelsCreateInput, FunnelsUncheckedCreateInput>
  }

  /**
   * Funnels createMany
   */
  export type FunnelsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Funnels.
     */
    data: FunnelsCreateManyInput | FunnelsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Funnels createManyAndReturn
   */
  export type FunnelsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Funnels
     */
    select?: FunnelsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Funnels
     */
    omit?: FunnelsOmit<ExtArgs> | null
    /**
     * The data used to create many Funnels.
     */
    data: FunnelsCreateManyInput | FunnelsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Funnels update
   */
  export type FunnelsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Funnels
     */
    select?: FunnelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Funnels
     */
    omit?: FunnelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelsInclude<ExtArgs> | null
    /**
     * The data needed to update a Funnels.
     */
    data: XOR<FunnelsUpdateInput, FunnelsUncheckedUpdateInput>
    /**
     * Choose, which Funnels to update.
     */
    where: FunnelsWhereUniqueInput
  }

  /**
   * Funnels updateMany
   */
  export type FunnelsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Funnels.
     */
    data: XOR<FunnelsUpdateManyMutationInput, FunnelsUncheckedUpdateManyInput>
    /**
     * Filter which Funnels to update
     */
    where?: FunnelsWhereInput
    /**
     * Limit how many Funnels to update.
     */
    limit?: number
  }

  /**
   * Funnels updateManyAndReturn
   */
  export type FunnelsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Funnels
     */
    select?: FunnelsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Funnels
     */
    omit?: FunnelsOmit<ExtArgs> | null
    /**
     * The data used to update Funnels.
     */
    data: XOR<FunnelsUpdateManyMutationInput, FunnelsUncheckedUpdateManyInput>
    /**
     * Filter which Funnels to update
     */
    where?: FunnelsWhereInput
    /**
     * Limit how many Funnels to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Funnels upsert
   */
  export type FunnelsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Funnels
     */
    select?: FunnelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Funnels
     */
    omit?: FunnelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelsInclude<ExtArgs> | null
    /**
     * The filter to search for the Funnels to update in case it exists.
     */
    where: FunnelsWhereUniqueInput
    /**
     * In case the Funnels found by the `where` argument doesn't exist, create a new Funnels with this data.
     */
    create: XOR<FunnelsCreateInput, FunnelsUncheckedCreateInput>
    /**
     * In case the Funnels was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FunnelsUpdateInput, FunnelsUncheckedUpdateInput>
  }

  /**
   * Funnels delete
   */
  export type FunnelsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Funnels
     */
    select?: FunnelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Funnels
     */
    omit?: FunnelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelsInclude<ExtArgs> | null
    /**
     * Filter which Funnels to delete.
     */
    where: FunnelsWhereUniqueInput
  }

  /**
   * Funnels deleteMany
   */
  export type FunnelsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Funnels to delete
     */
    where?: FunnelsWhereInput
    /**
     * Limit how many Funnels to delete.
     */
    limit?: number
  }

  /**
   * Funnels.FunelPages
   */
  export type Funnels$FunelPagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunelPages
     */
    select?: FunelPagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FunelPages
     */
    omit?: FunelPagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunelPagesInclude<ExtArgs> | null
    where?: FunelPagesWhereInput
    orderBy?: FunelPagesOrderByWithRelationInput | FunelPagesOrderByWithRelationInput[]
    cursor?: FunelPagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FunelPagesScalarFieldEnum | FunelPagesScalarFieldEnum[]
  }

  /**
   * Funnels.className
   */
  export type Funnels$classNameArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassName
     */
    select?: ClassNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassName
     */
    omit?: ClassNameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassNameInclude<ExtArgs> | null
    where?: ClassNameWhereInput
    orderBy?: ClassNameOrderByWithRelationInput | ClassNameOrderByWithRelationInput[]
    cursor?: ClassNameWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassNameScalarFieldEnum | ClassNameScalarFieldEnum[]
  }

  /**
   * Funnels without action
   */
  export type FunnelsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Funnels
     */
    select?: FunnelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Funnels
     */
    omit?: FunnelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunnelsInclude<ExtArgs> | null
  }


  /**
   * Model Notifications
   */

  export type AggregateNotifications = {
    _count: NotificationsCountAggregateOutputType | null
    _min: NotificationsMinAggregateOutputType | null
    _max: NotificationsMaxAggregateOutputType | null
  }

  export type NotificationsMinAggregateOutputType = {
    id: string | null
    notification: string | null
    agencyId: string | null
    subAccountId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationsMaxAggregateOutputType = {
    id: string | null
    notification: string | null
    agencyId: string | null
    subAccountId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationsCountAggregateOutputType = {
    id: number
    notification: number
    agencyId: number
    subAccountId: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationsMinAggregateInputType = {
    id?: true
    notification?: true
    agencyId?: true
    subAccountId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationsMaxAggregateInputType = {
    id?: true
    notification?: true
    agencyId?: true
    subAccountId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationsCountAggregateInputType = {
    id?: true
    notification?: true
    agencyId?: true
    subAccountId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to aggregate.
     */
    where?: NotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationsOrderByWithRelationInput | NotificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationsMaxAggregateInputType
  }

  export type GetNotificationsAggregateType<T extends NotificationsAggregateArgs> = {
        [P in keyof T & keyof AggregateNotifications]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotifications[P]>
      : GetScalarType<T[P], AggregateNotifications[P]>
  }




  export type NotificationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationsWhereInput
    orderBy?: NotificationsOrderByWithAggregationInput | NotificationsOrderByWithAggregationInput[]
    by: NotificationsScalarFieldEnum[] | NotificationsScalarFieldEnum
    having?: NotificationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationsCountAggregateInputType | true
    _min?: NotificationsMinAggregateInputType
    _max?: NotificationsMaxAggregateInputType
  }

  export type NotificationsGroupByOutputType = {
    id: string
    notification: string
    agencyId: string
    subAccountId: string | null
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: NotificationsCountAggregateOutputType | null
    _min: NotificationsMinAggregateOutputType | null
    _max: NotificationsMaxAggregateOutputType | null
  }

  type GetNotificationsGroupByPayload<T extends NotificationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationsGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationsGroupByOutputType[P]>
        }
      >
    >


  export type NotificationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    notification?: boolean
    agencyId?: boolean
    subAccountId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Users?: boolean | UsersDefaultArgs<ExtArgs>
    Agency?: boolean | AgencyDefaultArgs<ExtArgs>
    SubAccounts?: boolean | Notifications$SubAccountsArgs<ExtArgs>
  }, ExtArgs["result"]["notifications"]>

  export type NotificationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    notification?: boolean
    agencyId?: boolean
    subAccountId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Users?: boolean | UsersDefaultArgs<ExtArgs>
    Agency?: boolean | AgencyDefaultArgs<ExtArgs>
    SubAccounts?: boolean | Notifications$SubAccountsArgs<ExtArgs>
  }, ExtArgs["result"]["notifications"]>

  export type NotificationsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    notification?: boolean
    agencyId?: boolean
    subAccountId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Users?: boolean | UsersDefaultArgs<ExtArgs>
    Agency?: boolean | AgencyDefaultArgs<ExtArgs>
    SubAccounts?: boolean | Notifications$SubAccountsArgs<ExtArgs>
  }, ExtArgs["result"]["notifications"]>

  export type NotificationsSelectScalar = {
    id?: boolean
    notification?: boolean
    agencyId?: boolean
    subAccountId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "notification" | "agencyId" | "subAccountId" | "userId" | "createdAt" | "updatedAt", ExtArgs["result"]["notifications"]>
  export type NotificationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | UsersDefaultArgs<ExtArgs>
    Agency?: boolean | AgencyDefaultArgs<ExtArgs>
    SubAccounts?: boolean | Notifications$SubAccountsArgs<ExtArgs>
  }
  export type NotificationsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | UsersDefaultArgs<ExtArgs>
    Agency?: boolean | AgencyDefaultArgs<ExtArgs>
    SubAccounts?: boolean | Notifications$SubAccountsArgs<ExtArgs>
  }
  export type NotificationsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | UsersDefaultArgs<ExtArgs>
    Agency?: boolean | AgencyDefaultArgs<ExtArgs>
    SubAccounts?: boolean | Notifications$SubAccountsArgs<ExtArgs>
  }

  export type $NotificationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notifications"
    objects: {
      Users: Prisma.$UsersPayload<ExtArgs>
      Agency: Prisma.$AgencyPayload<ExtArgs>
      SubAccounts: Prisma.$SubAccountsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      notification: string
      agencyId: string
      subAccountId: string | null
      userId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notifications"]>
    composites: {}
  }

  type NotificationsGetPayload<S extends boolean | null | undefined | NotificationsDefaultArgs> = $Result.GetResult<Prisma.$NotificationsPayload, S>

  type NotificationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationsCountAggregateInputType | true
    }

  export interface NotificationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notifications'], meta: { name: 'Notifications' } }
    /**
     * Find zero or one Notifications that matches the filter.
     * @param {NotificationsFindUniqueArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationsFindUniqueArgs>(args: SelectSubset<T, NotificationsFindUniqueArgs<ExtArgs>>): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notifications that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationsFindUniqueOrThrowArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationsFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsFindFirstArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationsFindFirstArgs>(args?: SelectSubset<T, NotificationsFindFirstArgs<ExtArgs>>): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notifications that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsFindFirstOrThrowArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationsFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notifications.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notifications.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationsWithIdOnly = await prisma.notifications.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationsFindManyArgs>(args?: SelectSubset<T, NotificationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notifications.
     * @param {NotificationsCreateArgs} args - Arguments to create a Notifications.
     * @example
     * // Create one Notifications
     * const Notifications = await prisma.notifications.create({
     *   data: {
     *     // ... data to create a Notifications
     *   }
     * })
     * 
     */
    create<T extends NotificationsCreateArgs>(args: SelectSubset<T, NotificationsCreateArgs<ExtArgs>>): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationsCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notifications = await prisma.notifications.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationsCreateManyArgs>(args?: SelectSubset<T, NotificationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationsCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notifications = await prisma.notifications.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationsWithIdOnly = await prisma.notifications.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationsCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notifications.
     * @param {NotificationsDeleteArgs} args - Arguments to delete one Notifications.
     * @example
     * // Delete one Notifications
     * const Notifications = await prisma.notifications.delete({
     *   where: {
     *     // ... filter to delete one Notifications
     *   }
     * })
     * 
     */
    delete<T extends NotificationsDeleteArgs>(args: SelectSubset<T, NotificationsDeleteArgs<ExtArgs>>): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notifications.
     * @param {NotificationsUpdateArgs} args - Arguments to update one Notifications.
     * @example
     * // Update one Notifications
     * const notifications = await prisma.notifications.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationsUpdateArgs>(args: SelectSubset<T, NotificationsUpdateArgs<ExtArgs>>): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationsDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notifications.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationsDeleteManyArgs>(args?: SelectSubset<T, NotificationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notifications = await prisma.notifications.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationsUpdateManyArgs>(args: SelectSubset<T, NotificationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationsUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notifications = await prisma.notifications.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationsWithIdOnly = await prisma.notifications.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationsUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notifications.
     * @param {NotificationsUpsertArgs} args - Arguments to update or create a Notifications.
     * @example
     * // Update or create a Notifications
     * const notifications = await prisma.notifications.upsert({
     *   create: {
     *     // ... data to create a Notifications
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notifications we want to update
     *   }
     * })
     */
    upsert<T extends NotificationsUpsertArgs>(args: SelectSubset<T, NotificationsUpsertArgs<ExtArgs>>): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notifications.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationsCountArgs>(
      args?: Subset<T, NotificationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationsAggregateArgs>(args: Subset<T, NotificationsAggregateArgs>): Prisma.PrismaPromise<GetNotificationsAggregateType<T>>

    /**
     * Group by Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationsGroupByArgs['orderBy'] }
        : { orderBy?: NotificationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notifications model
   */
  readonly fields: NotificationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notifications.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Agency<T extends AgencyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgencyDefaultArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    SubAccounts<T extends Notifications$SubAccountsArgs<ExtArgs> = {}>(args?: Subset<T, Notifications$SubAccountsArgs<ExtArgs>>): Prisma__SubAccountsClient<$Result.GetResult<Prisma.$SubAccountsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notifications model
   */
  interface NotificationsFieldRefs {
    readonly id: FieldRef<"Notifications", 'String'>
    readonly notification: FieldRef<"Notifications", 'String'>
    readonly agencyId: FieldRef<"Notifications", 'String'>
    readonly subAccountId: FieldRef<"Notifications", 'String'>
    readonly userId: FieldRef<"Notifications", 'String'>
    readonly createdAt: FieldRef<"Notifications", 'DateTime'>
    readonly updatedAt: FieldRef<"Notifications", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notifications findUnique
   */
  export type NotificationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where: NotificationsWhereUniqueInput
  }

  /**
   * Notifications findUniqueOrThrow
   */
  export type NotificationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where: NotificationsWhereUniqueInput
  }

  /**
   * Notifications findFirst
   */
  export type NotificationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationsOrderByWithRelationInput | NotificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * Notifications findFirstOrThrow
   */
  export type NotificationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationsOrderByWithRelationInput | NotificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * Notifications findMany
   */
  export type NotificationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationsOrderByWithRelationInput | NotificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * Notifications create
   */
  export type NotificationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * The data needed to create a Notifications.
     */
    data: XOR<NotificationsCreateInput, NotificationsUncheckedCreateInput>
  }

  /**
   * Notifications createMany
   */
  export type NotificationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationsCreateManyInput | NotificationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notifications createManyAndReturn
   */
  export type NotificationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationsCreateManyInput | NotificationsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notifications update
   */
  export type NotificationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * The data needed to update a Notifications.
     */
    data: XOR<NotificationsUpdateInput, NotificationsUncheckedUpdateInput>
    /**
     * Choose, which Notifications to update.
     */
    where: NotificationsWhereUniqueInput
  }

  /**
   * Notifications updateMany
   */
  export type NotificationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationsUpdateManyMutationInput, NotificationsUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationsWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notifications updateManyAndReturn
   */
  export type NotificationsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationsUpdateManyMutationInput, NotificationsUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationsWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notifications upsert
   */
  export type NotificationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * The filter to search for the Notifications to update in case it exists.
     */
    where: NotificationsWhereUniqueInput
    /**
     * In case the Notifications found by the `where` argument doesn't exist, create a new Notifications with this data.
     */
    create: XOR<NotificationsCreateInput, NotificationsUncheckedCreateInput>
    /**
     * In case the Notifications was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationsUpdateInput, NotificationsUncheckedUpdateInput>
  }

  /**
   * Notifications delete
   */
  export type NotificationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * Filter which Notifications to delete.
     */
    where: NotificationsWhereUniqueInput
  }

  /**
   * Notifications deleteMany
   */
  export type NotificationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationsWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notifications.SubAccounts
   */
  export type Notifications$SubAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubAccounts
     */
    select?: SubAccountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubAccounts
     */
    omit?: SubAccountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubAccountsInclude<ExtArgs> | null
    where?: SubAccountsWhereInput
  }

  /**
   * Notifications without action
   */
  export type NotificationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notifications
     */
    omit?: NotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
  }


  /**
   * Model Subscriptions
   */

  export type AggregateSubscriptions = {
    _count: SubscriptionsCountAggregateOutputType | null
    _min: SubscriptionsMinAggregateOutputType | null
    _max: SubscriptionsMaxAggregateOutputType | null
  }

  export type SubscriptionsMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    plan: $Enums.Plans | null
    price: string | null
    active: boolean | null
    priceId: string | null
    customerId: string | null
    currentPeriodEndDate: Date | null
    subscriptionId: string | null
    agencyId: string | null
  }

  export type SubscriptionsMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    plan: $Enums.Plans | null
    price: string | null
    active: boolean | null
    priceId: string | null
    customerId: string | null
    currentPeriodEndDate: Date | null
    subscriptionId: string | null
    agencyId: string | null
  }

  export type SubscriptionsCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    plan: number
    price: number
    active: number
    priceId: number
    customerId: number
    currentPeriodEndDate: number
    subscriptionId: number
    agencyId: number
    _all: number
  }


  export type SubscriptionsMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    plan?: true
    price?: true
    active?: true
    priceId?: true
    customerId?: true
    currentPeriodEndDate?: true
    subscriptionId?: true
    agencyId?: true
  }

  export type SubscriptionsMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    plan?: true
    price?: true
    active?: true
    priceId?: true
    customerId?: true
    currentPeriodEndDate?: true
    subscriptionId?: true
    agencyId?: true
  }

  export type SubscriptionsCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    plan?: true
    price?: true
    active?: true
    priceId?: true
    customerId?: true
    currentPeriodEndDate?: true
    subscriptionId?: true
    agencyId?: true
    _all?: true
  }

  export type SubscriptionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscriptions to aggregate.
     */
    where?: SubscriptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionsOrderByWithRelationInput | SubscriptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscriptions
    **/
    _count?: true | SubscriptionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionsMaxAggregateInputType
  }

  export type GetSubscriptionsAggregateType<T extends SubscriptionsAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscriptions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscriptions[P]>
      : GetScalarType<T[P], AggregateSubscriptions[P]>
  }




  export type SubscriptionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionsWhereInput
    orderBy?: SubscriptionsOrderByWithAggregationInput | SubscriptionsOrderByWithAggregationInput[]
    by: SubscriptionsScalarFieldEnum[] | SubscriptionsScalarFieldEnum
    having?: SubscriptionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionsCountAggregateInputType | true
    _min?: SubscriptionsMinAggregateInputType
    _max?: SubscriptionsMaxAggregateInputType
  }

  export type SubscriptionsGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    plan: $Enums.Plans | null
    price: string | null
    active: boolean
    priceId: string
    customerId: string
    currentPeriodEndDate: Date
    subscriptionId: string
    agencyId: string | null
    _count: SubscriptionsCountAggregateOutputType | null
    _min: SubscriptionsMinAggregateOutputType | null
    _max: SubscriptionsMaxAggregateOutputType | null
  }

  type GetSubscriptionsGroupByPayload<T extends SubscriptionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionsGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionsGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plan?: boolean
    price?: boolean
    active?: boolean
    priceId?: boolean
    customerId?: boolean
    currentPeriodEndDate?: boolean
    subscriptionId?: boolean
    agencyId?: boolean
    Agency?: boolean | Subscriptions$AgencyArgs<ExtArgs>
  }, ExtArgs["result"]["subscriptions"]>

  export type SubscriptionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plan?: boolean
    price?: boolean
    active?: boolean
    priceId?: boolean
    customerId?: boolean
    currentPeriodEndDate?: boolean
    subscriptionId?: boolean
    agencyId?: boolean
    Agency?: boolean | Subscriptions$AgencyArgs<ExtArgs>
  }, ExtArgs["result"]["subscriptions"]>

  export type SubscriptionsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plan?: boolean
    price?: boolean
    active?: boolean
    priceId?: boolean
    customerId?: boolean
    currentPeriodEndDate?: boolean
    subscriptionId?: boolean
    agencyId?: boolean
    Agency?: boolean | Subscriptions$AgencyArgs<ExtArgs>
  }, ExtArgs["result"]["subscriptions"]>

  export type SubscriptionsSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plan?: boolean
    price?: boolean
    active?: boolean
    priceId?: boolean
    customerId?: boolean
    currentPeriodEndDate?: boolean
    subscriptionId?: boolean
    agencyId?: boolean
  }

  export type SubscriptionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "plan" | "price" | "active" | "priceId" | "customerId" | "currentPeriodEndDate" | "subscriptionId" | "agencyId", ExtArgs["result"]["subscriptions"]>
  export type SubscriptionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Agency?: boolean | Subscriptions$AgencyArgs<ExtArgs>
  }
  export type SubscriptionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Agency?: boolean | Subscriptions$AgencyArgs<ExtArgs>
  }
  export type SubscriptionsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Agency?: boolean | Subscriptions$AgencyArgs<ExtArgs>
  }

  export type $SubscriptionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subscriptions"
    objects: {
      Agency: Prisma.$AgencyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      plan: $Enums.Plans | null
      price: string | null
      active: boolean
      priceId: string
      customerId: string
      currentPeriodEndDate: Date
      subscriptionId: string
      agencyId: string | null
    }, ExtArgs["result"]["subscriptions"]>
    composites: {}
  }

  type SubscriptionsGetPayload<S extends boolean | null | undefined | SubscriptionsDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionsPayload, S>

  type SubscriptionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubscriptionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubscriptionsCountAggregateInputType | true
    }

  export interface SubscriptionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subscriptions'], meta: { name: 'Subscriptions' } }
    /**
     * Find zero or one Subscriptions that matches the filter.
     * @param {SubscriptionsFindUniqueArgs} args - Arguments to find a Subscriptions
     * @example
     * // Get one Subscriptions
     * const subscriptions = await prisma.subscriptions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionsFindUniqueArgs>(args: SelectSubset<T, SubscriptionsFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionsClient<$Result.GetResult<Prisma.$SubscriptionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subscriptions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubscriptionsFindUniqueOrThrowArgs} args - Arguments to find a Subscriptions
     * @example
     * // Get one Subscriptions
     * const subscriptions = await prisma.subscriptions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionsFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionsClient<$Result.GetResult<Prisma.$SubscriptionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionsFindFirstArgs} args - Arguments to find a Subscriptions
     * @example
     * // Get one Subscriptions
     * const subscriptions = await prisma.subscriptions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionsFindFirstArgs>(args?: SelectSubset<T, SubscriptionsFindFirstArgs<ExtArgs>>): Prisma__SubscriptionsClient<$Result.GetResult<Prisma.$SubscriptionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscriptions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionsFindFirstOrThrowArgs} args - Arguments to find a Subscriptions
     * @example
     * // Get one Subscriptions
     * const subscriptions = await prisma.subscriptions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionsFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionsClient<$Result.GetResult<Prisma.$SubscriptionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscriptions.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscriptions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionsWithIdOnly = await prisma.subscriptions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionsFindManyArgs>(args?: SelectSubset<T, SubscriptionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subscriptions.
     * @param {SubscriptionsCreateArgs} args - Arguments to create a Subscriptions.
     * @example
     * // Create one Subscriptions
     * const Subscriptions = await prisma.subscriptions.create({
     *   data: {
     *     // ... data to create a Subscriptions
     *   }
     * })
     * 
     */
    create<T extends SubscriptionsCreateArgs>(args: SelectSubset<T, SubscriptionsCreateArgs<ExtArgs>>): Prisma__SubscriptionsClient<$Result.GetResult<Prisma.$SubscriptionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subscriptions.
     * @param {SubscriptionsCreateManyArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscriptions = await prisma.subscriptions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionsCreateManyArgs>(args?: SelectSubset<T, SubscriptionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subscriptions and returns the data saved in the database.
     * @param {SubscriptionsCreateManyAndReturnArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscriptions = await prisma.subscriptions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subscriptions and only return the `id`
     * const subscriptionsWithIdOnly = await prisma.subscriptions.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionsCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Subscriptions.
     * @param {SubscriptionsDeleteArgs} args - Arguments to delete one Subscriptions.
     * @example
     * // Delete one Subscriptions
     * const Subscriptions = await prisma.subscriptions.delete({
     *   where: {
     *     // ... filter to delete one Subscriptions
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionsDeleteArgs>(args: SelectSubset<T, SubscriptionsDeleteArgs<ExtArgs>>): Prisma__SubscriptionsClient<$Result.GetResult<Prisma.$SubscriptionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subscriptions.
     * @param {SubscriptionsUpdateArgs} args - Arguments to update one Subscriptions.
     * @example
     * // Update one Subscriptions
     * const subscriptions = await prisma.subscriptions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionsUpdateArgs>(args: SelectSubset<T, SubscriptionsUpdateArgs<ExtArgs>>): Prisma__SubscriptionsClient<$Result.GetResult<Prisma.$SubscriptionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subscriptions.
     * @param {SubscriptionsDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscriptions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionsDeleteManyArgs>(args?: SelectSubset<T, SubscriptionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscriptions = await prisma.subscriptions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionsUpdateManyArgs>(args: SelectSubset<T, SubscriptionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions and returns the data updated in the database.
     * @param {SubscriptionsUpdateManyAndReturnArgs} args - Arguments to update many Subscriptions.
     * @example
     * // Update many Subscriptions
     * const subscriptions = await prisma.subscriptions.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Subscriptions and only return the `id`
     * const subscriptionsWithIdOnly = await prisma.subscriptions.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubscriptionsUpdateManyAndReturnArgs>(args: SelectSubset<T, SubscriptionsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Subscriptions.
     * @param {SubscriptionsUpsertArgs} args - Arguments to update or create a Subscriptions.
     * @example
     * // Update or create a Subscriptions
     * const subscriptions = await prisma.subscriptions.upsert({
     *   create: {
     *     // ... data to create a Subscriptions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscriptions we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionsUpsertArgs>(args: SelectSubset<T, SubscriptionsUpsertArgs<ExtArgs>>): Prisma__SubscriptionsClient<$Result.GetResult<Prisma.$SubscriptionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionsCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscriptions.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionsCountArgs>(
      args?: Subset<T, SubscriptionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionsAggregateArgs>(args: Subset<T, SubscriptionsAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionsAggregateType<T>>

    /**
     * Group by Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionsGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subscriptions model
   */
  readonly fields: SubscriptionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscriptions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Agency<T extends Subscriptions$AgencyArgs<ExtArgs> = {}>(args?: Subset<T, Subscriptions$AgencyArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subscriptions model
   */
  interface SubscriptionsFieldRefs {
    readonly id: FieldRef<"Subscriptions", 'String'>
    readonly createdAt: FieldRef<"Subscriptions", 'DateTime'>
    readonly updatedAt: FieldRef<"Subscriptions", 'DateTime'>
    readonly plan: FieldRef<"Subscriptions", 'Plans'>
    readonly price: FieldRef<"Subscriptions", 'String'>
    readonly active: FieldRef<"Subscriptions", 'Boolean'>
    readonly priceId: FieldRef<"Subscriptions", 'String'>
    readonly customerId: FieldRef<"Subscriptions", 'String'>
    readonly currentPeriodEndDate: FieldRef<"Subscriptions", 'DateTime'>
    readonly subscriptionId: FieldRef<"Subscriptions", 'String'>
    readonly agencyId: FieldRef<"Subscriptions", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Subscriptions findUnique
   */
  export type SubscriptionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriptions
     */
    select?: SubscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscriptions
     */
    omit?: SubscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionsInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where: SubscriptionsWhereUniqueInput
  }

  /**
   * Subscriptions findUniqueOrThrow
   */
  export type SubscriptionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriptions
     */
    select?: SubscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscriptions
     */
    omit?: SubscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionsInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where: SubscriptionsWhereUniqueInput
  }

  /**
   * Subscriptions findFirst
   */
  export type SubscriptionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriptions
     */
    select?: SubscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscriptions
     */
    omit?: SubscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionsInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionsOrderByWithRelationInput | SubscriptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionsScalarFieldEnum | SubscriptionsScalarFieldEnum[]
  }

  /**
   * Subscriptions findFirstOrThrow
   */
  export type SubscriptionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriptions
     */
    select?: SubscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscriptions
     */
    omit?: SubscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionsInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionsOrderByWithRelationInput | SubscriptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionsScalarFieldEnum | SubscriptionsScalarFieldEnum[]
  }

  /**
   * Subscriptions findMany
   */
  export type SubscriptionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriptions
     */
    select?: SubscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscriptions
     */
    omit?: SubscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionsInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionsOrderByWithRelationInput | SubscriptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscriptions.
     */
    cursor?: SubscriptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    distinct?: SubscriptionsScalarFieldEnum | SubscriptionsScalarFieldEnum[]
  }

  /**
   * Subscriptions create
   */
  export type SubscriptionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriptions
     */
    select?: SubscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscriptions
     */
    omit?: SubscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionsInclude<ExtArgs> | null
    /**
     * The data needed to create a Subscriptions.
     */
    data: XOR<SubscriptionsCreateInput, SubscriptionsUncheckedCreateInput>
  }

  /**
   * Subscriptions createMany
   */
  export type SubscriptionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionsCreateManyInput | SubscriptionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subscriptions createManyAndReturn
   */
  export type SubscriptionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriptions
     */
    select?: SubscriptionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscriptions
     */
    omit?: SubscriptionsOmit<ExtArgs> | null
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionsCreateManyInput | SubscriptionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscriptions update
   */
  export type SubscriptionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriptions
     */
    select?: SubscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscriptions
     */
    omit?: SubscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionsInclude<ExtArgs> | null
    /**
     * The data needed to update a Subscriptions.
     */
    data: XOR<SubscriptionsUpdateInput, SubscriptionsUncheckedUpdateInput>
    /**
     * Choose, which Subscriptions to update.
     */
    where: SubscriptionsWhereUniqueInput
  }

  /**
   * Subscriptions updateMany
   */
  export type SubscriptionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionsUpdateManyMutationInput, SubscriptionsUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionsWhereInput
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number
  }

  /**
   * Subscriptions updateManyAndReturn
   */
  export type SubscriptionsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriptions
     */
    select?: SubscriptionsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscriptions
     */
    omit?: SubscriptionsOmit<ExtArgs> | null
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionsUpdateManyMutationInput, SubscriptionsUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionsWhereInput
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscriptions upsert
   */
  export type SubscriptionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriptions
     */
    select?: SubscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscriptions
     */
    omit?: SubscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionsInclude<ExtArgs> | null
    /**
     * The filter to search for the Subscriptions to update in case it exists.
     */
    where: SubscriptionsWhereUniqueInput
    /**
     * In case the Subscriptions found by the `where` argument doesn't exist, create a new Subscriptions with this data.
     */
    create: XOR<SubscriptionsCreateInput, SubscriptionsUncheckedCreateInput>
    /**
     * In case the Subscriptions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionsUpdateInput, SubscriptionsUncheckedUpdateInput>
  }

  /**
   * Subscriptions delete
   */
  export type SubscriptionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriptions
     */
    select?: SubscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscriptions
     */
    omit?: SubscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionsInclude<ExtArgs> | null
    /**
     * Filter which Subscriptions to delete.
     */
    where: SubscriptionsWhereUniqueInput
  }

  /**
   * Subscriptions deleteMany
   */
  export type SubscriptionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscriptions to delete
     */
    where?: SubscriptionsWhereInput
    /**
     * Limit how many Subscriptions to delete.
     */
    limit?: number
  }

  /**
   * Subscriptions.Agency
   */
  export type Subscriptions$AgencyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    where?: AgencyWhereInput
  }

  /**
   * Subscriptions without action
   */
  export type SubscriptionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscriptions
     */
    select?: SubscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscriptions
     */
    omit?: SubscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionsInclude<ExtArgs> | null
  }


  /**
   * Model ClassName
   */

  export type AggregateClassName = {
    _count: ClassNameCountAggregateOutputType | null
    _min: ClassNameMinAggregateOutputType | null
    _max: ClassNameMaxAggregateOutputType | null
  }

  export type ClassNameMinAggregateOutputType = {
    id: string | null
    name: string | null
    color: string | null
    createdAt: Date | null
    updatedAt: Date | null
    funnelId: string | null
    customData: string | null
  }

  export type ClassNameMaxAggregateOutputType = {
    id: string | null
    name: string | null
    color: string | null
    createdAt: Date | null
    updatedAt: Date | null
    funnelId: string | null
    customData: string | null
  }

  export type ClassNameCountAggregateOutputType = {
    id: number
    name: number
    color: number
    createdAt: number
    updatedAt: number
    funnelId: number
    customData: number
    _all: number
  }


  export type ClassNameMinAggregateInputType = {
    id?: true
    name?: true
    color?: true
    createdAt?: true
    updatedAt?: true
    funnelId?: true
    customData?: true
  }

  export type ClassNameMaxAggregateInputType = {
    id?: true
    name?: true
    color?: true
    createdAt?: true
    updatedAt?: true
    funnelId?: true
    customData?: true
  }

  export type ClassNameCountAggregateInputType = {
    id?: true
    name?: true
    color?: true
    createdAt?: true
    updatedAt?: true
    funnelId?: true
    customData?: true
    _all?: true
  }

  export type ClassNameAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassName to aggregate.
     */
    where?: ClassNameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassNames to fetch.
     */
    orderBy?: ClassNameOrderByWithRelationInput | ClassNameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassNameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassNames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassNames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClassNames
    **/
    _count?: true | ClassNameCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassNameMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassNameMaxAggregateInputType
  }

  export type GetClassNameAggregateType<T extends ClassNameAggregateArgs> = {
        [P in keyof T & keyof AggregateClassName]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClassName[P]>
      : GetScalarType<T[P], AggregateClassName[P]>
  }




  export type ClassNameGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassNameWhereInput
    orderBy?: ClassNameOrderByWithAggregationInput | ClassNameOrderByWithAggregationInput[]
    by: ClassNameScalarFieldEnum[] | ClassNameScalarFieldEnum
    having?: ClassNameScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassNameCountAggregateInputType | true
    _min?: ClassNameMinAggregateInputType
    _max?: ClassNameMaxAggregateInputType
  }

  export type ClassNameGroupByOutputType = {
    id: string
    name: string
    color: string
    createdAt: Date
    updatedAt: Date
    funnelId: string
    customData: string | null
    _count: ClassNameCountAggregateOutputType | null
    _min: ClassNameMinAggregateOutputType | null
    _max: ClassNameMaxAggregateOutputType | null
  }

  type GetClassNameGroupByPayload<T extends ClassNameGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClassNameGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassNameGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassNameGroupByOutputType[P]>
            : GetScalarType<T[P], ClassNameGroupByOutputType[P]>
        }
      >
    >


  export type ClassNameSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    funnelId?: boolean
    customData?: boolean
    Funnel?: boolean | FunnelsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["className"]>

  export type ClassNameSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    funnelId?: boolean
    customData?: boolean
    Funnel?: boolean | FunnelsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["className"]>

  export type ClassNameSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    funnelId?: boolean
    customData?: boolean
    Funnel?: boolean | FunnelsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["className"]>

  export type ClassNameSelectScalar = {
    id?: boolean
    name?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    funnelId?: boolean
    customData?: boolean
  }

  export type ClassNameOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "color" | "createdAt" | "updatedAt" | "funnelId" | "customData", ExtArgs["result"]["className"]>
  export type ClassNameInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Funnel?: boolean | FunnelsDefaultArgs<ExtArgs>
  }
  export type ClassNameIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Funnel?: boolean | FunnelsDefaultArgs<ExtArgs>
  }
  export type ClassNameIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Funnel?: boolean | FunnelsDefaultArgs<ExtArgs>
  }

  export type $ClassNamePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClassName"
    objects: {
      Funnel: Prisma.$FunnelsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      color: string
      createdAt: Date
      updatedAt: Date
      funnelId: string
      customData: string | null
    }, ExtArgs["result"]["className"]>
    composites: {}
  }

  type ClassNameGetPayload<S extends boolean | null | undefined | ClassNameDefaultArgs> = $Result.GetResult<Prisma.$ClassNamePayload, S>

  type ClassNameCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClassNameFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClassNameCountAggregateInputType | true
    }

  export interface ClassNameDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClassName'], meta: { name: 'ClassName' } }
    /**
     * Find zero or one ClassName that matches the filter.
     * @param {ClassNameFindUniqueArgs} args - Arguments to find a ClassName
     * @example
     * // Get one ClassName
     * const className = await prisma.className.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClassNameFindUniqueArgs>(args: SelectSubset<T, ClassNameFindUniqueArgs<ExtArgs>>): Prisma__ClassNameClient<$Result.GetResult<Prisma.$ClassNamePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClassName that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClassNameFindUniqueOrThrowArgs} args - Arguments to find a ClassName
     * @example
     * // Get one ClassName
     * const className = await prisma.className.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClassNameFindUniqueOrThrowArgs>(args: SelectSubset<T, ClassNameFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClassNameClient<$Result.GetResult<Prisma.$ClassNamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClassName that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassNameFindFirstArgs} args - Arguments to find a ClassName
     * @example
     * // Get one ClassName
     * const className = await prisma.className.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClassNameFindFirstArgs>(args?: SelectSubset<T, ClassNameFindFirstArgs<ExtArgs>>): Prisma__ClassNameClient<$Result.GetResult<Prisma.$ClassNamePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClassName that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassNameFindFirstOrThrowArgs} args - Arguments to find a ClassName
     * @example
     * // Get one ClassName
     * const className = await prisma.className.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClassNameFindFirstOrThrowArgs>(args?: SelectSubset<T, ClassNameFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClassNameClient<$Result.GetResult<Prisma.$ClassNamePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClassNames that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassNameFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClassNames
     * const classNames = await prisma.className.findMany()
     * 
     * // Get first 10 ClassNames
     * const classNames = await prisma.className.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const classNameWithIdOnly = await prisma.className.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClassNameFindManyArgs>(args?: SelectSubset<T, ClassNameFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassNamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClassName.
     * @param {ClassNameCreateArgs} args - Arguments to create a ClassName.
     * @example
     * // Create one ClassName
     * const ClassName = await prisma.className.create({
     *   data: {
     *     // ... data to create a ClassName
     *   }
     * })
     * 
     */
    create<T extends ClassNameCreateArgs>(args: SelectSubset<T, ClassNameCreateArgs<ExtArgs>>): Prisma__ClassNameClient<$Result.GetResult<Prisma.$ClassNamePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClassNames.
     * @param {ClassNameCreateManyArgs} args - Arguments to create many ClassNames.
     * @example
     * // Create many ClassNames
     * const className = await prisma.className.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClassNameCreateManyArgs>(args?: SelectSubset<T, ClassNameCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClassNames and returns the data saved in the database.
     * @param {ClassNameCreateManyAndReturnArgs} args - Arguments to create many ClassNames.
     * @example
     * // Create many ClassNames
     * const className = await prisma.className.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClassNames and only return the `id`
     * const classNameWithIdOnly = await prisma.className.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClassNameCreateManyAndReturnArgs>(args?: SelectSubset<T, ClassNameCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassNamePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ClassName.
     * @param {ClassNameDeleteArgs} args - Arguments to delete one ClassName.
     * @example
     * // Delete one ClassName
     * const ClassName = await prisma.className.delete({
     *   where: {
     *     // ... filter to delete one ClassName
     *   }
     * })
     * 
     */
    delete<T extends ClassNameDeleteArgs>(args: SelectSubset<T, ClassNameDeleteArgs<ExtArgs>>): Prisma__ClassNameClient<$Result.GetResult<Prisma.$ClassNamePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClassName.
     * @param {ClassNameUpdateArgs} args - Arguments to update one ClassName.
     * @example
     * // Update one ClassName
     * const className = await prisma.className.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClassNameUpdateArgs>(args: SelectSubset<T, ClassNameUpdateArgs<ExtArgs>>): Prisma__ClassNameClient<$Result.GetResult<Prisma.$ClassNamePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClassNames.
     * @param {ClassNameDeleteManyArgs} args - Arguments to filter ClassNames to delete.
     * @example
     * // Delete a few ClassNames
     * const { count } = await prisma.className.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClassNameDeleteManyArgs>(args?: SelectSubset<T, ClassNameDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClassNames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassNameUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClassNames
     * const className = await prisma.className.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClassNameUpdateManyArgs>(args: SelectSubset<T, ClassNameUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClassNames and returns the data updated in the database.
     * @param {ClassNameUpdateManyAndReturnArgs} args - Arguments to update many ClassNames.
     * @example
     * // Update many ClassNames
     * const className = await prisma.className.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ClassNames and only return the `id`
     * const classNameWithIdOnly = await prisma.className.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClassNameUpdateManyAndReturnArgs>(args: SelectSubset<T, ClassNameUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassNamePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ClassName.
     * @param {ClassNameUpsertArgs} args - Arguments to update or create a ClassName.
     * @example
     * // Update or create a ClassName
     * const className = await prisma.className.upsert({
     *   create: {
     *     // ... data to create a ClassName
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClassName we want to update
     *   }
     * })
     */
    upsert<T extends ClassNameUpsertArgs>(args: SelectSubset<T, ClassNameUpsertArgs<ExtArgs>>): Prisma__ClassNameClient<$Result.GetResult<Prisma.$ClassNamePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClassNames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassNameCountArgs} args - Arguments to filter ClassNames to count.
     * @example
     * // Count the number of ClassNames
     * const count = await prisma.className.count({
     *   where: {
     *     // ... the filter for the ClassNames we want to count
     *   }
     * })
    **/
    count<T extends ClassNameCountArgs>(
      args?: Subset<T, ClassNameCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassNameCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClassName.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassNameAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassNameAggregateArgs>(args: Subset<T, ClassNameAggregateArgs>): Prisma.PrismaPromise<GetClassNameAggregateType<T>>

    /**
     * Group by ClassName.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassNameGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassNameGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassNameGroupByArgs['orderBy'] }
        : { orderBy?: ClassNameGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassNameGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassNameGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClassName model
   */
  readonly fields: ClassNameFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClassName.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClassNameClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Funnel<T extends FunnelsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FunnelsDefaultArgs<ExtArgs>>): Prisma__FunnelsClient<$Result.GetResult<Prisma.$FunnelsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClassName model
   */
  interface ClassNameFieldRefs {
    readonly id: FieldRef<"ClassName", 'String'>
    readonly name: FieldRef<"ClassName", 'String'>
    readonly color: FieldRef<"ClassName", 'String'>
    readonly createdAt: FieldRef<"ClassName", 'DateTime'>
    readonly updatedAt: FieldRef<"ClassName", 'DateTime'>
    readonly funnelId: FieldRef<"ClassName", 'String'>
    readonly customData: FieldRef<"ClassName", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ClassName findUnique
   */
  export type ClassNameFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassName
     */
    select?: ClassNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassName
     */
    omit?: ClassNameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassNameInclude<ExtArgs> | null
    /**
     * Filter, which ClassName to fetch.
     */
    where: ClassNameWhereUniqueInput
  }

  /**
   * ClassName findUniqueOrThrow
   */
  export type ClassNameFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassName
     */
    select?: ClassNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassName
     */
    omit?: ClassNameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassNameInclude<ExtArgs> | null
    /**
     * Filter, which ClassName to fetch.
     */
    where: ClassNameWhereUniqueInput
  }

  /**
   * ClassName findFirst
   */
  export type ClassNameFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassName
     */
    select?: ClassNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassName
     */
    omit?: ClassNameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassNameInclude<ExtArgs> | null
    /**
     * Filter, which ClassName to fetch.
     */
    where?: ClassNameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassNames to fetch.
     */
    orderBy?: ClassNameOrderByWithRelationInput | ClassNameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassNames.
     */
    cursor?: ClassNameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassNames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassNames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassNames.
     */
    distinct?: ClassNameScalarFieldEnum | ClassNameScalarFieldEnum[]
  }

  /**
   * ClassName findFirstOrThrow
   */
  export type ClassNameFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassName
     */
    select?: ClassNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassName
     */
    omit?: ClassNameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassNameInclude<ExtArgs> | null
    /**
     * Filter, which ClassName to fetch.
     */
    where?: ClassNameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassNames to fetch.
     */
    orderBy?: ClassNameOrderByWithRelationInput | ClassNameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassNames.
     */
    cursor?: ClassNameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassNames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassNames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassNames.
     */
    distinct?: ClassNameScalarFieldEnum | ClassNameScalarFieldEnum[]
  }

  /**
   * ClassName findMany
   */
  export type ClassNameFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassName
     */
    select?: ClassNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassName
     */
    omit?: ClassNameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassNameInclude<ExtArgs> | null
    /**
     * Filter, which ClassNames to fetch.
     */
    where?: ClassNameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassNames to fetch.
     */
    orderBy?: ClassNameOrderByWithRelationInput | ClassNameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClassNames.
     */
    cursor?: ClassNameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassNames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassNames.
     */
    skip?: number
    distinct?: ClassNameScalarFieldEnum | ClassNameScalarFieldEnum[]
  }

  /**
   * ClassName create
   */
  export type ClassNameCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassName
     */
    select?: ClassNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassName
     */
    omit?: ClassNameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassNameInclude<ExtArgs> | null
    /**
     * The data needed to create a ClassName.
     */
    data: XOR<ClassNameCreateInput, ClassNameUncheckedCreateInput>
  }

  /**
   * ClassName createMany
   */
  export type ClassNameCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClassNames.
     */
    data: ClassNameCreateManyInput | ClassNameCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClassName createManyAndReturn
   */
  export type ClassNameCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassName
     */
    select?: ClassNameSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClassName
     */
    omit?: ClassNameOmit<ExtArgs> | null
    /**
     * The data used to create many ClassNames.
     */
    data: ClassNameCreateManyInput | ClassNameCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassNameIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClassName update
   */
  export type ClassNameUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassName
     */
    select?: ClassNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassName
     */
    omit?: ClassNameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassNameInclude<ExtArgs> | null
    /**
     * The data needed to update a ClassName.
     */
    data: XOR<ClassNameUpdateInput, ClassNameUncheckedUpdateInput>
    /**
     * Choose, which ClassName to update.
     */
    where: ClassNameWhereUniqueInput
  }

  /**
   * ClassName updateMany
   */
  export type ClassNameUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClassNames.
     */
    data: XOR<ClassNameUpdateManyMutationInput, ClassNameUncheckedUpdateManyInput>
    /**
     * Filter which ClassNames to update
     */
    where?: ClassNameWhereInput
    /**
     * Limit how many ClassNames to update.
     */
    limit?: number
  }

  /**
   * ClassName updateManyAndReturn
   */
  export type ClassNameUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassName
     */
    select?: ClassNameSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClassName
     */
    omit?: ClassNameOmit<ExtArgs> | null
    /**
     * The data used to update ClassNames.
     */
    data: XOR<ClassNameUpdateManyMutationInput, ClassNameUncheckedUpdateManyInput>
    /**
     * Filter which ClassNames to update
     */
    where?: ClassNameWhereInput
    /**
     * Limit how many ClassNames to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassNameIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClassName upsert
   */
  export type ClassNameUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassName
     */
    select?: ClassNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassName
     */
    omit?: ClassNameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassNameInclude<ExtArgs> | null
    /**
     * The filter to search for the ClassName to update in case it exists.
     */
    where: ClassNameWhereUniqueInput
    /**
     * In case the ClassName found by the `where` argument doesn't exist, create a new ClassName with this data.
     */
    create: XOR<ClassNameCreateInput, ClassNameUncheckedCreateInput>
    /**
     * In case the ClassName was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassNameUpdateInput, ClassNameUncheckedUpdateInput>
  }

  /**
   * ClassName delete
   */
  export type ClassNameDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassName
     */
    select?: ClassNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassName
     */
    omit?: ClassNameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassNameInclude<ExtArgs> | null
    /**
     * Filter which ClassName to delete.
     */
    where: ClassNameWhereUniqueInput
  }

  /**
   * ClassName deleteMany
   */
  export type ClassNameDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassNames to delete
     */
    where?: ClassNameWhereInput
    /**
     * Limit how many ClassNames to delete.
     */
    limit?: number
  }

  /**
   * ClassName without action
   */
  export type ClassNameDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassName
     */
    select?: ClassNameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassName
     */
    omit?: ClassNameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassNameInclude<ExtArgs> | null
  }


  /**
   * Model FunelPages
   */

  export type AggregateFunelPages = {
    _count: FunelPagesCountAggregateOutputType | null
    _avg: FunelPagesAvgAggregateOutputType | null
    _sum: FunelPagesSumAggregateOutputType | null
    _min: FunelPagesMinAggregateOutputType | null
    _max: FunelPagesMaxAggregateOutputType | null
  }

  export type FunelPagesAvgAggregateOutputType = {
    visits: number | null
    order: number | null
  }

  export type FunelPagesSumAggregateOutputType = {
    visits: number | null
    order: number | null
  }

  export type FunelPagesMinAggregateOutputType = {
    id: string | null
    name: string | null
    pathName: string | null
    createdAt: Date | null
    updatedAt: Date | null
    visits: number | null
    content: string | null
    order: number | null
    previewImage: string | null
    funnelId: string | null
  }

  export type FunelPagesMaxAggregateOutputType = {
    id: string | null
    name: string | null
    pathName: string | null
    createdAt: Date | null
    updatedAt: Date | null
    visits: number | null
    content: string | null
    order: number | null
    previewImage: string | null
    funnelId: string | null
  }

  export type FunelPagesCountAggregateOutputType = {
    id: number
    name: number
    pathName: number
    createdAt: number
    updatedAt: number
    visits: number
    content: number
    order: number
    previewImage: number
    funnelId: number
    _all: number
  }


  export type FunelPagesAvgAggregateInputType = {
    visits?: true
    order?: true
  }

  export type FunelPagesSumAggregateInputType = {
    visits?: true
    order?: true
  }

  export type FunelPagesMinAggregateInputType = {
    id?: true
    name?: true
    pathName?: true
    createdAt?: true
    updatedAt?: true
    visits?: true
    content?: true
    order?: true
    previewImage?: true
    funnelId?: true
  }

  export type FunelPagesMaxAggregateInputType = {
    id?: true
    name?: true
    pathName?: true
    createdAt?: true
    updatedAt?: true
    visits?: true
    content?: true
    order?: true
    previewImage?: true
    funnelId?: true
  }

  export type FunelPagesCountAggregateInputType = {
    id?: true
    name?: true
    pathName?: true
    createdAt?: true
    updatedAt?: true
    visits?: true
    content?: true
    order?: true
    previewImage?: true
    funnelId?: true
    _all?: true
  }

  export type FunelPagesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FunelPages to aggregate.
     */
    where?: FunelPagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FunelPages to fetch.
     */
    orderBy?: FunelPagesOrderByWithRelationInput | FunelPagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FunelPagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FunelPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FunelPages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FunelPages
    **/
    _count?: true | FunelPagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FunelPagesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FunelPagesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FunelPagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FunelPagesMaxAggregateInputType
  }

  export type GetFunelPagesAggregateType<T extends FunelPagesAggregateArgs> = {
        [P in keyof T & keyof AggregateFunelPages]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFunelPages[P]>
      : GetScalarType<T[P], AggregateFunelPages[P]>
  }




  export type FunelPagesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FunelPagesWhereInput
    orderBy?: FunelPagesOrderByWithAggregationInput | FunelPagesOrderByWithAggregationInput[]
    by: FunelPagesScalarFieldEnum[] | FunelPagesScalarFieldEnum
    having?: FunelPagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FunelPagesCountAggregateInputType | true
    _avg?: FunelPagesAvgAggregateInputType
    _sum?: FunelPagesSumAggregateInputType
    _min?: FunelPagesMinAggregateInputType
    _max?: FunelPagesMaxAggregateInputType
  }

  export type FunelPagesGroupByOutputType = {
    id: string
    name: string
    pathName: string
    createdAt: Date
    updatedAt: Date
    visits: number
    content: string | null
    order: number
    previewImage: string
    funnelId: string
    _count: FunelPagesCountAggregateOutputType | null
    _avg: FunelPagesAvgAggregateOutputType | null
    _sum: FunelPagesSumAggregateOutputType | null
    _min: FunelPagesMinAggregateOutputType | null
    _max: FunelPagesMaxAggregateOutputType | null
  }

  type GetFunelPagesGroupByPayload<T extends FunelPagesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FunelPagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FunelPagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FunelPagesGroupByOutputType[P]>
            : GetScalarType<T[P], FunelPagesGroupByOutputType[P]>
        }
      >
    >


  export type FunelPagesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    pathName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    visits?: boolean
    content?: boolean
    order?: boolean
    previewImage?: boolean
    funnelId?: boolean
    Funnel?: boolean | FunnelsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["funelPages"]>

  export type FunelPagesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    pathName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    visits?: boolean
    content?: boolean
    order?: boolean
    previewImage?: boolean
    funnelId?: boolean
    Funnel?: boolean | FunnelsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["funelPages"]>

  export type FunelPagesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    pathName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    visits?: boolean
    content?: boolean
    order?: boolean
    previewImage?: boolean
    funnelId?: boolean
    Funnel?: boolean | FunnelsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["funelPages"]>

  export type FunelPagesSelectScalar = {
    id?: boolean
    name?: boolean
    pathName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    visits?: boolean
    content?: boolean
    order?: boolean
    previewImage?: boolean
    funnelId?: boolean
  }

  export type FunelPagesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "pathName" | "createdAt" | "updatedAt" | "visits" | "content" | "order" | "previewImage" | "funnelId", ExtArgs["result"]["funelPages"]>
  export type FunelPagesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Funnel?: boolean | FunnelsDefaultArgs<ExtArgs>
  }
  export type FunelPagesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Funnel?: boolean | FunnelsDefaultArgs<ExtArgs>
  }
  export type FunelPagesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Funnel?: boolean | FunnelsDefaultArgs<ExtArgs>
  }

  export type $FunelPagesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FunelPages"
    objects: {
      Funnel: Prisma.$FunnelsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      pathName: string
      createdAt: Date
      updatedAt: Date
      visits: number
      content: string | null
      order: number
      previewImage: string
      funnelId: string
    }, ExtArgs["result"]["funelPages"]>
    composites: {}
  }

  type FunelPagesGetPayload<S extends boolean | null | undefined | FunelPagesDefaultArgs> = $Result.GetResult<Prisma.$FunelPagesPayload, S>

  type FunelPagesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FunelPagesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FunelPagesCountAggregateInputType | true
    }

  export interface FunelPagesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FunelPages'], meta: { name: 'FunelPages' } }
    /**
     * Find zero or one FunelPages that matches the filter.
     * @param {FunelPagesFindUniqueArgs} args - Arguments to find a FunelPages
     * @example
     * // Get one FunelPages
     * const funelPages = await prisma.funelPages.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FunelPagesFindUniqueArgs>(args: SelectSubset<T, FunelPagesFindUniqueArgs<ExtArgs>>): Prisma__FunelPagesClient<$Result.GetResult<Prisma.$FunelPagesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FunelPages that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FunelPagesFindUniqueOrThrowArgs} args - Arguments to find a FunelPages
     * @example
     * // Get one FunelPages
     * const funelPages = await prisma.funelPages.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FunelPagesFindUniqueOrThrowArgs>(args: SelectSubset<T, FunelPagesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FunelPagesClient<$Result.GetResult<Prisma.$FunelPagesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FunelPages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunelPagesFindFirstArgs} args - Arguments to find a FunelPages
     * @example
     * // Get one FunelPages
     * const funelPages = await prisma.funelPages.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FunelPagesFindFirstArgs>(args?: SelectSubset<T, FunelPagesFindFirstArgs<ExtArgs>>): Prisma__FunelPagesClient<$Result.GetResult<Prisma.$FunelPagesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FunelPages that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunelPagesFindFirstOrThrowArgs} args - Arguments to find a FunelPages
     * @example
     * // Get one FunelPages
     * const funelPages = await prisma.funelPages.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FunelPagesFindFirstOrThrowArgs>(args?: SelectSubset<T, FunelPagesFindFirstOrThrowArgs<ExtArgs>>): Prisma__FunelPagesClient<$Result.GetResult<Prisma.$FunelPagesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FunelPages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunelPagesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FunelPages
     * const funelPages = await prisma.funelPages.findMany()
     * 
     * // Get first 10 FunelPages
     * const funelPages = await prisma.funelPages.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const funelPagesWithIdOnly = await prisma.funelPages.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FunelPagesFindManyArgs>(args?: SelectSubset<T, FunelPagesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FunelPagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FunelPages.
     * @param {FunelPagesCreateArgs} args - Arguments to create a FunelPages.
     * @example
     * // Create one FunelPages
     * const FunelPages = await prisma.funelPages.create({
     *   data: {
     *     // ... data to create a FunelPages
     *   }
     * })
     * 
     */
    create<T extends FunelPagesCreateArgs>(args: SelectSubset<T, FunelPagesCreateArgs<ExtArgs>>): Prisma__FunelPagesClient<$Result.GetResult<Prisma.$FunelPagesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FunelPages.
     * @param {FunelPagesCreateManyArgs} args - Arguments to create many FunelPages.
     * @example
     * // Create many FunelPages
     * const funelPages = await prisma.funelPages.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FunelPagesCreateManyArgs>(args?: SelectSubset<T, FunelPagesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FunelPages and returns the data saved in the database.
     * @param {FunelPagesCreateManyAndReturnArgs} args - Arguments to create many FunelPages.
     * @example
     * // Create many FunelPages
     * const funelPages = await prisma.funelPages.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FunelPages and only return the `id`
     * const funelPagesWithIdOnly = await prisma.funelPages.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FunelPagesCreateManyAndReturnArgs>(args?: SelectSubset<T, FunelPagesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FunelPagesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FunelPages.
     * @param {FunelPagesDeleteArgs} args - Arguments to delete one FunelPages.
     * @example
     * // Delete one FunelPages
     * const FunelPages = await prisma.funelPages.delete({
     *   where: {
     *     // ... filter to delete one FunelPages
     *   }
     * })
     * 
     */
    delete<T extends FunelPagesDeleteArgs>(args: SelectSubset<T, FunelPagesDeleteArgs<ExtArgs>>): Prisma__FunelPagesClient<$Result.GetResult<Prisma.$FunelPagesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FunelPages.
     * @param {FunelPagesUpdateArgs} args - Arguments to update one FunelPages.
     * @example
     * // Update one FunelPages
     * const funelPages = await prisma.funelPages.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FunelPagesUpdateArgs>(args: SelectSubset<T, FunelPagesUpdateArgs<ExtArgs>>): Prisma__FunelPagesClient<$Result.GetResult<Prisma.$FunelPagesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FunelPages.
     * @param {FunelPagesDeleteManyArgs} args - Arguments to filter FunelPages to delete.
     * @example
     * // Delete a few FunelPages
     * const { count } = await prisma.funelPages.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FunelPagesDeleteManyArgs>(args?: SelectSubset<T, FunelPagesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FunelPages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunelPagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FunelPages
     * const funelPages = await prisma.funelPages.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FunelPagesUpdateManyArgs>(args: SelectSubset<T, FunelPagesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FunelPages and returns the data updated in the database.
     * @param {FunelPagesUpdateManyAndReturnArgs} args - Arguments to update many FunelPages.
     * @example
     * // Update many FunelPages
     * const funelPages = await prisma.funelPages.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FunelPages and only return the `id`
     * const funelPagesWithIdOnly = await prisma.funelPages.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FunelPagesUpdateManyAndReturnArgs>(args: SelectSubset<T, FunelPagesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FunelPagesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FunelPages.
     * @param {FunelPagesUpsertArgs} args - Arguments to update or create a FunelPages.
     * @example
     * // Update or create a FunelPages
     * const funelPages = await prisma.funelPages.upsert({
     *   create: {
     *     // ... data to create a FunelPages
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FunelPages we want to update
     *   }
     * })
     */
    upsert<T extends FunelPagesUpsertArgs>(args: SelectSubset<T, FunelPagesUpsertArgs<ExtArgs>>): Prisma__FunelPagesClient<$Result.GetResult<Prisma.$FunelPagesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FunelPages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunelPagesCountArgs} args - Arguments to filter FunelPages to count.
     * @example
     * // Count the number of FunelPages
     * const count = await prisma.funelPages.count({
     *   where: {
     *     // ... the filter for the FunelPages we want to count
     *   }
     * })
    **/
    count<T extends FunelPagesCountArgs>(
      args?: Subset<T, FunelPagesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FunelPagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FunelPages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunelPagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FunelPagesAggregateArgs>(args: Subset<T, FunelPagesAggregateArgs>): Prisma.PrismaPromise<GetFunelPagesAggregateType<T>>

    /**
     * Group by FunelPages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FunelPagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FunelPagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FunelPagesGroupByArgs['orderBy'] }
        : { orderBy?: FunelPagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FunelPagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFunelPagesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FunelPages model
   */
  readonly fields: FunelPagesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FunelPages.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FunelPagesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Funnel<T extends FunnelsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FunnelsDefaultArgs<ExtArgs>>): Prisma__FunnelsClient<$Result.GetResult<Prisma.$FunnelsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FunelPages model
   */
  interface FunelPagesFieldRefs {
    readonly id: FieldRef<"FunelPages", 'String'>
    readonly name: FieldRef<"FunelPages", 'String'>
    readonly pathName: FieldRef<"FunelPages", 'String'>
    readonly createdAt: FieldRef<"FunelPages", 'DateTime'>
    readonly updatedAt: FieldRef<"FunelPages", 'DateTime'>
    readonly visits: FieldRef<"FunelPages", 'Int'>
    readonly content: FieldRef<"FunelPages", 'String'>
    readonly order: FieldRef<"FunelPages", 'Int'>
    readonly previewImage: FieldRef<"FunelPages", 'String'>
    readonly funnelId: FieldRef<"FunelPages", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FunelPages findUnique
   */
  export type FunelPagesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunelPages
     */
    select?: FunelPagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FunelPages
     */
    omit?: FunelPagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunelPagesInclude<ExtArgs> | null
    /**
     * Filter, which FunelPages to fetch.
     */
    where: FunelPagesWhereUniqueInput
  }

  /**
   * FunelPages findUniqueOrThrow
   */
  export type FunelPagesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunelPages
     */
    select?: FunelPagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FunelPages
     */
    omit?: FunelPagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunelPagesInclude<ExtArgs> | null
    /**
     * Filter, which FunelPages to fetch.
     */
    where: FunelPagesWhereUniqueInput
  }

  /**
   * FunelPages findFirst
   */
  export type FunelPagesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunelPages
     */
    select?: FunelPagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FunelPages
     */
    omit?: FunelPagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunelPagesInclude<ExtArgs> | null
    /**
     * Filter, which FunelPages to fetch.
     */
    where?: FunelPagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FunelPages to fetch.
     */
    orderBy?: FunelPagesOrderByWithRelationInput | FunelPagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FunelPages.
     */
    cursor?: FunelPagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FunelPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FunelPages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FunelPages.
     */
    distinct?: FunelPagesScalarFieldEnum | FunelPagesScalarFieldEnum[]
  }

  /**
   * FunelPages findFirstOrThrow
   */
  export type FunelPagesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunelPages
     */
    select?: FunelPagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FunelPages
     */
    omit?: FunelPagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunelPagesInclude<ExtArgs> | null
    /**
     * Filter, which FunelPages to fetch.
     */
    where?: FunelPagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FunelPages to fetch.
     */
    orderBy?: FunelPagesOrderByWithRelationInput | FunelPagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FunelPages.
     */
    cursor?: FunelPagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FunelPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FunelPages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FunelPages.
     */
    distinct?: FunelPagesScalarFieldEnum | FunelPagesScalarFieldEnum[]
  }

  /**
   * FunelPages findMany
   */
  export type FunelPagesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunelPages
     */
    select?: FunelPagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FunelPages
     */
    omit?: FunelPagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunelPagesInclude<ExtArgs> | null
    /**
     * Filter, which FunelPages to fetch.
     */
    where?: FunelPagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FunelPages to fetch.
     */
    orderBy?: FunelPagesOrderByWithRelationInput | FunelPagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FunelPages.
     */
    cursor?: FunelPagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FunelPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FunelPages.
     */
    skip?: number
    distinct?: FunelPagesScalarFieldEnum | FunelPagesScalarFieldEnum[]
  }

  /**
   * FunelPages create
   */
  export type FunelPagesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunelPages
     */
    select?: FunelPagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FunelPages
     */
    omit?: FunelPagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunelPagesInclude<ExtArgs> | null
    /**
     * The data needed to create a FunelPages.
     */
    data: XOR<FunelPagesCreateInput, FunelPagesUncheckedCreateInput>
  }

  /**
   * FunelPages createMany
   */
  export type FunelPagesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FunelPages.
     */
    data: FunelPagesCreateManyInput | FunelPagesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FunelPages createManyAndReturn
   */
  export type FunelPagesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunelPages
     */
    select?: FunelPagesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FunelPages
     */
    omit?: FunelPagesOmit<ExtArgs> | null
    /**
     * The data used to create many FunelPages.
     */
    data: FunelPagesCreateManyInput | FunelPagesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunelPagesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FunelPages update
   */
  export type FunelPagesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunelPages
     */
    select?: FunelPagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FunelPages
     */
    omit?: FunelPagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunelPagesInclude<ExtArgs> | null
    /**
     * The data needed to update a FunelPages.
     */
    data: XOR<FunelPagesUpdateInput, FunelPagesUncheckedUpdateInput>
    /**
     * Choose, which FunelPages to update.
     */
    where: FunelPagesWhereUniqueInput
  }

  /**
   * FunelPages updateMany
   */
  export type FunelPagesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FunelPages.
     */
    data: XOR<FunelPagesUpdateManyMutationInput, FunelPagesUncheckedUpdateManyInput>
    /**
     * Filter which FunelPages to update
     */
    where?: FunelPagesWhereInput
    /**
     * Limit how many FunelPages to update.
     */
    limit?: number
  }

  /**
   * FunelPages updateManyAndReturn
   */
  export type FunelPagesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunelPages
     */
    select?: FunelPagesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FunelPages
     */
    omit?: FunelPagesOmit<ExtArgs> | null
    /**
     * The data used to update FunelPages.
     */
    data: XOR<FunelPagesUpdateManyMutationInput, FunelPagesUncheckedUpdateManyInput>
    /**
     * Filter which FunelPages to update
     */
    where?: FunelPagesWhereInput
    /**
     * Limit how many FunelPages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunelPagesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FunelPages upsert
   */
  export type FunelPagesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunelPages
     */
    select?: FunelPagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FunelPages
     */
    omit?: FunelPagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunelPagesInclude<ExtArgs> | null
    /**
     * The filter to search for the FunelPages to update in case it exists.
     */
    where: FunelPagesWhereUniqueInput
    /**
     * In case the FunelPages found by the `where` argument doesn't exist, create a new FunelPages with this data.
     */
    create: XOR<FunelPagesCreateInput, FunelPagesUncheckedCreateInput>
    /**
     * In case the FunelPages was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FunelPagesUpdateInput, FunelPagesUncheckedUpdateInput>
  }

  /**
   * FunelPages delete
   */
  export type FunelPagesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunelPages
     */
    select?: FunelPagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FunelPages
     */
    omit?: FunelPagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunelPagesInclude<ExtArgs> | null
    /**
     * Filter which FunelPages to delete.
     */
    where: FunelPagesWhereUniqueInput
  }

  /**
   * FunelPages deleteMany
   */
  export type FunelPagesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FunelPages to delete
     */
    where?: FunelPagesWhereInput
    /**
     * Limit how many FunelPages to delete.
     */
    limit?: number
  }

  /**
   * FunelPages without action
   */
  export type FunelPagesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FunelPages
     */
    select?: FunelPagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FunelPages
     */
    omit?: FunelPagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FunelPagesInclude<ExtArgs> | null
  }


  /**
   * Model AddOns
   */

  export type AggregateAddOns = {
    _count: AddOnsCountAggregateOutputType | null
    _min: AddOnsMinAggregateOutputType | null
    _max: AddOnsMaxAggregateOutputType | null
  }

  export type AddOnsMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    active: boolean | null
    priceId: string | null
    agencyId: string | null
  }

  export type AddOnsMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    active: boolean | null
    priceId: string | null
    agencyId: string | null
  }

  export type AddOnsCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    name: number
    active: number
    priceId: number
    agencyId: number
    _all: number
  }


  export type AddOnsMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    active?: true
    priceId?: true
    agencyId?: true
  }

  export type AddOnsMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    active?: true
    priceId?: true
    agencyId?: true
  }

  export type AddOnsCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    active?: true
    priceId?: true
    agencyId?: true
    _all?: true
  }

  export type AddOnsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AddOns to aggregate.
     */
    where?: AddOnsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddOns to fetch.
     */
    orderBy?: AddOnsOrderByWithRelationInput | AddOnsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AddOnsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddOns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddOns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AddOns
    **/
    _count?: true | AddOnsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddOnsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddOnsMaxAggregateInputType
  }

  export type GetAddOnsAggregateType<T extends AddOnsAggregateArgs> = {
        [P in keyof T & keyof AggregateAddOns]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddOns[P]>
      : GetScalarType<T[P], AggregateAddOns[P]>
  }




  export type AddOnsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddOnsWhereInput
    orderBy?: AddOnsOrderByWithAggregationInput | AddOnsOrderByWithAggregationInput[]
    by: AddOnsScalarFieldEnum[] | AddOnsScalarFieldEnum
    having?: AddOnsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddOnsCountAggregateInputType | true
    _min?: AddOnsMinAggregateInputType
    _max?: AddOnsMaxAggregateInputType
  }

  export type AddOnsGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    name: string
    active: boolean
    priceId: string
    agencyId: string | null
    _count: AddOnsCountAggregateOutputType | null
    _min: AddOnsMinAggregateOutputType | null
    _max: AddOnsMaxAggregateOutputType | null
  }

  type GetAddOnsGroupByPayload<T extends AddOnsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AddOnsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddOnsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddOnsGroupByOutputType[P]>
            : GetScalarType<T[P], AddOnsGroupByOutputType[P]>
        }
      >
    >


  export type AddOnsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    active?: boolean
    priceId?: boolean
    agencyId?: boolean
    Agency?: boolean | AddOns$AgencyArgs<ExtArgs>
  }, ExtArgs["result"]["addOns"]>

  export type AddOnsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    active?: boolean
    priceId?: boolean
    agencyId?: boolean
    Agency?: boolean | AddOns$AgencyArgs<ExtArgs>
  }, ExtArgs["result"]["addOns"]>

  export type AddOnsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    active?: boolean
    priceId?: boolean
    agencyId?: boolean
    Agency?: boolean | AddOns$AgencyArgs<ExtArgs>
  }, ExtArgs["result"]["addOns"]>

  export type AddOnsSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    active?: boolean
    priceId?: boolean
    agencyId?: boolean
  }

  export type AddOnsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "name" | "active" | "priceId" | "agencyId", ExtArgs["result"]["addOns"]>
  export type AddOnsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Agency?: boolean | AddOns$AgencyArgs<ExtArgs>
  }
  export type AddOnsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Agency?: boolean | AddOns$AgencyArgs<ExtArgs>
  }
  export type AddOnsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Agency?: boolean | AddOns$AgencyArgs<ExtArgs>
  }

  export type $AddOnsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AddOns"
    objects: {
      Agency: Prisma.$AgencyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      name: string
      active: boolean
      priceId: string
      agencyId: string | null
    }, ExtArgs["result"]["addOns"]>
    composites: {}
  }

  type AddOnsGetPayload<S extends boolean | null | undefined | AddOnsDefaultArgs> = $Result.GetResult<Prisma.$AddOnsPayload, S>

  type AddOnsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AddOnsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AddOnsCountAggregateInputType | true
    }

  export interface AddOnsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AddOns'], meta: { name: 'AddOns' } }
    /**
     * Find zero or one AddOns that matches the filter.
     * @param {AddOnsFindUniqueArgs} args - Arguments to find a AddOns
     * @example
     * // Get one AddOns
     * const addOns = await prisma.addOns.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AddOnsFindUniqueArgs>(args: SelectSubset<T, AddOnsFindUniqueArgs<ExtArgs>>): Prisma__AddOnsClient<$Result.GetResult<Prisma.$AddOnsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AddOns that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AddOnsFindUniqueOrThrowArgs} args - Arguments to find a AddOns
     * @example
     * // Get one AddOns
     * const addOns = await prisma.addOns.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AddOnsFindUniqueOrThrowArgs>(args: SelectSubset<T, AddOnsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AddOnsClient<$Result.GetResult<Prisma.$AddOnsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AddOns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddOnsFindFirstArgs} args - Arguments to find a AddOns
     * @example
     * // Get one AddOns
     * const addOns = await prisma.addOns.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AddOnsFindFirstArgs>(args?: SelectSubset<T, AddOnsFindFirstArgs<ExtArgs>>): Prisma__AddOnsClient<$Result.GetResult<Prisma.$AddOnsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AddOns that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddOnsFindFirstOrThrowArgs} args - Arguments to find a AddOns
     * @example
     * // Get one AddOns
     * const addOns = await prisma.addOns.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AddOnsFindFirstOrThrowArgs>(args?: SelectSubset<T, AddOnsFindFirstOrThrowArgs<ExtArgs>>): Prisma__AddOnsClient<$Result.GetResult<Prisma.$AddOnsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AddOns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddOnsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AddOns
     * const addOns = await prisma.addOns.findMany()
     * 
     * // Get first 10 AddOns
     * const addOns = await prisma.addOns.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const addOnsWithIdOnly = await prisma.addOns.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AddOnsFindManyArgs>(args?: SelectSubset<T, AddOnsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddOnsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AddOns.
     * @param {AddOnsCreateArgs} args - Arguments to create a AddOns.
     * @example
     * // Create one AddOns
     * const AddOns = await prisma.addOns.create({
     *   data: {
     *     // ... data to create a AddOns
     *   }
     * })
     * 
     */
    create<T extends AddOnsCreateArgs>(args: SelectSubset<T, AddOnsCreateArgs<ExtArgs>>): Prisma__AddOnsClient<$Result.GetResult<Prisma.$AddOnsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AddOns.
     * @param {AddOnsCreateManyArgs} args - Arguments to create many AddOns.
     * @example
     * // Create many AddOns
     * const addOns = await prisma.addOns.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AddOnsCreateManyArgs>(args?: SelectSubset<T, AddOnsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AddOns and returns the data saved in the database.
     * @param {AddOnsCreateManyAndReturnArgs} args - Arguments to create many AddOns.
     * @example
     * // Create many AddOns
     * const addOns = await prisma.addOns.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AddOns and only return the `id`
     * const addOnsWithIdOnly = await prisma.addOns.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AddOnsCreateManyAndReturnArgs>(args?: SelectSubset<T, AddOnsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddOnsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AddOns.
     * @param {AddOnsDeleteArgs} args - Arguments to delete one AddOns.
     * @example
     * // Delete one AddOns
     * const AddOns = await prisma.addOns.delete({
     *   where: {
     *     // ... filter to delete one AddOns
     *   }
     * })
     * 
     */
    delete<T extends AddOnsDeleteArgs>(args: SelectSubset<T, AddOnsDeleteArgs<ExtArgs>>): Prisma__AddOnsClient<$Result.GetResult<Prisma.$AddOnsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AddOns.
     * @param {AddOnsUpdateArgs} args - Arguments to update one AddOns.
     * @example
     * // Update one AddOns
     * const addOns = await prisma.addOns.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AddOnsUpdateArgs>(args: SelectSubset<T, AddOnsUpdateArgs<ExtArgs>>): Prisma__AddOnsClient<$Result.GetResult<Prisma.$AddOnsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AddOns.
     * @param {AddOnsDeleteManyArgs} args - Arguments to filter AddOns to delete.
     * @example
     * // Delete a few AddOns
     * const { count } = await prisma.addOns.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AddOnsDeleteManyArgs>(args?: SelectSubset<T, AddOnsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AddOns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddOnsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AddOns
     * const addOns = await prisma.addOns.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AddOnsUpdateManyArgs>(args: SelectSubset<T, AddOnsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AddOns and returns the data updated in the database.
     * @param {AddOnsUpdateManyAndReturnArgs} args - Arguments to update many AddOns.
     * @example
     * // Update many AddOns
     * const addOns = await prisma.addOns.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AddOns and only return the `id`
     * const addOnsWithIdOnly = await prisma.addOns.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AddOnsUpdateManyAndReturnArgs>(args: SelectSubset<T, AddOnsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddOnsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AddOns.
     * @param {AddOnsUpsertArgs} args - Arguments to update or create a AddOns.
     * @example
     * // Update or create a AddOns
     * const addOns = await prisma.addOns.upsert({
     *   create: {
     *     // ... data to create a AddOns
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AddOns we want to update
     *   }
     * })
     */
    upsert<T extends AddOnsUpsertArgs>(args: SelectSubset<T, AddOnsUpsertArgs<ExtArgs>>): Prisma__AddOnsClient<$Result.GetResult<Prisma.$AddOnsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AddOns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddOnsCountArgs} args - Arguments to filter AddOns to count.
     * @example
     * // Count the number of AddOns
     * const count = await prisma.addOns.count({
     *   where: {
     *     // ... the filter for the AddOns we want to count
     *   }
     * })
    **/
    count<T extends AddOnsCountArgs>(
      args?: Subset<T, AddOnsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddOnsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AddOns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddOnsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddOnsAggregateArgs>(args: Subset<T, AddOnsAggregateArgs>): Prisma.PrismaPromise<GetAddOnsAggregateType<T>>

    /**
     * Group by AddOns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddOnsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddOnsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddOnsGroupByArgs['orderBy'] }
        : { orderBy?: AddOnsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddOnsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddOnsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AddOns model
   */
  readonly fields: AddOnsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AddOns.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AddOnsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Agency<T extends AddOns$AgencyArgs<ExtArgs> = {}>(args?: Subset<T, AddOns$AgencyArgs<ExtArgs>>): Prisma__AgencyClient<$Result.GetResult<Prisma.$AgencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AddOns model
   */
  interface AddOnsFieldRefs {
    readonly id: FieldRef<"AddOns", 'String'>
    readonly createdAt: FieldRef<"AddOns", 'DateTime'>
    readonly updatedAt: FieldRef<"AddOns", 'DateTime'>
    readonly name: FieldRef<"AddOns", 'String'>
    readonly active: FieldRef<"AddOns", 'Boolean'>
    readonly priceId: FieldRef<"AddOns", 'String'>
    readonly agencyId: FieldRef<"AddOns", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AddOns findUnique
   */
  export type AddOnsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOns
     */
    select?: AddOnsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddOns
     */
    omit?: AddOnsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddOnsInclude<ExtArgs> | null
    /**
     * Filter, which AddOns to fetch.
     */
    where: AddOnsWhereUniqueInput
  }

  /**
   * AddOns findUniqueOrThrow
   */
  export type AddOnsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOns
     */
    select?: AddOnsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddOns
     */
    omit?: AddOnsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddOnsInclude<ExtArgs> | null
    /**
     * Filter, which AddOns to fetch.
     */
    where: AddOnsWhereUniqueInput
  }

  /**
   * AddOns findFirst
   */
  export type AddOnsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOns
     */
    select?: AddOnsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddOns
     */
    omit?: AddOnsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddOnsInclude<ExtArgs> | null
    /**
     * Filter, which AddOns to fetch.
     */
    where?: AddOnsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddOns to fetch.
     */
    orderBy?: AddOnsOrderByWithRelationInput | AddOnsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AddOns.
     */
    cursor?: AddOnsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddOns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddOns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AddOns.
     */
    distinct?: AddOnsScalarFieldEnum | AddOnsScalarFieldEnum[]
  }

  /**
   * AddOns findFirstOrThrow
   */
  export type AddOnsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOns
     */
    select?: AddOnsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddOns
     */
    omit?: AddOnsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddOnsInclude<ExtArgs> | null
    /**
     * Filter, which AddOns to fetch.
     */
    where?: AddOnsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddOns to fetch.
     */
    orderBy?: AddOnsOrderByWithRelationInput | AddOnsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AddOns.
     */
    cursor?: AddOnsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddOns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddOns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AddOns.
     */
    distinct?: AddOnsScalarFieldEnum | AddOnsScalarFieldEnum[]
  }

  /**
   * AddOns findMany
   */
  export type AddOnsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOns
     */
    select?: AddOnsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddOns
     */
    omit?: AddOnsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddOnsInclude<ExtArgs> | null
    /**
     * Filter, which AddOns to fetch.
     */
    where?: AddOnsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AddOns to fetch.
     */
    orderBy?: AddOnsOrderByWithRelationInput | AddOnsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AddOns.
     */
    cursor?: AddOnsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AddOns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AddOns.
     */
    skip?: number
    distinct?: AddOnsScalarFieldEnum | AddOnsScalarFieldEnum[]
  }

  /**
   * AddOns create
   */
  export type AddOnsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOns
     */
    select?: AddOnsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddOns
     */
    omit?: AddOnsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddOnsInclude<ExtArgs> | null
    /**
     * The data needed to create a AddOns.
     */
    data: XOR<AddOnsCreateInput, AddOnsUncheckedCreateInput>
  }

  /**
   * AddOns createMany
   */
  export type AddOnsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AddOns.
     */
    data: AddOnsCreateManyInput | AddOnsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AddOns createManyAndReturn
   */
  export type AddOnsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOns
     */
    select?: AddOnsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AddOns
     */
    omit?: AddOnsOmit<ExtArgs> | null
    /**
     * The data used to create many AddOns.
     */
    data: AddOnsCreateManyInput | AddOnsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddOnsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AddOns update
   */
  export type AddOnsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOns
     */
    select?: AddOnsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddOns
     */
    omit?: AddOnsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddOnsInclude<ExtArgs> | null
    /**
     * The data needed to update a AddOns.
     */
    data: XOR<AddOnsUpdateInput, AddOnsUncheckedUpdateInput>
    /**
     * Choose, which AddOns to update.
     */
    where: AddOnsWhereUniqueInput
  }

  /**
   * AddOns updateMany
   */
  export type AddOnsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AddOns.
     */
    data: XOR<AddOnsUpdateManyMutationInput, AddOnsUncheckedUpdateManyInput>
    /**
     * Filter which AddOns to update
     */
    where?: AddOnsWhereInput
    /**
     * Limit how many AddOns to update.
     */
    limit?: number
  }

  /**
   * AddOns updateManyAndReturn
   */
  export type AddOnsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOns
     */
    select?: AddOnsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AddOns
     */
    omit?: AddOnsOmit<ExtArgs> | null
    /**
     * The data used to update AddOns.
     */
    data: XOR<AddOnsUpdateManyMutationInput, AddOnsUncheckedUpdateManyInput>
    /**
     * Filter which AddOns to update
     */
    where?: AddOnsWhereInput
    /**
     * Limit how many AddOns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddOnsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AddOns upsert
   */
  export type AddOnsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOns
     */
    select?: AddOnsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddOns
     */
    omit?: AddOnsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddOnsInclude<ExtArgs> | null
    /**
     * The filter to search for the AddOns to update in case it exists.
     */
    where: AddOnsWhereUniqueInput
    /**
     * In case the AddOns found by the `where` argument doesn't exist, create a new AddOns with this data.
     */
    create: XOR<AddOnsCreateInput, AddOnsUncheckedCreateInput>
    /**
     * In case the AddOns was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AddOnsUpdateInput, AddOnsUncheckedUpdateInput>
  }

  /**
   * AddOns delete
   */
  export type AddOnsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOns
     */
    select?: AddOnsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddOns
     */
    omit?: AddOnsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddOnsInclude<ExtArgs> | null
    /**
     * Filter which AddOns to delete.
     */
    where: AddOnsWhereUniqueInput
  }

  /**
   * AddOns deleteMany
   */
  export type AddOnsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AddOns to delete
     */
    where?: AddOnsWhereInput
    /**
     * Limit how many AddOns to delete.
     */
    limit?: number
  }

  /**
   * AddOns.Agency
   */
  export type AddOns$AgencyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agency
     */
    select?: AgencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agency
     */
    omit?: AgencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgencyInclude<ExtArgs> | null
    where?: AgencyWhereInput
  }

  /**
   * AddOns without action
   */
  export type AddOnsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddOns
     */
    select?: AddOnsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AddOns
     */
    omit?: AddOnsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddOnsInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UsersScalarFieldEnum: {
    id: 'id',
    name: 'name',
    avatarUrl: 'avatarUrl',
    email: 'email',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    role: 'role',
    agencyId: 'agencyId'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const PermissionsScalarFieldEnum: {
    id: 'id',
    email: 'email',
    subAccontId: 'subAccontId',
    access: 'access'
  };

  export type PermissionsScalarFieldEnum = (typeof PermissionsScalarFieldEnum)[keyof typeof PermissionsScalarFieldEnum]


  export const AgencyScalarFieldEnum: {
    id: 'id',
    connectAccountId: 'connectAccountId',
    customerId: 'customerId',
    name: 'name',
    agencyLogo: 'agencyLogo',
    companyEmail: 'companyEmail',
    companyPhone: 'companyPhone',
    whiteLabel: 'whiteLabel',
    address: 'address',
    city: 'city',
    zipCode: 'zipCode',
    state: 'state',
    country: 'country',
    goal: 'goal',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AgencyScalarFieldEnum = (typeof AgencyScalarFieldEnum)[keyof typeof AgencyScalarFieldEnum]


  export const AgencySidebarOptionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    link: 'link',
    icon: 'icon',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    agencyId: 'agencyId',
    subAccountId: 'subAccountId'
  };

  export type AgencySidebarOptionScalarFieldEnum = (typeof AgencySidebarOptionScalarFieldEnum)[keyof typeof AgencySidebarOptionScalarFieldEnum]


  export const SubAccountsScalarFieldEnum: {
    id: 'id',
    connectAccountId: 'connectAccountId',
    name: 'name',
    subAcctountLogo: 'subAcctountLogo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    companyEmail: 'companyEmail',
    companyPhone: 'companyPhone',
    goal: 'goal',
    address: 'address',
    city: 'city',
    zipCode: 'zipCode',
    state: 'state',
    country: 'country',
    agencyId: 'agencyId'
  };

  export type SubAccountsScalarFieldEnum = (typeof SubAccountsScalarFieldEnum)[keyof typeof SubAccountsScalarFieldEnum]


  export const PipelinesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    subAccountId: 'subAccountId'
  };

  export type PipelinesScalarFieldEnum = (typeof PipelinesScalarFieldEnum)[keyof typeof PipelinesScalarFieldEnum]


  export const TriggersScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    subAccountId: 'subAccountId'
  };

  export type TriggersScalarFieldEnum = (typeof TriggersScalarFieldEnum)[keyof typeof TriggersScalarFieldEnum]


  export const AutomationsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    triggerId: 'triggerId',
    published: 'published',
    subAccountId: 'subAccountId'
  };

  export type AutomationsScalarFieldEnum = (typeof AutomationsScalarFieldEnum)[keyof typeof AutomationsScalarFieldEnum]


  export const AutomationInstanceScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    automationId: 'automationId',
    active: 'active'
  };

  export type AutomationInstanceScalarFieldEnum = (typeof AutomationInstanceScalarFieldEnum)[keyof typeof AutomationInstanceScalarFieldEnum]


  export const ActionsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    automatedId: 'automatedId',
    order: 'order',
    laneId: 'laneId'
  };

  export type ActionsScalarFieldEnum = (typeof ActionsScalarFieldEnum)[keyof typeof ActionsScalarFieldEnum]


  export const ContactsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    subAccountId: 'subAccountId'
  };

  export type ContactsScalarFieldEnum = (typeof ContactsScalarFieldEnum)[keyof typeof ContactsScalarFieldEnum]


  export const MediaScalarFieldEnum: {
    id: 'id',
    type: 'type',
    name: 'name',
    link: 'link',
    subAccountId: 'subAccountId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MediaScalarFieldEnum = (typeof MediaScalarFieldEnum)[keyof typeof MediaScalarFieldEnum]


  export const LaneScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    pipelineId: 'pipelineId',
    order: 'order'
  };

  export type LaneScalarFieldEnum = (typeof LaneScalarFieldEnum)[keyof typeof LaneScalarFieldEnum]


  export const TicketsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lineId: 'lineId',
    order: 'order',
    value: 'value',
    description: 'description',
    userId: 'userId',
    contactId: 'contactId'
  };

  export type TicketsScalarFieldEnum = (typeof TicketsScalarFieldEnum)[keyof typeof TicketsScalarFieldEnum]


  export const TagsScalarFieldEnum: {
    id: 'id',
    nane: 'nane',
    color: 'color',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    subAccountId: 'subAccountId'
  };

  export type TagsScalarFieldEnum = (typeof TagsScalarFieldEnum)[keyof typeof TagsScalarFieldEnum]


  export const SubAccountSidebarOptionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    link: 'link',
    icon: 'icon',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    subAccountId: 'subAccountId',
    subAccount: 'subAccount'
  };

  export type SubAccountSidebarOptionScalarFieldEnum = (typeof SubAccountSidebarOptionScalarFieldEnum)[keyof typeof SubAccountSidebarOptionScalarFieldEnum]


  export const InvitationsScalarFieldEnum: {
    id: 'id',
    email: 'email',
    agencyId: 'agencyId',
    status: 'status',
    role: 'role'
  };

  export type InvitationsScalarFieldEnum = (typeof InvitationsScalarFieldEnum)[keyof typeof InvitationsScalarFieldEnum]


  export const FunnelsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    description: 'description',
    published: 'published',
    subDomainName: 'subDomainName',
    favicon: 'favicon',
    subAccountId: 'subAccountId',
    liveProducts: 'liveProducts'
  };

  export type FunnelsScalarFieldEnum = (typeof FunnelsScalarFieldEnum)[keyof typeof FunnelsScalarFieldEnum]


  export const NotificationsScalarFieldEnum: {
    id: 'id',
    notification: 'notification',
    agencyId: 'agencyId',
    subAccountId: 'subAccountId',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationsScalarFieldEnum = (typeof NotificationsScalarFieldEnum)[keyof typeof NotificationsScalarFieldEnum]


  export const SubscriptionsScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    plan: 'plan',
    price: 'price',
    active: 'active',
    priceId: 'priceId',
    customerId: 'customerId',
    currentPeriodEndDate: 'currentPeriodEndDate',
    subscriptionId: 'subscriptionId',
    agencyId: 'agencyId'
  };

  export type SubscriptionsScalarFieldEnum = (typeof SubscriptionsScalarFieldEnum)[keyof typeof SubscriptionsScalarFieldEnum]


  export const ClassNameScalarFieldEnum: {
    id: 'id',
    name: 'name',
    color: 'color',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    funnelId: 'funnelId',
    customData: 'customData'
  };

  export type ClassNameScalarFieldEnum = (typeof ClassNameScalarFieldEnum)[keyof typeof ClassNameScalarFieldEnum]


  export const FunelPagesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    pathName: 'pathName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    visits: 'visits',
    content: 'content',
    order: 'order',
    previewImage: 'previewImage',
    funnelId: 'funnelId'
  };

  export type FunelPagesScalarFieldEnum = (typeof FunelPagesScalarFieldEnum)[keyof typeof FunelPagesScalarFieldEnum]


  export const AddOnsScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    name: 'name',
    active: 'active',
    priceId: 'priceId',
    agencyId: 'agencyId'
  };

  export type AddOnsScalarFieldEnum = (typeof AddOnsScalarFieldEnum)[keyof typeof AddOnsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Icon'
   */
  export type EnumIconFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Icon'>
    


  /**
   * Reference to a field of type 'Icon[]'
   */
  export type ListEnumIconFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Icon[]'>
    


  /**
   * Reference to a field of type 'TriggerTypes'
   */
  export type EnumTriggerTypesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TriggerTypes'>
    


  /**
   * Reference to a field of type 'TriggerTypes[]'
   */
  export type ListEnumTriggerTypesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TriggerTypes[]'>
    


  /**
   * Reference to a field of type 'ActionType'
   */
  export type EnumActionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActionType'>
    


  /**
   * Reference to a field of type 'ActionType[]'
   */
  export type ListEnumActionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActionType[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'InvitationStatus'
   */
  export type EnumInvitationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvitationStatus'>
    


  /**
   * Reference to a field of type 'InvitationStatus[]'
   */
  export type ListEnumInvitationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvitationStatus[]'>
    


  /**
   * Reference to a field of type 'Plans'
   */
  export type EnumPlansFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Plans'>
    


  /**
   * Reference to a field of type 'Plans[]'
   */
  export type ListEnumPlansFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Plans[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UsersWhereInput = {
    AND?: UsersWhereInput | UsersWhereInput[]
    OR?: UsersWhereInput[]
    NOT?: UsersWhereInput | UsersWhereInput[]
    id?: StringFilter<"Users"> | string
    name?: StringFilter<"Users"> | string
    avatarUrl?: StringFilter<"Users"> | string
    email?: StringFilter<"Users"> | string
    createdAt?: DateTimeFilter<"Users"> | Date | string
    updatedAt?: DateTimeFilter<"Users"> | Date | string
    role?: EnumRoleFilter<"Users"> | $Enums.Role
    agencyId?: StringNullableFilter<"Users"> | string | null
    Agency?: XOR<AgencyNullableScalarRelationFilter, AgencyWhereInput> | null
    Permission?: PermissionsListRelationFilter
    Ticket?: TicketsListRelationFilter
    Notification?: NotificationsListRelationFilter
  }

  export type UsersOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    avatarUrl?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    role?: SortOrder
    agencyId?: SortOrderInput | SortOrder
    Agency?: AgencyOrderByWithRelationInput
    Permission?: PermissionsOrderByRelationAggregateInput
    Ticket?: TicketsOrderByRelationAggregateInput
    Notification?: NotificationsOrderByRelationAggregateInput
  }

  export type UsersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UsersWhereInput | UsersWhereInput[]
    OR?: UsersWhereInput[]
    NOT?: UsersWhereInput | UsersWhereInput[]
    name?: StringFilter<"Users"> | string
    avatarUrl?: StringFilter<"Users"> | string
    createdAt?: DateTimeFilter<"Users"> | Date | string
    updatedAt?: DateTimeFilter<"Users"> | Date | string
    role?: EnumRoleFilter<"Users"> | $Enums.Role
    agencyId?: StringNullableFilter<"Users"> | string | null
    Agency?: XOR<AgencyNullableScalarRelationFilter, AgencyWhereInput> | null
    Permission?: PermissionsListRelationFilter
    Ticket?: TicketsListRelationFilter
    Notification?: NotificationsListRelationFilter
  }, "id" | "email">

  export type UsersOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    avatarUrl?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    role?: SortOrder
    agencyId?: SortOrderInput | SortOrder
    _count?: UsersCountOrderByAggregateInput
    _max?: UsersMaxOrderByAggregateInput
    _min?: UsersMinOrderByAggregateInput
  }

  export type UsersScalarWhereWithAggregatesInput = {
    AND?: UsersScalarWhereWithAggregatesInput | UsersScalarWhereWithAggregatesInput[]
    OR?: UsersScalarWhereWithAggregatesInput[]
    NOT?: UsersScalarWhereWithAggregatesInput | UsersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Users"> | string
    name?: StringWithAggregatesFilter<"Users"> | string
    avatarUrl?: StringWithAggregatesFilter<"Users"> | string
    email?: StringWithAggregatesFilter<"Users"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Users"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Users"> | Date | string
    role?: EnumRoleWithAggregatesFilter<"Users"> | $Enums.Role
    agencyId?: StringNullableWithAggregatesFilter<"Users"> | string | null
  }

  export type PermissionsWhereInput = {
    AND?: PermissionsWhereInput | PermissionsWhereInput[]
    OR?: PermissionsWhereInput[]
    NOT?: PermissionsWhereInput | PermissionsWhereInput[]
    id?: StringFilter<"Permissions"> | string
    email?: StringFilter<"Permissions"> | string
    subAccontId?: StringFilter<"Permissions"> | string
    access?: BoolFilter<"Permissions"> | boolean
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    SubAcctount?: XOR<SubAccountsScalarRelationFilter, SubAccountsWhereInput>
  }

  export type PermissionsOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    subAccontId?: SortOrder
    access?: SortOrder
    Users?: UsersOrderByWithRelationInput
    SubAcctount?: SubAccountsOrderByWithRelationInput
  }

  export type PermissionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PermissionsWhereInput | PermissionsWhereInput[]
    OR?: PermissionsWhereInput[]
    NOT?: PermissionsWhereInput | PermissionsWhereInput[]
    email?: StringFilter<"Permissions"> | string
    subAccontId?: StringFilter<"Permissions"> | string
    access?: BoolFilter<"Permissions"> | boolean
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    SubAcctount?: XOR<SubAccountsScalarRelationFilter, SubAccountsWhereInput>
  }, "id">

  export type PermissionsOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    subAccontId?: SortOrder
    access?: SortOrder
    _count?: PermissionsCountOrderByAggregateInput
    _max?: PermissionsMaxOrderByAggregateInput
    _min?: PermissionsMinOrderByAggregateInput
  }

  export type PermissionsScalarWhereWithAggregatesInput = {
    AND?: PermissionsScalarWhereWithAggregatesInput | PermissionsScalarWhereWithAggregatesInput[]
    OR?: PermissionsScalarWhereWithAggregatesInput[]
    NOT?: PermissionsScalarWhereWithAggregatesInput | PermissionsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Permissions"> | string
    email?: StringWithAggregatesFilter<"Permissions"> | string
    subAccontId?: StringWithAggregatesFilter<"Permissions"> | string
    access?: BoolWithAggregatesFilter<"Permissions"> | boolean
  }

  export type AgencyWhereInput = {
    AND?: AgencyWhereInput | AgencyWhereInput[]
    OR?: AgencyWhereInput[]
    NOT?: AgencyWhereInput | AgencyWhereInput[]
    id?: StringFilter<"Agency"> | string
    connectAccountId?: StringNullableFilter<"Agency"> | string | null
    customerId?: StringFilter<"Agency"> | string
    name?: StringFilter<"Agency"> | string
    agencyLogo?: StringFilter<"Agency"> | string
    companyEmail?: StringFilter<"Agency"> | string
    companyPhone?: StringFilter<"Agency"> | string
    whiteLabel?: BoolFilter<"Agency"> | boolean
    address?: StringFilter<"Agency"> | string
    city?: StringFilter<"Agency"> | string
    zipCode?: StringFilter<"Agency"> | string
    state?: StringFilter<"Agency"> | string
    country?: StringFilter<"Agency"> | string
    goal?: IntFilter<"Agency"> | number
    createdAt?: DateTimeFilter<"Agency"> | Date | string
    updatedAt?: DateTimeFilter<"Agency"> | Date | string
    user?: UsersListRelationFilter
    SubAccount?: SubAccountsListRelationFilter
    SidebarOption?: AgencySidebarOptionListRelationFilter
    Invitation?: InvitationsListRelationFilter
    Notification?: NotificationsListRelationFilter
    Subscription?: XOR<SubscriptionsNullableScalarRelationFilter, SubscriptionsWhereInput> | null
    AddOns?: AddOnsListRelationFilter
  }

  export type AgencyOrderByWithRelationInput = {
    id?: SortOrder
    connectAccountId?: SortOrderInput | SortOrder
    customerId?: SortOrder
    name?: SortOrder
    agencyLogo?: SortOrder
    companyEmail?: SortOrder
    companyPhone?: SortOrder
    whiteLabel?: SortOrder
    address?: SortOrder
    city?: SortOrder
    zipCode?: SortOrder
    state?: SortOrder
    country?: SortOrder
    goal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UsersOrderByRelationAggregateInput
    SubAccount?: SubAccountsOrderByRelationAggregateInput
    SidebarOption?: AgencySidebarOptionOrderByRelationAggregateInput
    Invitation?: InvitationsOrderByRelationAggregateInput
    Notification?: NotificationsOrderByRelationAggregateInput
    Subscription?: SubscriptionsOrderByWithRelationInput
    AddOns?: AddOnsOrderByRelationAggregateInput
  }

  export type AgencyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AgencyWhereInput | AgencyWhereInput[]
    OR?: AgencyWhereInput[]
    NOT?: AgencyWhereInput | AgencyWhereInput[]
    connectAccountId?: StringNullableFilter<"Agency"> | string | null
    customerId?: StringFilter<"Agency"> | string
    name?: StringFilter<"Agency"> | string
    agencyLogo?: StringFilter<"Agency"> | string
    companyEmail?: StringFilter<"Agency"> | string
    companyPhone?: StringFilter<"Agency"> | string
    whiteLabel?: BoolFilter<"Agency"> | boolean
    address?: StringFilter<"Agency"> | string
    city?: StringFilter<"Agency"> | string
    zipCode?: StringFilter<"Agency"> | string
    state?: StringFilter<"Agency"> | string
    country?: StringFilter<"Agency"> | string
    goal?: IntFilter<"Agency"> | number
    createdAt?: DateTimeFilter<"Agency"> | Date | string
    updatedAt?: DateTimeFilter<"Agency"> | Date | string
    user?: UsersListRelationFilter
    SubAccount?: SubAccountsListRelationFilter
    SidebarOption?: AgencySidebarOptionListRelationFilter
    Invitation?: InvitationsListRelationFilter
    Notification?: NotificationsListRelationFilter
    Subscription?: XOR<SubscriptionsNullableScalarRelationFilter, SubscriptionsWhereInput> | null
    AddOns?: AddOnsListRelationFilter
  }, "id">

  export type AgencyOrderByWithAggregationInput = {
    id?: SortOrder
    connectAccountId?: SortOrderInput | SortOrder
    customerId?: SortOrder
    name?: SortOrder
    agencyLogo?: SortOrder
    companyEmail?: SortOrder
    companyPhone?: SortOrder
    whiteLabel?: SortOrder
    address?: SortOrder
    city?: SortOrder
    zipCode?: SortOrder
    state?: SortOrder
    country?: SortOrder
    goal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AgencyCountOrderByAggregateInput
    _avg?: AgencyAvgOrderByAggregateInput
    _max?: AgencyMaxOrderByAggregateInput
    _min?: AgencyMinOrderByAggregateInput
    _sum?: AgencySumOrderByAggregateInput
  }

  export type AgencyScalarWhereWithAggregatesInput = {
    AND?: AgencyScalarWhereWithAggregatesInput | AgencyScalarWhereWithAggregatesInput[]
    OR?: AgencyScalarWhereWithAggregatesInput[]
    NOT?: AgencyScalarWhereWithAggregatesInput | AgencyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Agency"> | string
    connectAccountId?: StringNullableWithAggregatesFilter<"Agency"> | string | null
    customerId?: StringWithAggregatesFilter<"Agency"> | string
    name?: StringWithAggregatesFilter<"Agency"> | string
    agencyLogo?: StringWithAggregatesFilter<"Agency"> | string
    companyEmail?: StringWithAggregatesFilter<"Agency"> | string
    companyPhone?: StringWithAggregatesFilter<"Agency"> | string
    whiteLabel?: BoolWithAggregatesFilter<"Agency"> | boolean
    address?: StringWithAggregatesFilter<"Agency"> | string
    city?: StringWithAggregatesFilter<"Agency"> | string
    zipCode?: StringWithAggregatesFilter<"Agency"> | string
    state?: StringWithAggregatesFilter<"Agency"> | string
    country?: StringWithAggregatesFilter<"Agency"> | string
    goal?: IntWithAggregatesFilter<"Agency"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Agency"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Agency"> | Date | string
  }

  export type AgencySidebarOptionWhereInput = {
    AND?: AgencySidebarOptionWhereInput | AgencySidebarOptionWhereInput[]
    OR?: AgencySidebarOptionWhereInput[]
    NOT?: AgencySidebarOptionWhereInput | AgencySidebarOptionWhereInput[]
    id?: StringFilter<"AgencySidebarOption"> | string
    name?: StringFilter<"AgencySidebarOption"> | string
    link?: StringFilter<"AgencySidebarOption"> | string
    icon?: EnumIconFilter<"AgencySidebarOption"> | $Enums.Icon
    createdAt?: DateTimeFilter<"AgencySidebarOption"> | Date | string
    updatedAt?: DateTimeFilter<"AgencySidebarOption"> | Date | string
    agencyId?: StringFilter<"AgencySidebarOption"> | string
    subAccountId?: StringNullableFilter<"AgencySidebarOption"> | string | null
    Agency?: XOR<AgencyScalarRelationFilter, AgencyWhereInput>
    SubAccounts?: XOR<SubAccountsNullableScalarRelationFilter, SubAccountsWhereInput> | null
  }

  export type AgencySidebarOptionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    link?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    agencyId?: SortOrder
    subAccountId?: SortOrderInput | SortOrder
    Agency?: AgencyOrderByWithRelationInput
    SubAccounts?: SubAccountsOrderByWithRelationInput
  }

  export type AgencySidebarOptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AgencySidebarOptionWhereInput | AgencySidebarOptionWhereInput[]
    OR?: AgencySidebarOptionWhereInput[]
    NOT?: AgencySidebarOptionWhereInput | AgencySidebarOptionWhereInput[]
    name?: StringFilter<"AgencySidebarOption"> | string
    link?: StringFilter<"AgencySidebarOption"> | string
    icon?: EnumIconFilter<"AgencySidebarOption"> | $Enums.Icon
    createdAt?: DateTimeFilter<"AgencySidebarOption"> | Date | string
    updatedAt?: DateTimeFilter<"AgencySidebarOption"> | Date | string
    agencyId?: StringFilter<"AgencySidebarOption"> | string
    subAccountId?: StringNullableFilter<"AgencySidebarOption"> | string | null
    Agency?: XOR<AgencyScalarRelationFilter, AgencyWhereInput>
    SubAccounts?: XOR<SubAccountsNullableScalarRelationFilter, SubAccountsWhereInput> | null
  }, "id">

  export type AgencySidebarOptionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    link?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    agencyId?: SortOrder
    subAccountId?: SortOrderInput | SortOrder
    _count?: AgencySidebarOptionCountOrderByAggregateInput
    _max?: AgencySidebarOptionMaxOrderByAggregateInput
    _min?: AgencySidebarOptionMinOrderByAggregateInput
  }

  export type AgencySidebarOptionScalarWhereWithAggregatesInput = {
    AND?: AgencySidebarOptionScalarWhereWithAggregatesInput | AgencySidebarOptionScalarWhereWithAggregatesInput[]
    OR?: AgencySidebarOptionScalarWhereWithAggregatesInput[]
    NOT?: AgencySidebarOptionScalarWhereWithAggregatesInput | AgencySidebarOptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AgencySidebarOption"> | string
    name?: StringWithAggregatesFilter<"AgencySidebarOption"> | string
    link?: StringWithAggregatesFilter<"AgencySidebarOption"> | string
    icon?: EnumIconWithAggregatesFilter<"AgencySidebarOption"> | $Enums.Icon
    createdAt?: DateTimeWithAggregatesFilter<"AgencySidebarOption"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AgencySidebarOption"> | Date | string
    agencyId?: StringWithAggregatesFilter<"AgencySidebarOption"> | string
    subAccountId?: StringNullableWithAggregatesFilter<"AgencySidebarOption"> | string | null
  }

  export type SubAccountsWhereInput = {
    AND?: SubAccountsWhereInput | SubAccountsWhereInput[]
    OR?: SubAccountsWhereInput[]
    NOT?: SubAccountsWhereInput | SubAccountsWhereInput[]
    id?: StringFilter<"SubAccounts"> | string
    connectAccountId?: StringNullableFilter<"SubAccounts"> | string | null
    name?: StringFilter<"SubAccounts"> | string
    subAcctountLogo?: StringFilter<"SubAccounts"> | string
    createdAt?: DateTimeFilter<"SubAccounts"> | Date | string
    updatedAt?: DateTimeFilter<"SubAccounts"> | Date | string
    companyEmail?: StringFilter<"SubAccounts"> | string
    companyPhone?: StringFilter<"SubAccounts"> | string
    goal?: IntFilter<"SubAccounts"> | number
    address?: StringFilter<"SubAccounts"> | string
    city?: StringFilter<"SubAccounts"> | string
    zipCode?: StringFilter<"SubAccounts"> | string
    state?: StringFilter<"SubAccounts"> | string
    country?: StringFilter<"SubAccounts"> | string
    agencyId?: StringFilter<"SubAccounts"> | string
    Agency?: XOR<AgencyScalarRelationFilter, AgencyWhereInput>
    SidebarOption?: AgencySidebarOptionListRelationFilter
    Permissions?: PermissionsListRelationFilter
    Funnels?: FunnelsListRelationFilter
    Media?: MediaListRelationFilter
    Contact?: ContactsListRelationFilter
    Trigger?: TriggersListRelationFilter
    Automation?: AutomationsListRelationFilter
    Pipeline?: PipelinesListRelationFilter
    Tags?: TagsListRelationFilter
    Notification?: NotificationsListRelationFilter
    SubAccountSidebarOption?: SubAccountSidebarOptionListRelationFilter
  }

  export type SubAccountsOrderByWithRelationInput = {
    id?: SortOrder
    connectAccountId?: SortOrderInput | SortOrder
    name?: SortOrder
    subAcctountLogo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyEmail?: SortOrder
    companyPhone?: SortOrder
    goal?: SortOrder
    address?: SortOrder
    city?: SortOrder
    zipCode?: SortOrder
    state?: SortOrder
    country?: SortOrder
    agencyId?: SortOrder
    Agency?: AgencyOrderByWithRelationInput
    SidebarOption?: AgencySidebarOptionOrderByRelationAggregateInput
    Permissions?: PermissionsOrderByRelationAggregateInput
    Funnels?: FunnelsOrderByRelationAggregateInput
    Media?: MediaOrderByRelationAggregateInput
    Contact?: ContactsOrderByRelationAggregateInput
    Trigger?: TriggersOrderByRelationAggregateInput
    Automation?: AutomationsOrderByRelationAggregateInput
    Pipeline?: PipelinesOrderByRelationAggregateInput
    Tags?: TagsOrderByRelationAggregateInput
    Notification?: NotificationsOrderByRelationAggregateInput
    SubAccountSidebarOption?: SubAccountSidebarOptionOrderByRelationAggregateInput
  }

  export type SubAccountsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SubAccountsWhereInput | SubAccountsWhereInput[]
    OR?: SubAccountsWhereInput[]
    NOT?: SubAccountsWhereInput | SubAccountsWhereInput[]
    connectAccountId?: StringNullableFilter<"SubAccounts"> | string | null
    name?: StringFilter<"SubAccounts"> | string
    subAcctountLogo?: StringFilter<"SubAccounts"> | string
    createdAt?: DateTimeFilter<"SubAccounts"> | Date | string
    updatedAt?: DateTimeFilter<"SubAccounts"> | Date | string
    companyEmail?: StringFilter<"SubAccounts"> | string
    companyPhone?: StringFilter<"SubAccounts"> | string
    goal?: IntFilter<"SubAccounts"> | number
    address?: StringFilter<"SubAccounts"> | string
    city?: StringFilter<"SubAccounts"> | string
    zipCode?: StringFilter<"SubAccounts"> | string
    state?: StringFilter<"SubAccounts"> | string
    country?: StringFilter<"SubAccounts"> | string
    agencyId?: StringFilter<"SubAccounts"> | string
    Agency?: XOR<AgencyScalarRelationFilter, AgencyWhereInput>
    SidebarOption?: AgencySidebarOptionListRelationFilter
    Permissions?: PermissionsListRelationFilter
    Funnels?: FunnelsListRelationFilter
    Media?: MediaListRelationFilter
    Contact?: ContactsListRelationFilter
    Trigger?: TriggersListRelationFilter
    Automation?: AutomationsListRelationFilter
    Pipeline?: PipelinesListRelationFilter
    Tags?: TagsListRelationFilter
    Notification?: NotificationsListRelationFilter
    SubAccountSidebarOption?: SubAccountSidebarOptionListRelationFilter
  }, "id">

  export type SubAccountsOrderByWithAggregationInput = {
    id?: SortOrder
    connectAccountId?: SortOrderInput | SortOrder
    name?: SortOrder
    subAcctountLogo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyEmail?: SortOrder
    companyPhone?: SortOrder
    goal?: SortOrder
    address?: SortOrder
    city?: SortOrder
    zipCode?: SortOrder
    state?: SortOrder
    country?: SortOrder
    agencyId?: SortOrder
    _count?: SubAccountsCountOrderByAggregateInput
    _avg?: SubAccountsAvgOrderByAggregateInput
    _max?: SubAccountsMaxOrderByAggregateInput
    _min?: SubAccountsMinOrderByAggregateInput
    _sum?: SubAccountsSumOrderByAggregateInput
  }

  export type SubAccountsScalarWhereWithAggregatesInput = {
    AND?: SubAccountsScalarWhereWithAggregatesInput | SubAccountsScalarWhereWithAggregatesInput[]
    OR?: SubAccountsScalarWhereWithAggregatesInput[]
    NOT?: SubAccountsScalarWhereWithAggregatesInput | SubAccountsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SubAccounts"> | string
    connectAccountId?: StringNullableWithAggregatesFilter<"SubAccounts"> | string | null
    name?: StringWithAggregatesFilter<"SubAccounts"> | string
    subAcctountLogo?: StringWithAggregatesFilter<"SubAccounts"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SubAccounts"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SubAccounts"> | Date | string
    companyEmail?: StringWithAggregatesFilter<"SubAccounts"> | string
    companyPhone?: StringWithAggregatesFilter<"SubAccounts"> | string
    goal?: IntWithAggregatesFilter<"SubAccounts"> | number
    address?: StringWithAggregatesFilter<"SubAccounts"> | string
    city?: StringWithAggregatesFilter<"SubAccounts"> | string
    zipCode?: StringWithAggregatesFilter<"SubAccounts"> | string
    state?: StringWithAggregatesFilter<"SubAccounts"> | string
    country?: StringWithAggregatesFilter<"SubAccounts"> | string
    agencyId?: StringWithAggregatesFilter<"SubAccounts"> | string
  }

  export type PipelinesWhereInput = {
    AND?: PipelinesWhereInput | PipelinesWhereInput[]
    OR?: PipelinesWhereInput[]
    NOT?: PipelinesWhereInput | PipelinesWhereInput[]
    id?: StringFilter<"Pipelines"> | string
    name?: StringFilter<"Pipelines"> | string
    createdAt?: DateTimeFilter<"Pipelines"> | Date | string
    updatedAt?: DateTimeFilter<"Pipelines"> | Date | string
    subAccountId?: StringFilter<"Pipelines"> | string
    Lane?: LaneListRelationFilter
    SubAccount?: XOR<SubAccountsScalarRelationFilter, SubAccountsWhereInput>
  }

  export type PipelinesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subAccountId?: SortOrder
    Lane?: LaneOrderByRelationAggregateInput
    SubAccount?: SubAccountsOrderByWithRelationInput
  }

  export type PipelinesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PipelinesWhereInput | PipelinesWhereInput[]
    OR?: PipelinesWhereInput[]
    NOT?: PipelinesWhereInput | PipelinesWhereInput[]
    name?: StringFilter<"Pipelines"> | string
    createdAt?: DateTimeFilter<"Pipelines"> | Date | string
    updatedAt?: DateTimeFilter<"Pipelines"> | Date | string
    subAccountId?: StringFilter<"Pipelines"> | string
    Lane?: LaneListRelationFilter
    SubAccount?: XOR<SubAccountsScalarRelationFilter, SubAccountsWhereInput>
  }, "id">

  export type PipelinesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subAccountId?: SortOrder
    _count?: PipelinesCountOrderByAggregateInput
    _max?: PipelinesMaxOrderByAggregateInput
    _min?: PipelinesMinOrderByAggregateInput
  }

  export type PipelinesScalarWhereWithAggregatesInput = {
    AND?: PipelinesScalarWhereWithAggregatesInput | PipelinesScalarWhereWithAggregatesInput[]
    OR?: PipelinesScalarWhereWithAggregatesInput[]
    NOT?: PipelinesScalarWhereWithAggregatesInput | PipelinesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Pipelines"> | string
    name?: StringWithAggregatesFilter<"Pipelines"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Pipelines"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Pipelines"> | Date | string
    subAccountId?: StringWithAggregatesFilter<"Pipelines"> | string
  }

  export type TriggersWhereInput = {
    AND?: TriggersWhereInput | TriggersWhereInput[]
    OR?: TriggersWhereInput[]
    NOT?: TriggersWhereInput | TriggersWhereInput[]
    id?: StringFilter<"Triggers"> | string
    name?: StringFilter<"Triggers"> | string
    type?: EnumTriggerTypesFilter<"Triggers"> | $Enums.TriggerTypes
    createdAt?: DateTimeFilter<"Triggers"> | Date | string
    updatedAt?: DateTimeFilter<"Triggers"> | Date | string
    subAccountId?: StringFilter<"Triggers"> | string
    SubAccounts?: XOR<SubAccountsScalarRelationFilter, SubAccountsWhereInput>
    Automations?: AutomationsListRelationFilter
  }

  export type TriggersOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subAccountId?: SortOrder
    SubAccounts?: SubAccountsOrderByWithRelationInput
    Automations?: AutomationsOrderByRelationAggregateInput
  }

  export type TriggersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TriggersWhereInput | TriggersWhereInput[]
    OR?: TriggersWhereInput[]
    NOT?: TriggersWhereInput | TriggersWhereInput[]
    name?: StringFilter<"Triggers"> | string
    type?: EnumTriggerTypesFilter<"Triggers"> | $Enums.TriggerTypes
    createdAt?: DateTimeFilter<"Triggers"> | Date | string
    updatedAt?: DateTimeFilter<"Triggers"> | Date | string
    subAccountId?: StringFilter<"Triggers"> | string
    SubAccounts?: XOR<SubAccountsScalarRelationFilter, SubAccountsWhereInput>
    Automations?: AutomationsListRelationFilter
  }, "id">

  export type TriggersOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subAccountId?: SortOrder
    _count?: TriggersCountOrderByAggregateInput
    _max?: TriggersMaxOrderByAggregateInput
    _min?: TriggersMinOrderByAggregateInput
  }

  export type TriggersScalarWhereWithAggregatesInput = {
    AND?: TriggersScalarWhereWithAggregatesInput | TriggersScalarWhereWithAggregatesInput[]
    OR?: TriggersScalarWhereWithAggregatesInput[]
    NOT?: TriggersScalarWhereWithAggregatesInput | TriggersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Triggers"> | string
    name?: StringWithAggregatesFilter<"Triggers"> | string
    type?: EnumTriggerTypesWithAggregatesFilter<"Triggers"> | $Enums.TriggerTypes
    createdAt?: DateTimeWithAggregatesFilter<"Triggers"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Triggers"> | Date | string
    subAccountId?: StringWithAggregatesFilter<"Triggers"> | string
  }

  export type AutomationsWhereInput = {
    AND?: AutomationsWhereInput | AutomationsWhereInput[]
    OR?: AutomationsWhereInput[]
    NOT?: AutomationsWhereInput | AutomationsWhereInput[]
    id?: StringFilter<"Automations"> | string
    name?: StringFilter<"Automations"> | string
    createdAt?: DateTimeFilter<"Automations"> | Date | string
    updatedAt?: DateTimeFilter<"Automations"> | Date | string
    triggerId?: StringNullableFilter<"Automations"> | string | null
    published?: BoolFilter<"Automations"> | boolean
    subAccountId?: StringFilter<"Automations"> | string
    Trigger?: XOR<TriggersNullableScalarRelationFilter, TriggersWhereInput> | null
    SubAccounts?: XOR<SubAccountsScalarRelationFilter, SubAccountsWhereInput>
    Actions?: ActionsListRelationFilter
    AutomationInstance?: AutomationInstanceListRelationFilter
  }

  export type AutomationsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    triggerId?: SortOrderInput | SortOrder
    published?: SortOrder
    subAccountId?: SortOrder
    Trigger?: TriggersOrderByWithRelationInput
    SubAccounts?: SubAccountsOrderByWithRelationInput
    Actions?: ActionsOrderByRelationAggregateInput
    AutomationInstance?: AutomationInstanceOrderByRelationAggregateInput
  }

  export type AutomationsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AutomationsWhereInput | AutomationsWhereInput[]
    OR?: AutomationsWhereInput[]
    NOT?: AutomationsWhereInput | AutomationsWhereInput[]
    name?: StringFilter<"Automations"> | string
    createdAt?: DateTimeFilter<"Automations"> | Date | string
    updatedAt?: DateTimeFilter<"Automations"> | Date | string
    triggerId?: StringNullableFilter<"Automations"> | string | null
    published?: BoolFilter<"Automations"> | boolean
    subAccountId?: StringFilter<"Automations"> | string
    Trigger?: XOR<TriggersNullableScalarRelationFilter, TriggersWhereInput> | null
    SubAccounts?: XOR<SubAccountsScalarRelationFilter, SubAccountsWhereInput>
    Actions?: ActionsListRelationFilter
    AutomationInstance?: AutomationInstanceListRelationFilter
  }, "id">

  export type AutomationsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    triggerId?: SortOrderInput | SortOrder
    published?: SortOrder
    subAccountId?: SortOrder
    _count?: AutomationsCountOrderByAggregateInput
    _max?: AutomationsMaxOrderByAggregateInput
    _min?: AutomationsMinOrderByAggregateInput
  }

  export type AutomationsScalarWhereWithAggregatesInput = {
    AND?: AutomationsScalarWhereWithAggregatesInput | AutomationsScalarWhereWithAggregatesInput[]
    OR?: AutomationsScalarWhereWithAggregatesInput[]
    NOT?: AutomationsScalarWhereWithAggregatesInput | AutomationsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Automations"> | string
    name?: StringWithAggregatesFilter<"Automations"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Automations"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Automations"> | Date | string
    triggerId?: StringNullableWithAggregatesFilter<"Automations"> | string | null
    published?: BoolWithAggregatesFilter<"Automations"> | boolean
    subAccountId?: StringWithAggregatesFilter<"Automations"> | string
  }

  export type AutomationInstanceWhereInput = {
    AND?: AutomationInstanceWhereInput | AutomationInstanceWhereInput[]
    OR?: AutomationInstanceWhereInput[]
    NOT?: AutomationInstanceWhereInput | AutomationInstanceWhereInput[]
    id?: StringFilter<"AutomationInstance"> | string
    createdAt?: DateTimeFilter<"AutomationInstance"> | Date | string
    updatedAt?: DateTimeFilter<"AutomationInstance"> | Date | string
    automationId?: StringFilter<"AutomationInstance"> | string
    active?: BoolFilter<"AutomationInstance"> | boolean
    Automations?: XOR<AutomationsScalarRelationFilter, AutomationsWhereInput>
  }

  export type AutomationInstanceOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    automationId?: SortOrder
    active?: SortOrder
    Automations?: AutomationsOrderByWithRelationInput
  }

  export type AutomationInstanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AutomationInstanceWhereInput | AutomationInstanceWhereInput[]
    OR?: AutomationInstanceWhereInput[]
    NOT?: AutomationInstanceWhereInput | AutomationInstanceWhereInput[]
    createdAt?: DateTimeFilter<"AutomationInstance"> | Date | string
    updatedAt?: DateTimeFilter<"AutomationInstance"> | Date | string
    automationId?: StringFilter<"AutomationInstance"> | string
    active?: BoolFilter<"AutomationInstance"> | boolean
    Automations?: XOR<AutomationsScalarRelationFilter, AutomationsWhereInput>
  }, "id">

  export type AutomationInstanceOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    automationId?: SortOrder
    active?: SortOrder
    _count?: AutomationInstanceCountOrderByAggregateInput
    _max?: AutomationInstanceMaxOrderByAggregateInput
    _min?: AutomationInstanceMinOrderByAggregateInput
  }

  export type AutomationInstanceScalarWhereWithAggregatesInput = {
    AND?: AutomationInstanceScalarWhereWithAggregatesInput | AutomationInstanceScalarWhereWithAggregatesInput[]
    OR?: AutomationInstanceScalarWhereWithAggregatesInput[]
    NOT?: AutomationInstanceScalarWhereWithAggregatesInput | AutomationInstanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AutomationInstance"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AutomationInstance"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AutomationInstance"> | Date | string
    automationId?: StringWithAggregatesFilter<"AutomationInstance"> | string
    active?: BoolWithAggregatesFilter<"AutomationInstance"> | boolean
  }

  export type ActionsWhereInput = {
    AND?: ActionsWhereInput | ActionsWhereInput[]
    OR?: ActionsWhereInput[]
    NOT?: ActionsWhereInput | ActionsWhereInput[]
    id?: StringFilter<"Actions"> | string
    name?: StringFilter<"Actions"> | string
    type?: EnumActionTypeFilter<"Actions"> | $Enums.ActionType
    createdAt?: DateTimeFilter<"Actions"> | Date | string
    updatedAt?: DateTimeFilter<"Actions"> | Date | string
    automatedId?: StringFilter<"Actions"> | string
    order?: IntFilter<"Actions"> | number
    laneId?: StringFilter<"Actions"> | string
    Automations?: XOR<AutomationsScalarRelationFilter, AutomationsWhereInput>
  }

  export type ActionsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    automatedId?: SortOrder
    order?: SortOrder
    laneId?: SortOrder
    Automations?: AutomationsOrderByWithRelationInput
  }

  export type ActionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ActionsWhereInput | ActionsWhereInput[]
    OR?: ActionsWhereInput[]
    NOT?: ActionsWhereInput | ActionsWhereInput[]
    name?: StringFilter<"Actions"> | string
    type?: EnumActionTypeFilter<"Actions"> | $Enums.ActionType
    createdAt?: DateTimeFilter<"Actions"> | Date | string
    updatedAt?: DateTimeFilter<"Actions"> | Date | string
    automatedId?: StringFilter<"Actions"> | string
    order?: IntFilter<"Actions"> | number
    laneId?: StringFilter<"Actions"> | string
    Automations?: XOR<AutomationsScalarRelationFilter, AutomationsWhereInput>
  }, "id">

  export type ActionsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    automatedId?: SortOrder
    order?: SortOrder
    laneId?: SortOrder
    _count?: ActionsCountOrderByAggregateInput
    _avg?: ActionsAvgOrderByAggregateInput
    _max?: ActionsMaxOrderByAggregateInput
    _min?: ActionsMinOrderByAggregateInput
    _sum?: ActionsSumOrderByAggregateInput
  }

  export type ActionsScalarWhereWithAggregatesInput = {
    AND?: ActionsScalarWhereWithAggregatesInput | ActionsScalarWhereWithAggregatesInput[]
    OR?: ActionsScalarWhereWithAggregatesInput[]
    NOT?: ActionsScalarWhereWithAggregatesInput | ActionsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Actions"> | string
    name?: StringWithAggregatesFilter<"Actions"> | string
    type?: EnumActionTypeWithAggregatesFilter<"Actions"> | $Enums.ActionType
    createdAt?: DateTimeWithAggregatesFilter<"Actions"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Actions"> | Date | string
    automatedId?: StringWithAggregatesFilter<"Actions"> | string
    order?: IntWithAggregatesFilter<"Actions"> | number
    laneId?: StringWithAggregatesFilter<"Actions"> | string
  }

  export type ContactsWhereInput = {
    AND?: ContactsWhereInput | ContactsWhereInput[]
    OR?: ContactsWhereInput[]
    NOT?: ContactsWhereInput | ContactsWhereInput[]
    id?: StringFilter<"Contacts"> | string
    name?: StringFilter<"Contacts"> | string
    email?: StringFilter<"Contacts"> | string
    createdAt?: DateTimeFilter<"Contacts"> | Date | string
    updatedAt?: DateTimeFilter<"Contacts"> | Date | string
    subAccountId?: StringFilter<"Contacts"> | string
    SubAccounts?: XOR<SubAccountsScalarRelationFilter, SubAccountsWhereInput>
    Tickets?: TicketsListRelationFilter
  }

  export type ContactsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subAccountId?: SortOrder
    SubAccounts?: SubAccountsOrderByWithRelationInput
    Tickets?: TicketsOrderByRelationAggregateInput
  }

  export type ContactsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContactsWhereInput | ContactsWhereInput[]
    OR?: ContactsWhereInput[]
    NOT?: ContactsWhereInput | ContactsWhereInput[]
    name?: StringFilter<"Contacts"> | string
    email?: StringFilter<"Contacts"> | string
    createdAt?: DateTimeFilter<"Contacts"> | Date | string
    updatedAt?: DateTimeFilter<"Contacts"> | Date | string
    subAccountId?: StringFilter<"Contacts"> | string
    SubAccounts?: XOR<SubAccountsScalarRelationFilter, SubAccountsWhereInput>
    Tickets?: TicketsListRelationFilter
  }, "id">

  export type ContactsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subAccountId?: SortOrder
    _count?: ContactsCountOrderByAggregateInput
    _max?: ContactsMaxOrderByAggregateInput
    _min?: ContactsMinOrderByAggregateInput
  }

  export type ContactsScalarWhereWithAggregatesInput = {
    AND?: ContactsScalarWhereWithAggregatesInput | ContactsScalarWhereWithAggregatesInput[]
    OR?: ContactsScalarWhereWithAggregatesInput[]
    NOT?: ContactsScalarWhereWithAggregatesInput | ContactsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Contacts"> | string
    name?: StringWithAggregatesFilter<"Contacts"> | string
    email?: StringWithAggregatesFilter<"Contacts"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Contacts"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Contacts"> | Date | string
    subAccountId?: StringWithAggregatesFilter<"Contacts"> | string
  }

  export type MediaWhereInput = {
    AND?: MediaWhereInput | MediaWhereInput[]
    OR?: MediaWhereInput[]
    NOT?: MediaWhereInput | MediaWhereInput[]
    id?: StringFilter<"Media"> | string
    type?: StringNullableFilter<"Media"> | string | null
    name?: StringFilter<"Media"> | string
    link?: StringFilter<"Media"> | string
    subAccountId?: StringFilter<"Media"> | string
    createdAt?: DateTimeFilter<"Media"> | Date | string
    updatedAt?: DateTimeFilter<"Media"> | Date | string
    SubAccounts?: XOR<SubAccountsScalarRelationFilter, SubAccountsWhereInput>
  }

  export type MediaOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrderInput | SortOrder
    name?: SortOrder
    link?: SortOrder
    subAccountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    SubAccounts?: SubAccountsOrderByWithRelationInput
  }

  export type MediaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    link?: string
    AND?: MediaWhereInput | MediaWhereInput[]
    OR?: MediaWhereInput[]
    NOT?: MediaWhereInput | MediaWhereInput[]
    type?: StringNullableFilter<"Media"> | string | null
    name?: StringFilter<"Media"> | string
    subAccountId?: StringFilter<"Media"> | string
    createdAt?: DateTimeFilter<"Media"> | Date | string
    updatedAt?: DateTimeFilter<"Media"> | Date | string
    SubAccounts?: XOR<SubAccountsScalarRelationFilter, SubAccountsWhereInput>
  }, "id" | "link">

  export type MediaOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrderInput | SortOrder
    name?: SortOrder
    link?: SortOrder
    subAccountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MediaCountOrderByAggregateInput
    _max?: MediaMaxOrderByAggregateInput
    _min?: MediaMinOrderByAggregateInput
  }

  export type MediaScalarWhereWithAggregatesInput = {
    AND?: MediaScalarWhereWithAggregatesInput | MediaScalarWhereWithAggregatesInput[]
    OR?: MediaScalarWhereWithAggregatesInput[]
    NOT?: MediaScalarWhereWithAggregatesInput | MediaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Media"> | string
    type?: StringNullableWithAggregatesFilter<"Media"> | string | null
    name?: StringWithAggregatesFilter<"Media"> | string
    link?: StringWithAggregatesFilter<"Media"> | string
    subAccountId?: StringWithAggregatesFilter<"Media"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Media"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Media"> | Date | string
  }

  export type LaneWhereInput = {
    AND?: LaneWhereInput | LaneWhereInput[]
    OR?: LaneWhereInput[]
    NOT?: LaneWhereInput | LaneWhereInput[]
    id?: StringFilter<"Lane"> | string
    name?: StringFilter<"Lane"> | string
    createdAt?: DateTimeFilter<"Lane"> | Date | string
    updatedAt?: DateTimeFilter<"Lane"> | Date | string
    pipelineId?: StringFilter<"Lane"> | string
    order?: IntFilter<"Lane"> | number
    Pipeline?: XOR<PipelinesScalarRelationFilter, PipelinesWhereInput>
    Tickets?: TicketsListRelationFilter
  }

  export type LaneOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pipelineId?: SortOrder
    order?: SortOrder
    Pipeline?: PipelinesOrderByWithRelationInput
    Tickets?: TicketsOrderByRelationAggregateInput
  }

  export type LaneWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LaneWhereInput | LaneWhereInput[]
    OR?: LaneWhereInput[]
    NOT?: LaneWhereInput | LaneWhereInput[]
    name?: StringFilter<"Lane"> | string
    createdAt?: DateTimeFilter<"Lane"> | Date | string
    updatedAt?: DateTimeFilter<"Lane"> | Date | string
    pipelineId?: StringFilter<"Lane"> | string
    order?: IntFilter<"Lane"> | number
    Pipeline?: XOR<PipelinesScalarRelationFilter, PipelinesWhereInput>
    Tickets?: TicketsListRelationFilter
  }, "id">

  export type LaneOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pipelineId?: SortOrder
    order?: SortOrder
    _count?: LaneCountOrderByAggregateInput
    _avg?: LaneAvgOrderByAggregateInput
    _max?: LaneMaxOrderByAggregateInput
    _min?: LaneMinOrderByAggregateInput
    _sum?: LaneSumOrderByAggregateInput
  }

  export type LaneScalarWhereWithAggregatesInput = {
    AND?: LaneScalarWhereWithAggregatesInput | LaneScalarWhereWithAggregatesInput[]
    OR?: LaneScalarWhereWithAggregatesInput[]
    NOT?: LaneScalarWhereWithAggregatesInput | LaneScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Lane"> | string
    name?: StringWithAggregatesFilter<"Lane"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Lane"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Lane"> | Date | string
    pipelineId?: StringWithAggregatesFilter<"Lane"> | string
    order?: IntWithAggregatesFilter<"Lane"> | number
  }

  export type TicketsWhereInput = {
    AND?: TicketsWhereInput | TicketsWhereInput[]
    OR?: TicketsWhereInput[]
    NOT?: TicketsWhereInput | TicketsWhereInput[]
    id?: StringFilter<"Tickets"> | string
    name?: StringFilter<"Tickets"> | string
    createdAt?: DateTimeFilter<"Tickets"> | Date | string
    updatedAt?: DateTimeFilter<"Tickets"> | Date | string
    lineId?: StringFilter<"Tickets"> | string
    order?: IntFilter<"Tickets"> | number
    value?: DecimalNullableFilter<"Tickets"> | Decimal | DecimalJsLike | number | string | null
    description?: StringNullableFilter<"Tickets"> | string | null
    userId?: StringNullableFilter<"Tickets"> | string | null
    contactId?: StringNullableFilter<"Tickets"> | string | null
    Lane?: XOR<LaneScalarRelationFilter, LaneWhereInput>
    tags?: TagsListRelationFilter
    Users?: XOR<UsersNullableScalarRelationFilter, UsersWhereInput> | null
    Contacts?: XOR<ContactsNullableScalarRelationFilter, ContactsWhereInput> | null
  }

  export type TicketsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lineId?: SortOrder
    order?: SortOrder
    value?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    contactId?: SortOrderInput | SortOrder
    Lane?: LaneOrderByWithRelationInput
    tags?: TagsOrderByRelationAggregateInput
    Users?: UsersOrderByWithRelationInput
    Contacts?: ContactsOrderByWithRelationInput
  }

  export type TicketsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TicketsWhereInput | TicketsWhereInput[]
    OR?: TicketsWhereInput[]
    NOT?: TicketsWhereInput | TicketsWhereInput[]
    name?: StringFilter<"Tickets"> | string
    createdAt?: DateTimeFilter<"Tickets"> | Date | string
    updatedAt?: DateTimeFilter<"Tickets"> | Date | string
    lineId?: StringFilter<"Tickets"> | string
    order?: IntFilter<"Tickets"> | number
    value?: DecimalNullableFilter<"Tickets"> | Decimal | DecimalJsLike | number | string | null
    description?: StringNullableFilter<"Tickets"> | string | null
    userId?: StringNullableFilter<"Tickets"> | string | null
    contactId?: StringNullableFilter<"Tickets"> | string | null
    Lane?: XOR<LaneScalarRelationFilter, LaneWhereInput>
    tags?: TagsListRelationFilter
    Users?: XOR<UsersNullableScalarRelationFilter, UsersWhereInput> | null
    Contacts?: XOR<ContactsNullableScalarRelationFilter, ContactsWhereInput> | null
  }, "id">

  export type TicketsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lineId?: SortOrder
    order?: SortOrder
    value?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    contactId?: SortOrderInput | SortOrder
    _count?: TicketsCountOrderByAggregateInput
    _avg?: TicketsAvgOrderByAggregateInput
    _max?: TicketsMaxOrderByAggregateInput
    _min?: TicketsMinOrderByAggregateInput
    _sum?: TicketsSumOrderByAggregateInput
  }

  export type TicketsScalarWhereWithAggregatesInput = {
    AND?: TicketsScalarWhereWithAggregatesInput | TicketsScalarWhereWithAggregatesInput[]
    OR?: TicketsScalarWhereWithAggregatesInput[]
    NOT?: TicketsScalarWhereWithAggregatesInput | TicketsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tickets"> | string
    name?: StringWithAggregatesFilter<"Tickets"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Tickets"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tickets"> | Date | string
    lineId?: StringWithAggregatesFilter<"Tickets"> | string
    order?: IntWithAggregatesFilter<"Tickets"> | number
    value?: DecimalNullableWithAggregatesFilter<"Tickets"> | Decimal | DecimalJsLike | number | string | null
    description?: StringNullableWithAggregatesFilter<"Tickets"> | string | null
    userId?: StringNullableWithAggregatesFilter<"Tickets"> | string | null
    contactId?: StringNullableWithAggregatesFilter<"Tickets"> | string | null
  }

  export type TagsWhereInput = {
    AND?: TagsWhereInput | TagsWhereInput[]
    OR?: TagsWhereInput[]
    NOT?: TagsWhereInput | TagsWhereInput[]
    id?: StringFilter<"Tags"> | string
    nane?: StringFilter<"Tags"> | string
    color?: StringFilter<"Tags"> | string
    createdAt?: DateTimeFilter<"Tags"> | Date | string
    updatedAt?: DateTimeFilter<"Tags"> | Date | string
    subAccountId?: StringFilter<"Tags"> | string
    SubAccounts?: XOR<SubAccountsScalarRelationFilter, SubAccountsWhereInput>
    Tickets?: TicketsListRelationFilter
  }

  export type TagsOrderByWithRelationInput = {
    id?: SortOrder
    nane?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subAccountId?: SortOrder
    SubAccounts?: SubAccountsOrderByWithRelationInput
    Tickets?: TicketsOrderByRelationAggregateInput
  }

  export type TagsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TagsWhereInput | TagsWhereInput[]
    OR?: TagsWhereInput[]
    NOT?: TagsWhereInput | TagsWhereInput[]
    nane?: StringFilter<"Tags"> | string
    color?: StringFilter<"Tags"> | string
    createdAt?: DateTimeFilter<"Tags"> | Date | string
    updatedAt?: DateTimeFilter<"Tags"> | Date | string
    subAccountId?: StringFilter<"Tags"> | string
    SubAccounts?: XOR<SubAccountsScalarRelationFilter, SubAccountsWhereInput>
    Tickets?: TicketsListRelationFilter
  }, "id">

  export type TagsOrderByWithAggregationInput = {
    id?: SortOrder
    nane?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subAccountId?: SortOrder
    _count?: TagsCountOrderByAggregateInput
    _max?: TagsMaxOrderByAggregateInput
    _min?: TagsMinOrderByAggregateInput
  }

  export type TagsScalarWhereWithAggregatesInput = {
    AND?: TagsScalarWhereWithAggregatesInput | TagsScalarWhereWithAggregatesInput[]
    OR?: TagsScalarWhereWithAggregatesInput[]
    NOT?: TagsScalarWhereWithAggregatesInput | TagsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tags"> | string
    nane?: StringWithAggregatesFilter<"Tags"> | string
    color?: StringWithAggregatesFilter<"Tags"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Tags"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tags"> | Date | string
    subAccountId?: StringWithAggregatesFilter<"Tags"> | string
  }

  export type SubAccountSidebarOptionWhereInput = {
    AND?: SubAccountSidebarOptionWhereInput | SubAccountSidebarOptionWhereInput[]
    OR?: SubAccountSidebarOptionWhereInput[]
    NOT?: SubAccountSidebarOptionWhereInput | SubAccountSidebarOptionWhereInput[]
    id?: StringFilter<"SubAccountSidebarOption"> | string
    name?: StringFilter<"SubAccountSidebarOption"> | string
    link?: StringFilter<"SubAccountSidebarOption"> | string
    icon?: EnumIconFilter<"SubAccountSidebarOption"> | $Enums.Icon
    createdAt?: DateTimeFilter<"SubAccountSidebarOption"> | Date | string
    updatedAt?: DateTimeFilter<"SubAccountSidebarOption"> | Date | string
    subAccountId?: StringFilter<"SubAccountSidebarOption"> | string
    subAccount?: StringNullableFilter<"SubAccountSidebarOption"> | string | null
    SubAccount?: XOR<SubAccountsNullableScalarRelationFilter, SubAccountsWhereInput> | null
  }

  export type SubAccountSidebarOptionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    link?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subAccountId?: SortOrder
    subAccount?: SortOrderInput | SortOrder
    SubAccount?: SubAccountsOrderByWithRelationInput
  }

  export type SubAccountSidebarOptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SubAccountSidebarOptionWhereInput | SubAccountSidebarOptionWhereInput[]
    OR?: SubAccountSidebarOptionWhereInput[]
    NOT?: SubAccountSidebarOptionWhereInput | SubAccountSidebarOptionWhereInput[]
    name?: StringFilter<"SubAccountSidebarOption"> | string
    link?: StringFilter<"SubAccountSidebarOption"> | string
    icon?: EnumIconFilter<"SubAccountSidebarOption"> | $Enums.Icon
    createdAt?: DateTimeFilter<"SubAccountSidebarOption"> | Date | string
    updatedAt?: DateTimeFilter<"SubAccountSidebarOption"> | Date | string
    subAccountId?: StringFilter<"SubAccountSidebarOption"> | string
    subAccount?: StringNullableFilter<"SubAccountSidebarOption"> | string | null
    SubAccount?: XOR<SubAccountsNullableScalarRelationFilter, SubAccountsWhereInput> | null
  }, "id">

  export type SubAccountSidebarOptionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    link?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subAccountId?: SortOrder
    subAccount?: SortOrderInput | SortOrder
    _count?: SubAccountSidebarOptionCountOrderByAggregateInput
    _max?: SubAccountSidebarOptionMaxOrderByAggregateInput
    _min?: SubAccountSidebarOptionMinOrderByAggregateInput
  }

  export type SubAccountSidebarOptionScalarWhereWithAggregatesInput = {
    AND?: SubAccountSidebarOptionScalarWhereWithAggregatesInput | SubAccountSidebarOptionScalarWhereWithAggregatesInput[]
    OR?: SubAccountSidebarOptionScalarWhereWithAggregatesInput[]
    NOT?: SubAccountSidebarOptionScalarWhereWithAggregatesInput | SubAccountSidebarOptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SubAccountSidebarOption"> | string
    name?: StringWithAggregatesFilter<"SubAccountSidebarOption"> | string
    link?: StringWithAggregatesFilter<"SubAccountSidebarOption"> | string
    icon?: EnumIconWithAggregatesFilter<"SubAccountSidebarOption"> | $Enums.Icon
    createdAt?: DateTimeWithAggregatesFilter<"SubAccountSidebarOption"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SubAccountSidebarOption"> | Date | string
    subAccountId?: StringWithAggregatesFilter<"SubAccountSidebarOption"> | string
    subAccount?: StringNullableWithAggregatesFilter<"SubAccountSidebarOption"> | string | null
  }

  export type InvitationsWhereInput = {
    AND?: InvitationsWhereInput | InvitationsWhereInput[]
    OR?: InvitationsWhereInput[]
    NOT?: InvitationsWhereInput | InvitationsWhereInput[]
    id?: StringFilter<"Invitations"> | string
    email?: StringFilter<"Invitations"> | string
    agencyId?: StringFilter<"Invitations"> | string
    status?: EnumInvitationStatusFilter<"Invitations"> | $Enums.InvitationStatus
    role?: EnumRoleFilter<"Invitations"> | $Enums.Role
    Agency?: XOR<AgencyScalarRelationFilter, AgencyWhereInput>
  }

  export type InvitationsOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    agencyId?: SortOrder
    status?: SortOrder
    role?: SortOrder
    Agency?: AgencyOrderByWithRelationInput
  }

  export type InvitationsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: InvitationsWhereInput | InvitationsWhereInput[]
    OR?: InvitationsWhereInput[]
    NOT?: InvitationsWhereInput | InvitationsWhereInput[]
    agencyId?: StringFilter<"Invitations"> | string
    status?: EnumInvitationStatusFilter<"Invitations"> | $Enums.InvitationStatus
    role?: EnumRoleFilter<"Invitations"> | $Enums.Role
    Agency?: XOR<AgencyScalarRelationFilter, AgencyWhereInput>
  }, "id" | "email">

  export type InvitationsOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    agencyId?: SortOrder
    status?: SortOrder
    role?: SortOrder
    _count?: InvitationsCountOrderByAggregateInput
    _max?: InvitationsMaxOrderByAggregateInput
    _min?: InvitationsMinOrderByAggregateInput
  }

  export type InvitationsScalarWhereWithAggregatesInput = {
    AND?: InvitationsScalarWhereWithAggregatesInput | InvitationsScalarWhereWithAggregatesInput[]
    OR?: InvitationsScalarWhereWithAggregatesInput[]
    NOT?: InvitationsScalarWhereWithAggregatesInput | InvitationsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Invitations"> | string
    email?: StringWithAggregatesFilter<"Invitations"> | string
    agencyId?: StringWithAggregatesFilter<"Invitations"> | string
    status?: EnumInvitationStatusWithAggregatesFilter<"Invitations"> | $Enums.InvitationStatus
    role?: EnumRoleWithAggregatesFilter<"Invitations"> | $Enums.Role
  }

  export type FunnelsWhereInput = {
    AND?: FunnelsWhereInput | FunnelsWhereInput[]
    OR?: FunnelsWhereInput[]
    NOT?: FunnelsWhereInput | FunnelsWhereInput[]
    id?: StringFilter<"Funnels"> | string
    name?: StringFilter<"Funnels"> | string
    createdAt?: DateTimeFilter<"Funnels"> | Date | string
    updatedAt?: DateTimeFilter<"Funnels"> | Date | string
    description?: StringNullableFilter<"Funnels"> | string | null
    published?: BoolFilter<"Funnels"> | boolean
    subDomainName?: StringNullableFilter<"Funnels"> | string | null
    favicon?: StringNullableFilter<"Funnels"> | string | null
    subAccountId?: StringFilter<"Funnels"> | string
    liveProducts?: StringNullableFilter<"Funnels"> | string | null
    SubAccount?: XOR<SubAccountsScalarRelationFilter, SubAccountsWhereInput>
    FunelPages?: FunelPagesListRelationFilter
    className?: ClassNameListRelationFilter
  }

  export type FunnelsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrderInput | SortOrder
    published?: SortOrder
    subDomainName?: SortOrderInput | SortOrder
    favicon?: SortOrderInput | SortOrder
    subAccountId?: SortOrder
    liveProducts?: SortOrderInput | SortOrder
    SubAccount?: SubAccountsOrderByWithRelationInput
    FunelPages?: FunelPagesOrderByRelationAggregateInput
    className?: ClassNameOrderByRelationAggregateInput
  }

  export type FunnelsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    subDomainName?: string
    AND?: FunnelsWhereInput | FunnelsWhereInput[]
    OR?: FunnelsWhereInput[]
    NOT?: FunnelsWhereInput | FunnelsWhereInput[]
    name?: StringFilter<"Funnels"> | string
    createdAt?: DateTimeFilter<"Funnels"> | Date | string
    updatedAt?: DateTimeFilter<"Funnels"> | Date | string
    description?: StringNullableFilter<"Funnels"> | string | null
    published?: BoolFilter<"Funnels"> | boolean
    favicon?: StringNullableFilter<"Funnels"> | string | null
    subAccountId?: StringFilter<"Funnels"> | string
    liveProducts?: StringNullableFilter<"Funnels"> | string | null
    SubAccount?: XOR<SubAccountsScalarRelationFilter, SubAccountsWhereInput>
    FunelPages?: FunelPagesListRelationFilter
    className?: ClassNameListRelationFilter
  }, "id" | "subDomainName">

  export type FunnelsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrderInput | SortOrder
    published?: SortOrder
    subDomainName?: SortOrderInput | SortOrder
    favicon?: SortOrderInput | SortOrder
    subAccountId?: SortOrder
    liveProducts?: SortOrderInput | SortOrder
    _count?: FunnelsCountOrderByAggregateInput
    _max?: FunnelsMaxOrderByAggregateInput
    _min?: FunnelsMinOrderByAggregateInput
  }

  export type FunnelsScalarWhereWithAggregatesInput = {
    AND?: FunnelsScalarWhereWithAggregatesInput | FunnelsScalarWhereWithAggregatesInput[]
    OR?: FunnelsScalarWhereWithAggregatesInput[]
    NOT?: FunnelsScalarWhereWithAggregatesInput | FunnelsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Funnels"> | string
    name?: StringWithAggregatesFilter<"Funnels"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Funnels"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Funnels"> | Date | string
    description?: StringNullableWithAggregatesFilter<"Funnels"> | string | null
    published?: BoolWithAggregatesFilter<"Funnels"> | boolean
    subDomainName?: StringNullableWithAggregatesFilter<"Funnels"> | string | null
    favicon?: StringNullableWithAggregatesFilter<"Funnels"> | string | null
    subAccountId?: StringWithAggregatesFilter<"Funnels"> | string
    liveProducts?: StringNullableWithAggregatesFilter<"Funnels"> | string | null
  }

  export type NotificationsWhereInput = {
    AND?: NotificationsWhereInput | NotificationsWhereInput[]
    OR?: NotificationsWhereInput[]
    NOT?: NotificationsWhereInput | NotificationsWhereInput[]
    id?: StringFilter<"Notifications"> | string
    notification?: StringFilter<"Notifications"> | string
    agencyId?: StringFilter<"Notifications"> | string
    subAccountId?: StringNullableFilter<"Notifications"> | string | null
    userId?: StringFilter<"Notifications"> | string
    createdAt?: DateTimeFilter<"Notifications"> | Date | string
    updatedAt?: DateTimeFilter<"Notifications"> | Date | string
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    Agency?: XOR<AgencyScalarRelationFilter, AgencyWhereInput>
    SubAccounts?: XOR<SubAccountsNullableScalarRelationFilter, SubAccountsWhereInput> | null
  }

  export type NotificationsOrderByWithRelationInput = {
    id?: SortOrder
    notification?: SortOrder
    agencyId?: SortOrder
    subAccountId?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Users?: UsersOrderByWithRelationInput
    Agency?: AgencyOrderByWithRelationInput
    SubAccounts?: SubAccountsOrderByWithRelationInput
  }

  export type NotificationsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationsWhereInput | NotificationsWhereInput[]
    OR?: NotificationsWhereInput[]
    NOT?: NotificationsWhereInput | NotificationsWhereInput[]
    notification?: StringFilter<"Notifications"> | string
    agencyId?: StringFilter<"Notifications"> | string
    subAccountId?: StringNullableFilter<"Notifications"> | string | null
    userId?: StringFilter<"Notifications"> | string
    createdAt?: DateTimeFilter<"Notifications"> | Date | string
    updatedAt?: DateTimeFilter<"Notifications"> | Date | string
    Users?: XOR<UsersScalarRelationFilter, UsersWhereInput>
    Agency?: XOR<AgencyScalarRelationFilter, AgencyWhereInput>
    SubAccounts?: XOR<SubAccountsNullableScalarRelationFilter, SubAccountsWhereInput> | null
  }, "id">

  export type NotificationsOrderByWithAggregationInput = {
    id?: SortOrder
    notification?: SortOrder
    agencyId?: SortOrder
    subAccountId?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationsCountOrderByAggregateInput
    _max?: NotificationsMaxOrderByAggregateInput
    _min?: NotificationsMinOrderByAggregateInput
  }

  export type NotificationsScalarWhereWithAggregatesInput = {
    AND?: NotificationsScalarWhereWithAggregatesInput | NotificationsScalarWhereWithAggregatesInput[]
    OR?: NotificationsScalarWhereWithAggregatesInput[]
    NOT?: NotificationsScalarWhereWithAggregatesInput | NotificationsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notifications"> | string
    notification?: StringWithAggregatesFilter<"Notifications"> | string
    agencyId?: StringWithAggregatesFilter<"Notifications"> | string
    subAccountId?: StringNullableWithAggregatesFilter<"Notifications"> | string | null
    userId?: StringWithAggregatesFilter<"Notifications"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Notifications"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Notifications"> | Date | string
  }

  export type SubscriptionsWhereInput = {
    AND?: SubscriptionsWhereInput | SubscriptionsWhereInput[]
    OR?: SubscriptionsWhereInput[]
    NOT?: SubscriptionsWhereInput | SubscriptionsWhereInput[]
    id?: StringFilter<"Subscriptions"> | string
    createdAt?: DateTimeFilter<"Subscriptions"> | Date | string
    updatedAt?: DateTimeFilter<"Subscriptions"> | Date | string
    plan?: EnumPlansNullableFilter<"Subscriptions"> | $Enums.Plans | null
    price?: StringNullableFilter<"Subscriptions"> | string | null
    active?: BoolFilter<"Subscriptions"> | boolean
    priceId?: StringFilter<"Subscriptions"> | string
    customerId?: StringFilter<"Subscriptions"> | string
    currentPeriodEndDate?: DateTimeFilter<"Subscriptions"> | Date | string
    subscriptionId?: StringFilter<"Subscriptions"> | string
    agencyId?: StringNullableFilter<"Subscriptions"> | string | null
    Agency?: XOR<AgencyNullableScalarRelationFilter, AgencyWhereInput> | null
  }

  export type SubscriptionsOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    plan?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    active?: SortOrder
    priceId?: SortOrder
    customerId?: SortOrder
    currentPeriodEndDate?: SortOrder
    subscriptionId?: SortOrder
    agencyId?: SortOrderInput | SortOrder
    Agency?: AgencyOrderByWithRelationInput
  }

  export type SubscriptionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    subscriptionId?: string
    agencyId?: string
    AND?: SubscriptionsWhereInput | SubscriptionsWhereInput[]
    OR?: SubscriptionsWhereInput[]
    NOT?: SubscriptionsWhereInput | SubscriptionsWhereInput[]
    createdAt?: DateTimeFilter<"Subscriptions"> | Date | string
    updatedAt?: DateTimeFilter<"Subscriptions"> | Date | string
    plan?: EnumPlansNullableFilter<"Subscriptions"> | $Enums.Plans | null
    price?: StringNullableFilter<"Subscriptions"> | string | null
    active?: BoolFilter<"Subscriptions"> | boolean
    priceId?: StringFilter<"Subscriptions"> | string
    customerId?: StringFilter<"Subscriptions"> | string
    currentPeriodEndDate?: DateTimeFilter<"Subscriptions"> | Date | string
    Agency?: XOR<AgencyNullableScalarRelationFilter, AgencyWhereInput> | null
  }, "id" | "subscriptionId" | "agencyId">

  export type SubscriptionsOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    plan?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    active?: SortOrder
    priceId?: SortOrder
    customerId?: SortOrder
    currentPeriodEndDate?: SortOrder
    subscriptionId?: SortOrder
    agencyId?: SortOrderInput | SortOrder
    _count?: SubscriptionsCountOrderByAggregateInput
    _max?: SubscriptionsMaxOrderByAggregateInput
    _min?: SubscriptionsMinOrderByAggregateInput
  }

  export type SubscriptionsScalarWhereWithAggregatesInput = {
    AND?: SubscriptionsScalarWhereWithAggregatesInput | SubscriptionsScalarWhereWithAggregatesInput[]
    OR?: SubscriptionsScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionsScalarWhereWithAggregatesInput | SubscriptionsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Subscriptions"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Subscriptions"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Subscriptions"> | Date | string
    plan?: EnumPlansNullableWithAggregatesFilter<"Subscriptions"> | $Enums.Plans | null
    price?: StringNullableWithAggregatesFilter<"Subscriptions"> | string | null
    active?: BoolWithAggregatesFilter<"Subscriptions"> | boolean
    priceId?: StringWithAggregatesFilter<"Subscriptions"> | string
    customerId?: StringWithAggregatesFilter<"Subscriptions"> | string
    currentPeriodEndDate?: DateTimeWithAggregatesFilter<"Subscriptions"> | Date | string
    subscriptionId?: StringWithAggregatesFilter<"Subscriptions"> | string
    agencyId?: StringNullableWithAggregatesFilter<"Subscriptions"> | string | null
  }

  export type ClassNameWhereInput = {
    AND?: ClassNameWhereInput | ClassNameWhereInput[]
    OR?: ClassNameWhereInput[]
    NOT?: ClassNameWhereInput | ClassNameWhereInput[]
    id?: StringFilter<"ClassName"> | string
    name?: StringFilter<"ClassName"> | string
    color?: StringFilter<"ClassName"> | string
    createdAt?: DateTimeFilter<"ClassName"> | Date | string
    updatedAt?: DateTimeFilter<"ClassName"> | Date | string
    funnelId?: StringFilter<"ClassName"> | string
    customData?: StringNullableFilter<"ClassName"> | string | null
    Funnel?: XOR<FunnelsScalarRelationFilter, FunnelsWhereInput>
  }

  export type ClassNameOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    funnelId?: SortOrder
    customData?: SortOrderInput | SortOrder
    Funnel?: FunnelsOrderByWithRelationInput
  }

  export type ClassNameWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClassNameWhereInput | ClassNameWhereInput[]
    OR?: ClassNameWhereInput[]
    NOT?: ClassNameWhereInput | ClassNameWhereInput[]
    name?: StringFilter<"ClassName"> | string
    color?: StringFilter<"ClassName"> | string
    createdAt?: DateTimeFilter<"ClassName"> | Date | string
    updatedAt?: DateTimeFilter<"ClassName"> | Date | string
    funnelId?: StringFilter<"ClassName"> | string
    customData?: StringNullableFilter<"ClassName"> | string | null
    Funnel?: XOR<FunnelsScalarRelationFilter, FunnelsWhereInput>
  }, "id">

  export type ClassNameOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    funnelId?: SortOrder
    customData?: SortOrderInput | SortOrder
    _count?: ClassNameCountOrderByAggregateInput
    _max?: ClassNameMaxOrderByAggregateInput
    _min?: ClassNameMinOrderByAggregateInput
  }

  export type ClassNameScalarWhereWithAggregatesInput = {
    AND?: ClassNameScalarWhereWithAggregatesInput | ClassNameScalarWhereWithAggregatesInput[]
    OR?: ClassNameScalarWhereWithAggregatesInput[]
    NOT?: ClassNameScalarWhereWithAggregatesInput | ClassNameScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClassName"> | string
    name?: StringWithAggregatesFilter<"ClassName"> | string
    color?: StringWithAggregatesFilter<"ClassName"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ClassName"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ClassName"> | Date | string
    funnelId?: StringWithAggregatesFilter<"ClassName"> | string
    customData?: StringNullableWithAggregatesFilter<"ClassName"> | string | null
  }

  export type FunelPagesWhereInput = {
    AND?: FunelPagesWhereInput | FunelPagesWhereInput[]
    OR?: FunelPagesWhereInput[]
    NOT?: FunelPagesWhereInput | FunelPagesWhereInput[]
    id?: StringFilter<"FunelPages"> | string
    name?: StringFilter<"FunelPages"> | string
    pathName?: StringFilter<"FunelPages"> | string
    createdAt?: DateTimeFilter<"FunelPages"> | Date | string
    updatedAt?: DateTimeFilter<"FunelPages"> | Date | string
    visits?: IntFilter<"FunelPages"> | number
    content?: StringNullableFilter<"FunelPages"> | string | null
    order?: IntFilter<"FunelPages"> | number
    previewImage?: StringFilter<"FunelPages"> | string
    funnelId?: StringFilter<"FunelPages"> | string
    Funnel?: XOR<FunnelsScalarRelationFilter, FunnelsWhereInput>
  }

  export type FunelPagesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    pathName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    visits?: SortOrder
    content?: SortOrderInput | SortOrder
    order?: SortOrder
    previewImage?: SortOrder
    funnelId?: SortOrder
    Funnel?: FunnelsOrderByWithRelationInput
  }

  export type FunelPagesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FunelPagesWhereInput | FunelPagesWhereInput[]
    OR?: FunelPagesWhereInput[]
    NOT?: FunelPagesWhereInput | FunelPagesWhereInput[]
    name?: StringFilter<"FunelPages"> | string
    pathName?: StringFilter<"FunelPages"> | string
    createdAt?: DateTimeFilter<"FunelPages"> | Date | string
    updatedAt?: DateTimeFilter<"FunelPages"> | Date | string
    visits?: IntFilter<"FunelPages"> | number
    content?: StringNullableFilter<"FunelPages"> | string | null
    order?: IntFilter<"FunelPages"> | number
    previewImage?: StringFilter<"FunelPages"> | string
    funnelId?: StringFilter<"FunelPages"> | string
    Funnel?: XOR<FunnelsScalarRelationFilter, FunnelsWhereInput>
  }, "id">

  export type FunelPagesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    pathName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    visits?: SortOrder
    content?: SortOrderInput | SortOrder
    order?: SortOrder
    previewImage?: SortOrder
    funnelId?: SortOrder
    _count?: FunelPagesCountOrderByAggregateInput
    _avg?: FunelPagesAvgOrderByAggregateInput
    _max?: FunelPagesMaxOrderByAggregateInput
    _min?: FunelPagesMinOrderByAggregateInput
    _sum?: FunelPagesSumOrderByAggregateInput
  }

  export type FunelPagesScalarWhereWithAggregatesInput = {
    AND?: FunelPagesScalarWhereWithAggregatesInput | FunelPagesScalarWhereWithAggregatesInput[]
    OR?: FunelPagesScalarWhereWithAggregatesInput[]
    NOT?: FunelPagesScalarWhereWithAggregatesInput | FunelPagesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FunelPages"> | string
    name?: StringWithAggregatesFilter<"FunelPages"> | string
    pathName?: StringWithAggregatesFilter<"FunelPages"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FunelPages"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FunelPages"> | Date | string
    visits?: IntWithAggregatesFilter<"FunelPages"> | number
    content?: StringNullableWithAggregatesFilter<"FunelPages"> | string | null
    order?: IntWithAggregatesFilter<"FunelPages"> | number
    previewImage?: StringWithAggregatesFilter<"FunelPages"> | string
    funnelId?: StringWithAggregatesFilter<"FunelPages"> | string
  }

  export type AddOnsWhereInput = {
    AND?: AddOnsWhereInput | AddOnsWhereInput[]
    OR?: AddOnsWhereInput[]
    NOT?: AddOnsWhereInput | AddOnsWhereInput[]
    id?: StringFilter<"AddOns"> | string
    createdAt?: DateTimeFilter<"AddOns"> | Date | string
    updatedAt?: DateTimeFilter<"AddOns"> | Date | string
    name?: StringFilter<"AddOns"> | string
    active?: BoolFilter<"AddOns"> | boolean
    priceId?: StringFilter<"AddOns"> | string
    agencyId?: StringNullableFilter<"AddOns"> | string | null
    Agency?: XOR<AgencyNullableScalarRelationFilter, AgencyWhereInput> | null
  }

  export type AddOnsOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    active?: SortOrder
    priceId?: SortOrder
    agencyId?: SortOrderInput | SortOrder
    Agency?: AgencyOrderByWithRelationInput
  }

  export type AddOnsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    priceId?: string
    AND?: AddOnsWhereInput | AddOnsWhereInput[]
    OR?: AddOnsWhereInput[]
    NOT?: AddOnsWhereInput | AddOnsWhereInput[]
    createdAt?: DateTimeFilter<"AddOns"> | Date | string
    updatedAt?: DateTimeFilter<"AddOns"> | Date | string
    name?: StringFilter<"AddOns"> | string
    active?: BoolFilter<"AddOns"> | boolean
    agencyId?: StringNullableFilter<"AddOns"> | string | null
    Agency?: XOR<AgencyNullableScalarRelationFilter, AgencyWhereInput> | null
  }, "id" | "priceId">

  export type AddOnsOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    active?: SortOrder
    priceId?: SortOrder
    agencyId?: SortOrderInput | SortOrder
    _count?: AddOnsCountOrderByAggregateInput
    _max?: AddOnsMaxOrderByAggregateInput
    _min?: AddOnsMinOrderByAggregateInput
  }

  export type AddOnsScalarWhereWithAggregatesInput = {
    AND?: AddOnsScalarWhereWithAggregatesInput | AddOnsScalarWhereWithAggregatesInput[]
    OR?: AddOnsScalarWhereWithAggregatesInput[]
    NOT?: AddOnsScalarWhereWithAggregatesInput | AddOnsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AddOns"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AddOns"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AddOns"> | Date | string
    name?: StringWithAggregatesFilter<"AddOns"> | string
    active?: BoolWithAggregatesFilter<"AddOns"> | boolean
    priceId?: StringWithAggregatesFilter<"AddOns"> | string
    agencyId?: StringNullableWithAggregatesFilter<"AddOns"> | string | null
  }

  export type UsersCreateInput = {
    id?: string
    name: string
    avatarUrl: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.Role
    Agency?: AgencyCreateNestedOneWithoutUserInput
    Permission?: PermissionsCreateNestedManyWithoutUsersInput
    Ticket?: TicketsCreateNestedManyWithoutUsersInput
    Notification?: NotificationsCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateInput = {
    id?: string
    name: string
    avatarUrl: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.Role
    agencyId?: string | null
    Permission?: PermissionsUncheckedCreateNestedManyWithoutUsersInput
    Ticket?: TicketsUncheckedCreateNestedManyWithoutUsersInput
    Notification?: NotificationsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    Agency?: AgencyUpdateOneWithoutUserNestedInput
    Permission?: PermissionsUpdateManyWithoutUsersNestedInput
    Ticket?: TicketsUpdateManyWithoutUsersNestedInput
    Notification?: NotificationsUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
    Permission?: PermissionsUncheckedUpdateManyWithoutUsersNestedInput
    Ticket?: TicketsUncheckedUpdateManyWithoutUsersNestedInput
    Notification?: NotificationsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UsersCreateManyInput = {
    id?: string
    name: string
    avatarUrl: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.Role
    agencyId?: string | null
  }

  export type UsersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
  }

  export type UsersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PermissionsCreateInput = {
    id?: string
    access: boolean
    Users: UsersCreateNestedOneWithoutPermissionInput
    SubAcctount: SubAccountsCreateNestedOneWithoutPermissionsInput
  }

  export type PermissionsUncheckedCreateInput = {
    id?: string
    email: string
    subAccontId: string
    access: boolean
  }

  export type PermissionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    access?: BoolFieldUpdateOperationsInput | boolean
    Users?: UsersUpdateOneRequiredWithoutPermissionNestedInput
    SubAcctount?: SubAccountsUpdateOneRequiredWithoutPermissionsNestedInput
  }

  export type PermissionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subAccontId?: StringFieldUpdateOperationsInput | string
    access?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PermissionsCreateManyInput = {
    id?: string
    email: string
    subAccontId: string
    access: boolean
  }

  export type PermissionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    access?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PermissionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subAccontId?: StringFieldUpdateOperationsInput | string
    access?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AgencyCreateInput = {
    id?: string
    connectAccountId?: string | null
    customerId?: string
    name: string
    agencyLogo: string
    companyEmail: string
    companyPhone: string
    whiteLabel?: boolean
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    goal: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UsersCreateNestedManyWithoutAgencyInput
    SubAccount?: SubAccountsCreateNestedManyWithoutAgencyInput
    SidebarOption?: AgencySidebarOptionCreateNestedManyWithoutAgencyInput
    Invitation?: InvitationsCreateNestedManyWithoutAgencyInput
    Notification?: NotificationsCreateNestedManyWithoutAgencyInput
    Subscription?: SubscriptionsCreateNestedOneWithoutAgencyInput
    AddOns?: AddOnsCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUncheckedCreateInput = {
    id?: string
    connectAccountId?: string | null
    customerId?: string
    name: string
    agencyLogo: string
    companyEmail: string
    companyPhone: string
    whiteLabel?: boolean
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    goal: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UsersUncheckedCreateNestedManyWithoutAgencyInput
    SubAccount?: SubAccountsUncheckedCreateNestedManyWithoutAgencyInput
    SidebarOption?: AgencySidebarOptionUncheckedCreateNestedManyWithoutAgencyInput
    Invitation?: InvitationsUncheckedCreateNestedManyWithoutAgencyInput
    Notification?: NotificationsUncheckedCreateNestedManyWithoutAgencyInput
    Subscription?: SubscriptionsUncheckedCreateNestedOneWithoutAgencyInput
    AddOns?: AddOnsUncheckedCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    agencyLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    whiteLabel?: BoolFieldUpdateOperationsInput | boolean
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateManyWithoutAgencyNestedInput
    SubAccount?: SubAccountsUpdateManyWithoutAgencyNestedInput
    SidebarOption?: AgencySidebarOptionUpdateManyWithoutAgencyNestedInput
    Invitation?: InvitationsUpdateManyWithoutAgencyNestedInput
    Notification?: NotificationsUpdateManyWithoutAgencyNestedInput
    Subscription?: SubscriptionsUpdateOneWithoutAgencyNestedInput
    AddOns?: AddOnsUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    agencyLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    whiteLabel?: BoolFieldUpdateOperationsInput | boolean
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUncheckedUpdateManyWithoutAgencyNestedInput
    SubAccount?: SubAccountsUncheckedUpdateManyWithoutAgencyNestedInput
    SidebarOption?: AgencySidebarOptionUncheckedUpdateManyWithoutAgencyNestedInput
    Invitation?: InvitationsUncheckedUpdateManyWithoutAgencyNestedInput
    Notification?: NotificationsUncheckedUpdateManyWithoutAgencyNestedInput
    Subscription?: SubscriptionsUncheckedUpdateOneWithoutAgencyNestedInput
    AddOns?: AddOnsUncheckedUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyCreateManyInput = {
    id?: string
    connectAccountId?: string | null
    customerId?: string
    name: string
    agencyLogo: string
    companyEmail: string
    companyPhone: string
    whiteLabel?: boolean
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    goal: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgencyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    agencyLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    whiteLabel?: BoolFieldUpdateOperationsInput | boolean
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    agencyLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    whiteLabel?: BoolFieldUpdateOperationsInput | boolean
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencySidebarOptionCreateInput = {
    id?: string
    name?: string
    link?: string
    icon?: $Enums.Icon
    createdAt?: Date | string
    updatedAt?: Date | string
    Agency: AgencyCreateNestedOneWithoutSidebarOptionInput
    SubAccounts?: SubAccountsCreateNestedOneWithoutSidebarOptionInput
  }

  export type AgencySidebarOptionUncheckedCreateInput = {
    id?: string
    name?: string
    link?: string
    icon?: $Enums.Icon
    createdAt?: Date | string
    updatedAt?: Date | string
    agencyId: string
    subAccountId?: string | null
  }

  export type AgencySidebarOptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    icon?: EnumIconFieldUpdateOperationsInput | $Enums.Icon
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Agency?: AgencyUpdateOneRequiredWithoutSidebarOptionNestedInput
    SubAccounts?: SubAccountsUpdateOneWithoutSidebarOptionNestedInput
  }

  export type AgencySidebarOptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    icon?: EnumIconFieldUpdateOperationsInput | $Enums.Icon
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agencyId?: StringFieldUpdateOperationsInput | string
    subAccountId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AgencySidebarOptionCreateManyInput = {
    id?: string
    name?: string
    link?: string
    icon?: $Enums.Icon
    createdAt?: Date | string
    updatedAt?: Date | string
    agencyId: string
    subAccountId?: string | null
  }

  export type AgencySidebarOptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    icon?: EnumIconFieldUpdateOperationsInput | $Enums.Icon
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgencySidebarOptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    icon?: EnumIconFieldUpdateOperationsInput | $Enums.Icon
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agencyId?: StringFieldUpdateOperationsInput | string
    subAccountId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubAccountsCreateInput = {
    id?: string
    connectAccountId?: string | null
    name: string
    subAcctountLogo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    Agency: AgencyCreateNestedOneWithoutSubAccountInput
    SidebarOption?: AgencySidebarOptionCreateNestedManyWithoutSubAccountsInput
    Permissions?: PermissionsCreateNestedManyWithoutSubAcctountInput
    Funnels?: FunnelsCreateNestedManyWithoutSubAccountInput
    Media?: MediaCreateNestedManyWithoutSubAccountsInput
    Contact?: ContactsCreateNestedManyWithoutSubAccountsInput
    Trigger?: TriggersCreateNestedManyWithoutSubAccountsInput
    Automation?: AutomationsCreateNestedManyWithoutSubAccountsInput
    Pipeline?: PipelinesCreateNestedManyWithoutSubAccountInput
    Tags?: TagsCreateNestedManyWithoutSubAccountsInput
    Notification?: NotificationsCreateNestedManyWithoutSubAccountsInput
    SubAccountSidebarOption?: SubAccountSidebarOptionCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountsUncheckedCreateInput = {
    id?: string
    connectAccountId?: string | null
    name: string
    subAcctountLogo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    agencyId: string
    SidebarOption?: AgencySidebarOptionUncheckedCreateNestedManyWithoutSubAccountsInput
    Permissions?: PermissionsUncheckedCreateNestedManyWithoutSubAcctountInput
    Funnels?: FunnelsUncheckedCreateNestedManyWithoutSubAccountInput
    Media?: MediaUncheckedCreateNestedManyWithoutSubAccountsInput
    Contact?: ContactsUncheckedCreateNestedManyWithoutSubAccountsInput
    Trigger?: TriggersUncheckedCreateNestedManyWithoutSubAccountsInput
    Automation?: AutomationsUncheckedCreateNestedManyWithoutSubAccountsInput
    Pipeline?: PipelinesUncheckedCreateNestedManyWithoutSubAccountInput
    Tags?: TagsUncheckedCreateNestedManyWithoutSubAccountsInput
    Notification?: NotificationsUncheckedCreateNestedManyWithoutSubAccountsInput
    SubAccountSidebarOption?: SubAccountSidebarOptionUncheckedCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAcctountLogo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    Agency?: AgencyUpdateOneRequiredWithoutSubAccountNestedInput
    SidebarOption?: AgencySidebarOptionUpdateManyWithoutSubAccountsNestedInput
    Permissions?: PermissionsUpdateManyWithoutSubAcctountNestedInput
    Funnels?: FunnelsUpdateManyWithoutSubAccountNestedInput
    Media?: MediaUpdateManyWithoutSubAccountsNestedInput
    Contact?: ContactsUpdateManyWithoutSubAccountsNestedInput
    Trigger?: TriggersUpdateManyWithoutSubAccountsNestedInput
    Automation?: AutomationsUpdateManyWithoutSubAccountsNestedInput
    Pipeline?: PipelinesUpdateManyWithoutSubAccountNestedInput
    Tags?: TagsUpdateManyWithoutSubAccountsNestedInput
    Notification?: NotificationsUpdateManyWithoutSubAccountsNestedInput
    SubAccountSidebarOption?: SubAccountSidebarOptionUpdateManyWithoutSubAccountNestedInput
  }

  export type SubAccountsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAcctountLogo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    SidebarOption?: AgencySidebarOptionUncheckedUpdateManyWithoutSubAccountsNestedInput
    Permissions?: PermissionsUncheckedUpdateManyWithoutSubAcctountNestedInput
    Funnels?: FunnelsUncheckedUpdateManyWithoutSubAccountNestedInput
    Media?: MediaUncheckedUpdateManyWithoutSubAccountsNestedInput
    Contact?: ContactsUncheckedUpdateManyWithoutSubAccountsNestedInput
    Trigger?: TriggersUncheckedUpdateManyWithoutSubAccountsNestedInput
    Automation?: AutomationsUncheckedUpdateManyWithoutSubAccountsNestedInput
    Pipeline?: PipelinesUncheckedUpdateManyWithoutSubAccountNestedInput
    Tags?: TagsUncheckedUpdateManyWithoutSubAccountsNestedInput
    Notification?: NotificationsUncheckedUpdateManyWithoutSubAccountsNestedInput
    SubAccountSidebarOption?: SubAccountSidebarOptionUncheckedUpdateManyWithoutSubAccountNestedInput
  }

  export type SubAccountsCreateManyInput = {
    id?: string
    connectAccountId?: string | null
    name: string
    subAcctountLogo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    agencyId: string
  }

  export type SubAccountsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAcctountLogo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
  }

  export type SubAccountsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAcctountLogo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
  }

  export type PipelinesCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Lane?: LaneCreateNestedManyWithoutPipelineInput
    SubAccount: SubAccountsCreateNestedOneWithoutPipelineInput
  }

  export type PipelinesUncheckedCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subAccountId: string
    Lane?: LaneUncheckedCreateNestedManyWithoutPipelineInput
  }

  export type PipelinesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Lane?: LaneUpdateManyWithoutPipelineNestedInput
    SubAccount?: SubAccountsUpdateOneRequiredWithoutPipelineNestedInput
  }

  export type PipelinesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subAccountId?: StringFieldUpdateOperationsInput | string
    Lane?: LaneUncheckedUpdateManyWithoutPipelineNestedInput
  }

  export type PipelinesCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subAccountId: string
  }

  export type PipelinesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PipelinesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subAccountId?: StringFieldUpdateOperationsInput | string
  }

  export type TriggersCreateInput = {
    id?: string
    name: string
    type: $Enums.TriggerTypes
    createdAt?: Date | string
    updatedAt?: Date | string
    SubAccounts: SubAccountsCreateNestedOneWithoutTriggerInput
    Automations?: AutomationsCreateNestedManyWithoutTriggerInput
  }

  export type TriggersUncheckedCreateInput = {
    id?: string
    name: string
    type: $Enums.TriggerTypes
    createdAt?: Date | string
    updatedAt?: Date | string
    subAccountId: string
    Automations?: AutomationsUncheckedCreateNestedManyWithoutTriggerInput
  }

  export type TriggersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTriggerTypesFieldUpdateOperationsInput | $Enums.TriggerTypes
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SubAccounts?: SubAccountsUpdateOneRequiredWithoutTriggerNestedInput
    Automations?: AutomationsUpdateManyWithoutTriggerNestedInput
  }

  export type TriggersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTriggerTypesFieldUpdateOperationsInput | $Enums.TriggerTypes
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subAccountId?: StringFieldUpdateOperationsInput | string
    Automations?: AutomationsUncheckedUpdateManyWithoutTriggerNestedInput
  }

  export type TriggersCreateManyInput = {
    id?: string
    name: string
    type: $Enums.TriggerTypes
    createdAt?: Date | string
    updatedAt?: Date | string
    subAccountId: string
  }

  export type TriggersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTriggerTypesFieldUpdateOperationsInput | $Enums.TriggerTypes
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TriggersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTriggerTypesFieldUpdateOperationsInput | $Enums.TriggerTypes
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subAccountId?: StringFieldUpdateOperationsInput | string
  }

  export type AutomationsCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    published?: boolean
    Trigger?: TriggersCreateNestedOneWithoutAutomationsInput
    SubAccounts: SubAccountsCreateNestedOneWithoutAutomationInput
    Actions?: ActionsCreateNestedManyWithoutAutomationsInput
    AutomationInstance?: AutomationInstanceCreateNestedManyWithoutAutomationsInput
  }

  export type AutomationsUncheckedCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    triggerId?: string | null
    published?: boolean
    subAccountId: string
    Actions?: ActionsUncheckedCreateNestedManyWithoutAutomationsInput
    AutomationInstance?: AutomationInstanceUncheckedCreateNestedManyWithoutAutomationsInput
  }

  export type AutomationsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    published?: BoolFieldUpdateOperationsInput | boolean
    Trigger?: TriggersUpdateOneWithoutAutomationsNestedInput
    SubAccounts?: SubAccountsUpdateOneRequiredWithoutAutomationNestedInput
    Actions?: ActionsUpdateManyWithoutAutomationsNestedInput
    AutomationInstance?: AutomationInstanceUpdateManyWithoutAutomationsNestedInput
  }

  export type AutomationsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    triggerId?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    subAccountId?: StringFieldUpdateOperationsInput | string
    Actions?: ActionsUncheckedUpdateManyWithoutAutomationsNestedInput
    AutomationInstance?: AutomationInstanceUncheckedUpdateManyWithoutAutomationsNestedInput
  }

  export type AutomationsCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    triggerId?: string | null
    published?: boolean
    subAccountId: string
  }

  export type AutomationsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    published?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AutomationsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    triggerId?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    subAccountId?: StringFieldUpdateOperationsInput | string
  }

  export type AutomationInstanceCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    active?: boolean
    Automations: AutomationsCreateNestedOneWithoutAutomationInstanceInput
  }

  export type AutomationInstanceUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    automationId: string
    active?: boolean
  }

  export type AutomationInstanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    Automations?: AutomationsUpdateOneRequiredWithoutAutomationInstanceNestedInput
  }

  export type AutomationInstanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    automationId?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AutomationInstanceCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    automationId: string
    active?: boolean
  }

  export type AutomationInstanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AutomationInstanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    automationId?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ActionsCreateInput = {
    id?: string
    name: string
    type: $Enums.ActionType
    createdAt?: Date | string
    updatedAt?: Date | string
    order: number
    laneId?: string
    Automations: AutomationsCreateNestedOneWithoutActionsInput
  }

  export type ActionsUncheckedCreateInput = {
    id?: string
    name: string
    type: $Enums.ActionType
    createdAt?: Date | string
    updatedAt?: Date | string
    automatedId: string
    order: number
    laneId?: string
  }

  export type ActionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumActionTypeFieldUpdateOperationsInput | $Enums.ActionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: IntFieldUpdateOperationsInput | number
    laneId?: StringFieldUpdateOperationsInput | string
    Automations?: AutomationsUpdateOneRequiredWithoutActionsNestedInput
  }

  export type ActionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumActionTypeFieldUpdateOperationsInput | $Enums.ActionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    automatedId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    laneId?: StringFieldUpdateOperationsInput | string
  }

  export type ActionsCreateManyInput = {
    id?: string
    name: string
    type: $Enums.ActionType
    createdAt?: Date | string
    updatedAt?: Date | string
    automatedId: string
    order: number
    laneId?: string
  }

  export type ActionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumActionTypeFieldUpdateOperationsInput | $Enums.ActionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: IntFieldUpdateOperationsInput | number
    laneId?: StringFieldUpdateOperationsInput | string
  }

  export type ActionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumActionTypeFieldUpdateOperationsInput | $Enums.ActionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    automatedId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    laneId?: StringFieldUpdateOperationsInput | string
  }

  export type ContactsCreateInput = {
    id?: string
    name: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    SubAccounts: SubAccountsCreateNestedOneWithoutContactInput
    Tickets?: TicketsCreateNestedManyWithoutContactsInput
  }

  export type ContactsUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subAccountId: string
    Tickets?: TicketsUncheckedCreateNestedManyWithoutContactsInput
  }

  export type ContactsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SubAccounts?: SubAccountsUpdateOneRequiredWithoutContactNestedInput
    Tickets?: TicketsUpdateManyWithoutContactsNestedInput
  }

  export type ContactsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subAccountId?: StringFieldUpdateOperationsInput | string
    Tickets?: TicketsUncheckedUpdateManyWithoutContactsNestedInput
  }

  export type ContactsCreateManyInput = {
    id?: string
    name: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subAccountId: string
  }

  export type ContactsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subAccountId?: StringFieldUpdateOperationsInput | string
  }

  export type MediaCreateInput = {
    id?: string
    type?: string | null
    name: string
    link: string
    createdAt?: Date | string
    updatedAt?: Date | string
    SubAccounts: SubAccountsCreateNestedOneWithoutMediaInput
  }

  export type MediaUncheckedCreateInput = {
    id?: string
    type?: string | null
    name: string
    link: string
    subAccountId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MediaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SubAccounts?: SubAccountsUpdateOneRequiredWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    subAccountId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaCreateManyInput = {
    id?: string
    type?: string | null
    name: string
    link: string
    subAccountId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MediaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    subAccountId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LaneCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: number
    Pipeline: PipelinesCreateNestedOneWithoutLaneInput
    Tickets?: TicketsCreateNestedManyWithoutLaneInput
  }

  export type LaneUncheckedCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    pipelineId: string
    order?: number
    Tickets?: TicketsUncheckedCreateNestedManyWithoutLaneInput
  }

  export type LaneUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: IntFieldUpdateOperationsInput | number
    Pipeline?: PipelinesUpdateOneRequiredWithoutLaneNestedInput
    Tickets?: TicketsUpdateManyWithoutLaneNestedInput
  }

  export type LaneUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pipelineId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    Tickets?: TicketsUncheckedUpdateManyWithoutLaneNestedInput
  }

  export type LaneCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    pipelineId: string
    order?: number
  }

  export type LaneUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type LaneUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pipelineId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type TicketsCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: number
    value?: Decimal | DecimalJsLike | number | string | null
    description?: string | null
    Lane: LaneCreateNestedOneWithoutTicketsInput
    tags?: TagsCreateNestedManyWithoutTicketsInput
    Users?: UsersCreateNestedOneWithoutTicketInput
    Contacts?: ContactsCreateNestedOneWithoutTicketsInput
  }

  export type TicketsUncheckedCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lineId: string
    order?: number
    value?: Decimal | DecimalJsLike | number | string | null
    description?: string | null
    userId?: string | null
    contactId?: string | null
    tags?: TagsUncheckedCreateNestedManyWithoutTicketsInput
  }

  export type TicketsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    Lane?: LaneUpdateOneRequiredWithoutTicketsNestedInput
    tags?: TagsUpdateManyWithoutTicketsNestedInput
    Users?: UsersUpdateOneWithoutTicketNestedInput
    Contacts?: ContactsUpdateOneWithoutTicketsNestedInput
  }

  export type TicketsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lineId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TagsUncheckedUpdateManyWithoutTicketsNestedInput
  }

  export type TicketsCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lineId: string
    order?: number
    value?: Decimal | DecimalJsLike | number | string | null
    description?: string | null
    userId?: string | null
    contactId?: string | null
  }

  export type TicketsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TicketsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lineId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TagsCreateInput = {
    id?: string
    nane: string
    color: string
    createdAt?: Date | string
    updatedAt?: Date | string
    SubAccounts: SubAccountsCreateNestedOneWithoutTagsInput
    Tickets?: TicketsCreateNestedManyWithoutTagsInput
  }

  export type TagsUncheckedCreateInput = {
    id?: string
    nane: string
    color: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subAccountId: string
    Tickets?: TicketsUncheckedCreateNestedManyWithoutTagsInput
  }

  export type TagsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nane?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SubAccounts?: SubAccountsUpdateOneRequiredWithoutTagsNestedInput
    Tickets?: TicketsUpdateManyWithoutTagsNestedInput
  }

  export type TagsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nane?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subAccountId?: StringFieldUpdateOperationsInput | string
    Tickets?: TicketsUncheckedUpdateManyWithoutTagsNestedInput
  }

  export type TagsCreateManyInput = {
    id?: string
    nane: string
    color: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subAccountId: string
  }

  export type TagsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nane?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nane?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subAccountId?: StringFieldUpdateOperationsInput | string
  }

  export type SubAccountSidebarOptionCreateInput = {
    id?: string
    name: string
    link?: string
    icon?: $Enums.Icon
    createdAt?: Date | string
    updatedAt?: Date | string
    subAccount?: string | null
    SubAccount?: SubAccountsCreateNestedOneWithoutSubAccountSidebarOptionInput
  }

  export type SubAccountSidebarOptionUncheckedCreateInput = {
    id?: string
    name: string
    link?: string
    icon?: $Enums.Icon
    createdAt?: Date | string
    updatedAt?: Date | string
    subAccountId: string
    subAccount?: string | null
  }

  export type SubAccountSidebarOptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    icon?: EnumIconFieldUpdateOperationsInput | $Enums.Icon
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subAccount?: NullableStringFieldUpdateOperationsInput | string | null
    SubAccount?: SubAccountsUpdateOneWithoutSubAccountSidebarOptionNestedInput
  }

  export type SubAccountSidebarOptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    icon?: EnumIconFieldUpdateOperationsInput | $Enums.Icon
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subAccountId?: StringFieldUpdateOperationsInput | string
    subAccount?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubAccountSidebarOptionCreateManyInput = {
    id?: string
    name: string
    link?: string
    icon?: $Enums.Icon
    createdAt?: Date | string
    updatedAt?: Date | string
    subAccountId: string
    subAccount?: string | null
  }

  export type SubAccountSidebarOptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    icon?: EnumIconFieldUpdateOperationsInput | $Enums.Icon
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subAccount?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubAccountSidebarOptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    icon?: EnumIconFieldUpdateOperationsInput | $Enums.Icon
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subAccountId?: StringFieldUpdateOperationsInput | string
    subAccount?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InvitationsCreateInput = {
    id?: string
    email: string
    status?: $Enums.InvitationStatus
    role?: $Enums.Role
    Agency: AgencyCreateNestedOneWithoutInvitationInput
  }

  export type InvitationsUncheckedCreateInput = {
    id?: string
    email: string
    agencyId: string
    status?: $Enums.InvitationStatus
    role?: $Enums.Role
  }

  export type InvitationsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    Agency?: AgencyUpdateOneRequiredWithoutInvitationNestedInput
  }

  export type InvitationsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
  }

  export type InvitationsCreateManyInput = {
    id?: string
    email: string
    agencyId: string
    status?: $Enums.InvitationStatus
    role?: $Enums.Role
  }

  export type InvitationsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
  }

  export type InvitationsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
  }

  export type FunnelsCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    published?: boolean
    subDomainName?: string | null
    favicon?: string | null
    liveProducts?: string | null
    SubAccount: SubAccountsCreateNestedOneWithoutFunnelsInput
    FunelPages?: FunelPagesCreateNestedManyWithoutFunnelInput
    className?: ClassNameCreateNestedManyWithoutFunnelInput
  }

  export type FunnelsUncheckedCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    published?: boolean
    subDomainName?: string | null
    favicon?: string | null
    subAccountId: string
    liveProducts?: string | null
    FunelPages?: FunelPagesUncheckedCreateNestedManyWithoutFunnelInput
    className?: ClassNameUncheckedCreateNestedManyWithoutFunnelInput
  }

  export type FunnelsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    subDomainName?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    liveProducts?: NullableStringFieldUpdateOperationsInput | string | null
    SubAccount?: SubAccountsUpdateOneRequiredWithoutFunnelsNestedInput
    FunelPages?: FunelPagesUpdateManyWithoutFunnelNestedInput
    className?: ClassNameUpdateManyWithoutFunnelNestedInput
  }

  export type FunnelsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    subDomainName?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    subAccountId?: StringFieldUpdateOperationsInput | string
    liveProducts?: NullableStringFieldUpdateOperationsInput | string | null
    FunelPages?: FunelPagesUncheckedUpdateManyWithoutFunnelNestedInput
    className?: ClassNameUncheckedUpdateManyWithoutFunnelNestedInput
  }

  export type FunnelsCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    published?: boolean
    subDomainName?: string | null
    favicon?: string | null
    subAccountId: string
    liveProducts?: string | null
  }

  export type FunnelsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    subDomainName?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    liveProducts?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FunnelsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    subDomainName?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    subAccountId?: StringFieldUpdateOperationsInput | string
    liveProducts?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationsCreateInput = {
    id?: string
    notification: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Users: UsersCreateNestedOneWithoutNotificationInput
    Agency: AgencyCreateNestedOneWithoutNotificationInput
    SubAccounts?: SubAccountsCreateNestedOneWithoutNotificationInput
  }

  export type NotificationsUncheckedCreateInput = {
    id?: string
    notification: string
    agencyId: string
    subAccountId?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    notification?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Users?: UsersUpdateOneRequiredWithoutNotificationNestedInput
    Agency?: AgencyUpdateOneRequiredWithoutNotificationNestedInput
    SubAccounts?: SubAccountsUpdateOneWithoutNotificationNestedInput
  }

  export type NotificationsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    notification?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    subAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationsCreateManyInput = {
    id?: string
    notification: string
    agencyId: string
    subAccountId?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    notification?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    notification?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    subAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionsCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    plan?: $Enums.Plans | null
    price?: string | null
    active?: boolean
    priceId: string
    customerId: string
    currentPeriodEndDate: Date | string
    subscriptionId: string
    Agency?: AgencyCreateNestedOneWithoutSubscriptionInput
  }

  export type SubscriptionsUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    plan?: $Enums.Plans | null
    price?: string | null
    active?: boolean
    priceId: string
    customerId: string
    currentPeriodEndDate: Date | string
    subscriptionId: string
    agencyId?: string | null
  }

  export type SubscriptionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: NullableEnumPlansFieldUpdateOperationsInput | $Enums.Plans | null
    price?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    priceId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    currentPeriodEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    Agency?: AgencyUpdateOneWithoutSubscriptionNestedInput
  }

  export type SubscriptionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: NullableEnumPlansFieldUpdateOperationsInput | $Enums.Plans | null
    price?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    priceId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    currentPeriodEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubscriptionsCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    plan?: $Enums.Plans | null
    price?: string | null
    active?: boolean
    priceId: string
    customerId: string
    currentPeriodEndDate: Date | string
    subscriptionId: string
    agencyId?: string | null
  }

  export type SubscriptionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: NullableEnumPlansFieldUpdateOperationsInput | $Enums.Plans | null
    price?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    priceId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    currentPeriodEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
  }

  export type SubscriptionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: NullableEnumPlansFieldUpdateOperationsInput | $Enums.Plans | null
    price?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    priceId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    currentPeriodEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClassNameCreateInput = {
    id?: string
    name: string
    color: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customData?: string | null
    Funnel: FunnelsCreateNestedOneWithoutClassNameInput
  }

  export type ClassNameUncheckedCreateInput = {
    id?: string
    name: string
    color: string
    createdAt?: Date | string
    updatedAt?: Date | string
    funnelId: string
    customData?: string | null
  }

  export type ClassNameUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customData?: NullableStringFieldUpdateOperationsInput | string | null
    Funnel?: FunnelsUpdateOneRequiredWithoutClassNameNestedInput
  }

  export type ClassNameUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    funnelId?: StringFieldUpdateOperationsInput | string
    customData?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClassNameCreateManyInput = {
    id?: string
    name: string
    color: string
    createdAt?: Date | string
    updatedAt?: Date | string
    funnelId: string
    customData?: string | null
  }

  export type ClassNameUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customData?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClassNameUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    funnelId?: StringFieldUpdateOperationsInput | string
    customData?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FunelPagesCreateInput = {
    id?: string
    name: string
    pathName?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    visits?: number
    content?: string | null
    order: number
    previewImage: string
    Funnel: FunnelsCreateNestedOneWithoutFunelPagesInput
  }

  export type FunelPagesUncheckedCreateInput = {
    id?: string
    name: string
    pathName?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    visits?: number
    content?: string | null
    order: number
    previewImage: string
    funnelId: string
  }

  export type FunelPagesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pathName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visits?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    previewImage?: StringFieldUpdateOperationsInput | string
    Funnel?: FunnelsUpdateOneRequiredWithoutFunelPagesNestedInput
  }

  export type FunelPagesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pathName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visits?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    previewImage?: StringFieldUpdateOperationsInput | string
    funnelId?: StringFieldUpdateOperationsInput | string
  }

  export type FunelPagesCreateManyInput = {
    id?: string
    name: string
    pathName?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    visits?: number
    content?: string | null
    order: number
    previewImage: string
    funnelId: string
  }

  export type FunelPagesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pathName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visits?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    previewImage?: StringFieldUpdateOperationsInput | string
  }

  export type FunelPagesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pathName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visits?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    previewImage?: StringFieldUpdateOperationsInput | string
    funnelId?: StringFieldUpdateOperationsInput | string
  }

  export type AddOnsCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    active?: boolean
    priceId: string
    Agency?: AgencyCreateNestedOneWithoutAddOnsInput
  }

  export type AddOnsUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    active?: boolean
    priceId: string
    agencyId?: string | null
  }

  export type AddOnsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    priceId?: StringFieldUpdateOperationsInput | string
    Agency?: AgencyUpdateOneWithoutAddOnsNestedInput
  }

  export type AddOnsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    priceId?: StringFieldUpdateOperationsInput | string
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AddOnsCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    active?: boolean
    priceId: string
    agencyId?: string | null
  }

  export type AddOnsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    priceId?: StringFieldUpdateOperationsInput | string
  }

  export type AddOnsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    priceId?: StringFieldUpdateOperationsInput | string
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type AgencyNullableScalarRelationFilter = {
    is?: AgencyWhereInput | null
    isNot?: AgencyWhereInput | null
  }

  export type PermissionsListRelationFilter = {
    every?: PermissionsWhereInput
    some?: PermissionsWhereInput
    none?: PermissionsWhereInput
  }

  export type TicketsListRelationFilter = {
    every?: TicketsWhereInput
    some?: TicketsWhereInput
    none?: TicketsWhereInput
  }

  export type NotificationsListRelationFilter = {
    every?: NotificationsWhereInput
    some?: NotificationsWhereInput
    none?: NotificationsWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type PermissionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TicketsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsersCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    avatarUrl?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    role?: SortOrder
    agencyId?: SortOrder
  }

  export type UsersMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    avatarUrl?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    role?: SortOrder
    agencyId?: SortOrder
  }

  export type UsersMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    avatarUrl?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    role?: SortOrder
    agencyId?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type UsersScalarRelationFilter = {
    is?: UsersWhereInput
    isNot?: UsersWhereInput
  }

  export type SubAccountsScalarRelationFilter = {
    is?: SubAccountsWhereInput
    isNot?: SubAccountsWhereInput
  }

  export type PermissionsCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    subAccontId?: SortOrder
    access?: SortOrder
  }

  export type PermissionsMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    subAccontId?: SortOrder
    access?: SortOrder
  }

  export type PermissionsMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    subAccontId?: SortOrder
    access?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type UsersListRelationFilter = {
    every?: UsersWhereInput
    some?: UsersWhereInput
    none?: UsersWhereInput
  }

  export type SubAccountsListRelationFilter = {
    every?: SubAccountsWhereInput
    some?: SubAccountsWhereInput
    none?: SubAccountsWhereInput
  }

  export type AgencySidebarOptionListRelationFilter = {
    every?: AgencySidebarOptionWhereInput
    some?: AgencySidebarOptionWhereInput
    none?: AgencySidebarOptionWhereInput
  }

  export type InvitationsListRelationFilter = {
    every?: InvitationsWhereInput
    some?: InvitationsWhereInput
    none?: InvitationsWhereInput
  }

  export type SubscriptionsNullableScalarRelationFilter = {
    is?: SubscriptionsWhereInput | null
    isNot?: SubscriptionsWhereInput | null
  }

  export type AddOnsListRelationFilter = {
    every?: AddOnsWhereInput
    some?: AddOnsWhereInput
    none?: AddOnsWhereInput
  }

  export type UsersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubAccountsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgencySidebarOptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvitationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AddOnsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgencyCountOrderByAggregateInput = {
    id?: SortOrder
    connectAccountId?: SortOrder
    customerId?: SortOrder
    name?: SortOrder
    agencyLogo?: SortOrder
    companyEmail?: SortOrder
    companyPhone?: SortOrder
    whiteLabel?: SortOrder
    address?: SortOrder
    city?: SortOrder
    zipCode?: SortOrder
    state?: SortOrder
    country?: SortOrder
    goal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgencyAvgOrderByAggregateInput = {
    goal?: SortOrder
  }

  export type AgencyMaxOrderByAggregateInput = {
    id?: SortOrder
    connectAccountId?: SortOrder
    customerId?: SortOrder
    name?: SortOrder
    agencyLogo?: SortOrder
    companyEmail?: SortOrder
    companyPhone?: SortOrder
    whiteLabel?: SortOrder
    address?: SortOrder
    city?: SortOrder
    zipCode?: SortOrder
    state?: SortOrder
    country?: SortOrder
    goal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgencyMinOrderByAggregateInput = {
    id?: SortOrder
    connectAccountId?: SortOrder
    customerId?: SortOrder
    name?: SortOrder
    agencyLogo?: SortOrder
    companyEmail?: SortOrder
    companyPhone?: SortOrder
    whiteLabel?: SortOrder
    address?: SortOrder
    city?: SortOrder
    zipCode?: SortOrder
    state?: SortOrder
    country?: SortOrder
    goal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgencySumOrderByAggregateInput = {
    goal?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumIconFilter<$PrismaModel = never> = {
    equals?: $Enums.Icon | EnumIconFieldRefInput<$PrismaModel>
    in?: $Enums.Icon[] | ListEnumIconFieldRefInput<$PrismaModel>
    notIn?: $Enums.Icon[] | ListEnumIconFieldRefInput<$PrismaModel>
    not?: NestedEnumIconFilter<$PrismaModel> | $Enums.Icon
  }

  export type AgencyScalarRelationFilter = {
    is?: AgencyWhereInput
    isNot?: AgencyWhereInput
  }

  export type SubAccountsNullableScalarRelationFilter = {
    is?: SubAccountsWhereInput | null
    isNot?: SubAccountsWhereInput | null
  }

  export type AgencySidebarOptionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    link?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    agencyId?: SortOrder
    subAccountId?: SortOrder
  }

  export type AgencySidebarOptionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    link?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    agencyId?: SortOrder
    subAccountId?: SortOrder
  }

  export type AgencySidebarOptionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    link?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    agencyId?: SortOrder
    subAccountId?: SortOrder
  }

  export type EnumIconWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Icon | EnumIconFieldRefInput<$PrismaModel>
    in?: $Enums.Icon[] | ListEnumIconFieldRefInput<$PrismaModel>
    notIn?: $Enums.Icon[] | ListEnumIconFieldRefInput<$PrismaModel>
    not?: NestedEnumIconWithAggregatesFilter<$PrismaModel> | $Enums.Icon
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIconFilter<$PrismaModel>
    _max?: NestedEnumIconFilter<$PrismaModel>
  }

  export type FunnelsListRelationFilter = {
    every?: FunnelsWhereInput
    some?: FunnelsWhereInput
    none?: FunnelsWhereInput
  }

  export type MediaListRelationFilter = {
    every?: MediaWhereInput
    some?: MediaWhereInput
    none?: MediaWhereInput
  }

  export type ContactsListRelationFilter = {
    every?: ContactsWhereInput
    some?: ContactsWhereInput
    none?: ContactsWhereInput
  }

  export type TriggersListRelationFilter = {
    every?: TriggersWhereInput
    some?: TriggersWhereInput
    none?: TriggersWhereInput
  }

  export type AutomationsListRelationFilter = {
    every?: AutomationsWhereInput
    some?: AutomationsWhereInput
    none?: AutomationsWhereInput
  }

  export type PipelinesListRelationFilter = {
    every?: PipelinesWhereInput
    some?: PipelinesWhereInput
    none?: PipelinesWhereInput
  }

  export type TagsListRelationFilter = {
    every?: TagsWhereInput
    some?: TagsWhereInput
    none?: TagsWhereInput
  }

  export type SubAccountSidebarOptionListRelationFilter = {
    every?: SubAccountSidebarOptionWhereInput
    some?: SubAccountSidebarOptionWhereInput
    none?: SubAccountSidebarOptionWhereInput
  }

  export type FunnelsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MediaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContactsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TriggersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AutomationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PipelinesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TagsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubAccountSidebarOptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubAccountsCountOrderByAggregateInput = {
    id?: SortOrder
    connectAccountId?: SortOrder
    name?: SortOrder
    subAcctountLogo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyEmail?: SortOrder
    companyPhone?: SortOrder
    goal?: SortOrder
    address?: SortOrder
    city?: SortOrder
    zipCode?: SortOrder
    state?: SortOrder
    country?: SortOrder
    agencyId?: SortOrder
  }

  export type SubAccountsAvgOrderByAggregateInput = {
    goal?: SortOrder
  }

  export type SubAccountsMaxOrderByAggregateInput = {
    id?: SortOrder
    connectAccountId?: SortOrder
    name?: SortOrder
    subAcctountLogo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyEmail?: SortOrder
    companyPhone?: SortOrder
    goal?: SortOrder
    address?: SortOrder
    city?: SortOrder
    zipCode?: SortOrder
    state?: SortOrder
    country?: SortOrder
    agencyId?: SortOrder
  }

  export type SubAccountsMinOrderByAggregateInput = {
    id?: SortOrder
    connectAccountId?: SortOrder
    name?: SortOrder
    subAcctountLogo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyEmail?: SortOrder
    companyPhone?: SortOrder
    goal?: SortOrder
    address?: SortOrder
    city?: SortOrder
    zipCode?: SortOrder
    state?: SortOrder
    country?: SortOrder
    agencyId?: SortOrder
  }

  export type SubAccountsSumOrderByAggregateInput = {
    goal?: SortOrder
  }

  export type LaneListRelationFilter = {
    every?: LaneWhereInput
    some?: LaneWhereInput
    none?: LaneWhereInput
  }

  export type LaneOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PipelinesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subAccountId?: SortOrder
  }

  export type PipelinesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subAccountId?: SortOrder
  }

  export type PipelinesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subAccountId?: SortOrder
  }

  export type EnumTriggerTypesFilter<$PrismaModel = never> = {
    equals?: $Enums.TriggerTypes | EnumTriggerTypesFieldRefInput<$PrismaModel>
    in?: $Enums.TriggerTypes[] | ListEnumTriggerTypesFieldRefInput<$PrismaModel>
    notIn?: $Enums.TriggerTypes[] | ListEnumTriggerTypesFieldRefInput<$PrismaModel>
    not?: NestedEnumTriggerTypesFilter<$PrismaModel> | $Enums.TriggerTypes
  }

  export type TriggersCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subAccountId?: SortOrder
  }

  export type TriggersMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subAccountId?: SortOrder
  }

  export type TriggersMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subAccountId?: SortOrder
  }

  export type EnumTriggerTypesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TriggerTypes | EnumTriggerTypesFieldRefInput<$PrismaModel>
    in?: $Enums.TriggerTypes[] | ListEnumTriggerTypesFieldRefInput<$PrismaModel>
    notIn?: $Enums.TriggerTypes[] | ListEnumTriggerTypesFieldRefInput<$PrismaModel>
    not?: NestedEnumTriggerTypesWithAggregatesFilter<$PrismaModel> | $Enums.TriggerTypes
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTriggerTypesFilter<$PrismaModel>
    _max?: NestedEnumTriggerTypesFilter<$PrismaModel>
  }

  export type TriggersNullableScalarRelationFilter = {
    is?: TriggersWhereInput | null
    isNot?: TriggersWhereInput | null
  }

  export type ActionsListRelationFilter = {
    every?: ActionsWhereInput
    some?: ActionsWhereInput
    none?: ActionsWhereInput
  }

  export type AutomationInstanceListRelationFilter = {
    every?: AutomationInstanceWhereInput
    some?: AutomationInstanceWhereInput
    none?: AutomationInstanceWhereInput
  }

  export type ActionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AutomationInstanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AutomationsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    triggerId?: SortOrder
    published?: SortOrder
    subAccountId?: SortOrder
  }

  export type AutomationsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    triggerId?: SortOrder
    published?: SortOrder
    subAccountId?: SortOrder
  }

  export type AutomationsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    triggerId?: SortOrder
    published?: SortOrder
    subAccountId?: SortOrder
  }

  export type AutomationsScalarRelationFilter = {
    is?: AutomationsWhereInput
    isNot?: AutomationsWhereInput
  }

  export type AutomationInstanceCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    automationId?: SortOrder
    active?: SortOrder
  }

  export type AutomationInstanceMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    automationId?: SortOrder
    active?: SortOrder
  }

  export type AutomationInstanceMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    automationId?: SortOrder
    active?: SortOrder
  }

  export type EnumActionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActionType | EnumActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActionType[] | ListEnumActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActionType[] | ListEnumActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActionTypeFilter<$PrismaModel> | $Enums.ActionType
  }

  export type ActionsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    automatedId?: SortOrder
    order?: SortOrder
    laneId?: SortOrder
  }

  export type ActionsAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type ActionsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    automatedId?: SortOrder
    order?: SortOrder
    laneId?: SortOrder
  }

  export type ActionsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    automatedId?: SortOrder
    order?: SortOrder
    laneId?: SortOrder
  }

  export type ActionsSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type EnumActionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActionType | EnumActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActionType[] | ListEnumActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActionType[] | ListEnumActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActionTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActionTypeFilter<$PrismaModel>
    _max?: NestedEnumActionTypeFilter<$PrismaModel>
  }

  export type ContactsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subAccountId?: SortOrder
  }

  export type ContactsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subAccountId?: SortOrder
  }

  export type ContactsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subAccountId?: SortOrder
  }

  export type MediaCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    link?: SortOrder
    subAccountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MediaMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    link?: SortOrder
    subAccountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MediaMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    link?: SortOrder
    subAccountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PipelinesScalarRelationFilter = {
    is?: PipelinesWhereInput
    isNot?: PipelinesWhereInput
  }

  export type LaneCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pipelineId?: SortOrder
    order?: SortOrder
  }

  export type LaneAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type LaneMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pipelineId?: SortOrder
    order?: SortOrder
  }

  export type LaneMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pipelineId?: SortOrder
    order?: SortOrder
  }

  export type LaneSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type LaneScalarRelationFilter = {
    is?: LaneWhereInput
    isNot?: LaneWhereInput
  }

  export type UsersNullableScalarRelationFilter = {
    is?: UsersWhereInput | null
    isNot?: UsersWhereInput | null
  }

  export type ContactsNullableScalarRelationFilter = {
    is?: ContactsWhereInput | null
    isNot?: ContactsWhereInput | null
  }

  export type TicketsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lineId?: SortOrder
    order?: SortOrder
    value?: SortOrder
    description?: SortOrder
    userId?: SortOrder
    contactId?: SortOrder
  }

  export type TicketsAvgOrderByAggregateInput = {
    order?: SortOrder
    value?: SortOrder
  }

  export type TicketsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lineId?: SortOrder
    order?: SortOrder
    value?: SortOrder
    description?: SortOrder
    userId?: SortOrder
    contactId?: SortOrder
  }

  export type TicketsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lineId?: SortOrder
    order?: SortOrder
    value?: SortOrder
    description?: SortOrder
    userId?: SortOrder
    contactId?: SortOrder
  }

  export type TicketsSumOrderByAggregateInput = {
    order?: SortOrder
    value?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type TagsCountOrderByAggregateInput = {
    id?: SortOrder
    nane?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subAccountId?: SortOrder
  }

  export type TagsMaxOrderByAggregateInput = {
    id?: SortOrder
    nane?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subAccountId?: SortOrder
  }

  export type TagsMinOrderByAggregateInput = {
    id?: SortOrder
    nane?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subAccountId?: SortOrder
  }

  export type SubAccountSidebarOptionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    link?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subAccountId?: SortOrder
    subAccount?: SortOrder
  }

  export type SubAccountSidebarOptionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    link?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subAccountId?: SortOrder
    subAccount?: SortOrder
  }

  export type SubAccountSidebarOptionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    link?: SortOrder
    icon?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subAccountId?: SortOrder
    subAccount?: SortOrder
  }

  export type EnumInvitationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationStatus | EnumInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationStatusFilter<$PrismaModel> | $Enums.InvitationStatus
  }

  export type InvitationsCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    agencyId?: SortOrder
    status?: SortOrder
    role?: SortOrder
  }

  export type InvitationsMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    agencyId?: SortOrder
    status?: SortOrder
    role?: SortOrder
  }

  export type InvitationsMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    agencyId?: SortOrder
    status?: SortOrder
    role?: SortOrder
  }

  export type EnumInvitationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationStatus | EnumInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvitationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvitationStatusFilter<$PrismaModel>
    _max?: NestedEnumInvitationStatusFilter<$PrismaModel>
  }

  export type FunelPagesListRelationFilter = {
    every?: FunelPagesWhereInput
    some?: FunelPagesWhereInput
    none?: FunelPagesWhereInput
  }

  export type ClassNameListRelationFilter = {
    every?: ClassNameWhereInput
    some?: ClassNameWhereInput
    none?: ClassNameWhereInput
  }

  export type FunelPagesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClassNameOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FunnelsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
    published?: SortOrder
    subDomainName?: SortOrder
    favicon?: SortOrder
    subAccountId?: SortOrder
    liveProducts?: SortOrder
  }

  export type FunnelsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
    published?: SortOrder
    subDomainName?: SortOrder
    favicon?: SortOrder
    subAccountId?: SortOrder
    liveProducts?: SortOrder
  }

  export type FunnelsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
    published?: SortOrder
    subDomainName?: SortOrder
    favicon?: SortOrder
    subAccountId?: SortOrder
    liveProducts?: SortOrder
  }

  export type NotificationsCountOrderByAggregateInput = {
    id?: SortOrder
    notification?: SortOrder
    agencyId?: SortOrder
    subAccountId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationsMaxOrderByAggregateInput = {
    id?: SortOrder
    notification?: SortOrder
    agencyId?: SortOrder
    subAccountId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationsMinOrderByAggregateInput = {
    id?: SortOrder
    notification?: SortOrder
    agencyId?: SortOrder
    subAccountId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumPlansNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Plans | EnumPlansFieldRefInput<$PrismaModel> | null
    in?: $Enums.Plans[] | ListEnumPlansFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Plans[] | ListEnumPlansFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPlansNullableFilter<$PrismaModel> | $Enums.Plans | null
  }

  export type SubscriptionsCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    plan?: SortOrder
    price?: SortOrder
    active?: SortOrder
    priceId?: SortOrder
    customerId?: SortOrder
    currentPeriodEndDate?: SortOrder
    subscriptionId?: SortOrder
    agencyId?: SortOrder
  }

  export type SubscriptionsMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    plan?: SortOrder
    price?: SortOrder
    active?: SortOrder
    priceId?: SortOrder
    customerId?: SortOrder
    currentPeriodEndDate?: SortOrder
    subscriptionId?: SortOrder
    agencyId?: SortOrder
  }

  export type SubscriptionsMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    plan?: SortOrder
    price?: SortOrder
    active?: SortOrder
    priceId?: SortOrder
    customerId?: SortOrder
    currentPeriodEndDate?: SortOrder
    subscriptionId?: SortOrder
    agencyId?: SortOrder
  }

  export type EnumPlansNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Plans | EnumPlansFieldRefInput<$PrismaModel> | null
    in?: $Enums.Plans[] | ListEnumPlansFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Plans[] | ListEnumPlansFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPlansNullableWithAggregatesFilter<$PrismaModel> | $Enums.Plans | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPlansNullableFilter<$PrismaModel>
    _max?: NestedEnumPlansNullableFilter<$PrismaModel>
  }

  export type FunnelsScalarRelationFilter = {
    is?: FunnelsWhereInput
    isNot?: FunnelsWhereInput
  }

  export type ClassNameCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    funnelId?: SortOrder
    customData?: SortOrder
  }

  export type ClassNameMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    funnelId?: SortOrder
    customData?: SortOrder
  }

  export type ClassNameMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    funnelId?: SortOrder
    customData?: SortOrder
  }

  export type FunelPagesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    pathName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    visits?: SortOrder
    content?: SortOrder
    order?: SortOrder
    previewImage?: SortOrder
    funnelId?: SortOrder
  }

  export type FunelPagesAvgOrderByAggregateInput = {
    visits?: SortOrder
    order?: SortOrder
  }

  export type FunelPagesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    pathName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    visits?: SortOrder
    content?: SortOrder
    order?: SortOrder
    previewImage?: SortOrder
    funnelId?: SortOrder
  }

  export type FunelPagesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    pathName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    visits?: SortOrder
    content?: SortOrder
    order?: SortOrder
    previewImage?: SortOrder
    funnelId?: SortOrder
  }

  export type FunelPagesSumOrderByAggregateInput = {
    visits?: SortOrder
    order?: SortOrder
  }

  export type AddOnsCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    active?: SortOrder
    priceId?: SortOrder
    agencyId?: SortOrder
  }

  export type AddOnsMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    active?: SortOrder
    priceId?: SortOrder
    agencyId?: SortOrder
  }

  export type AddOnsMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    active?: SortOrder
    priceId?: SortOrder
    agencyId?: SortOrder
  }

  export type AgencyCreateNestedOneWithoutUserInput = {
    create?: XOR<AgencyCreateWithoutUserInput, AgencyUncheckedCreateWithoutUserInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutUserInput
    connect?: AgencyWhereUniqueInput
  }

  export type PermissionsCreateNestedManyWithoutUsersInput = {
    create?: XOR<PermissionsCreateWithoutUsersInput, PermissionsUncheckedCreateWithoutUsersInput> | PermissionsCreateWithoutUsersInput[] | PermissionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: PermissionsCreateOrConnectWithoutUsersInput | PermissionsCreateOrConnectWithoutUsersInput[]
    createMany?: PermissionsCreateManyUsersInputEnvelope
    connect?: PermissionsWhereUniqueInput | PermissionsWhereUniqueInput[]
  }

  export type TicketsCreateNestedManyWithoutUsersInput = {
    create?: XOR<TicketsCreateWithoutUsersInput, TicketsUncheckedCreateWithoutUsersInput> | TicketsCreateWithoutUsersInput[] | TicketsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: TicketsCreateOrConnectWithoutUsersInput | TicketsCreateOrConnectWithoutUsersInput[]
    createMany?: TicketsCreateManyUsersInputEnvelope
    connect?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
  }

  export type NotificationsCreateNestedManyWithoutUsersInput = {
    create?: XOR<NotificationsCreateWithoutUsersInput, NotificationsUncheckedCreateWithoutUsersInput> | NotificationsCreateWithoutUsersInput[] | NotificationsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: NotificationsCreateOrConnectWithoutUsersInput | NotificationsCreateOrConnectWithoutUsersInput[]
    createMany?: NotificationsCreateManyUsersInputEnvelope
    connect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
  }

  export type PermissionsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<PermissionsCreateWithoutUsersInput, PermissionsUncheckedCreateWithoutUsersInput> | PermissionsCreateWithoutUsersInput[] | PermissionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: PermissionsCreateOrConnectWithoutUsersInput | PermissionsCreateOrConnectWithoutUsersInput[]
    createMany?: PermissionsCreateManyUsersInputEnvelope
    connect?: PermissionsWhereUniqueInput | PermissionsWhereUniqueInput[]
  }

  export type TicketsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<TicketsCreateWithoutUsersInput, TicketsUncheckedCreateWithoutUsersInput> | TicketsCreateWithoutUsersInput[] | TicketsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: TicketsCreateOrConnectWithoutUsersInput | TicketsCreateOrConnectWithoutUsersInput[]
    createMany?: TicketsCreateManyUsersInputEnvelope
    connect?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
  }

  export type NotificationsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<NotificationsCreateWithoutUsersInput, NotificationsUncheckedCreateWithoutUsersInput> | NotificationsCreateWithoutUsersInput[] | NotificationsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: NotificationsCreateOrConnectWithoutUsersInput | NotificationsCreateOrConnectWithoutUsersInput[]
    createMany?: NotificationsCreateManyUsersInputEnvelope
    connect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type AgencyUpdateOneWithoutUserNestedInput = {
    create?: XOR<AgencyCreateWithoutUserInput, AgencyUncheckedCreateWithoutUserInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutUserInput
    upsert?: AgencyUpsertWithoutUserInput
    disconnect?: AgencyWhereInput | boolean
    delete?: AgencyWhereInput | boolean
    connect?: AgencyWhereUniqueInput
    update?: XOR<XOR<AgencyUpdateToOneWithWhereWithoutUserInput, AgencyUpdateWithoutUserInput>, AgencyUncheckedUpdateWithoutUserInput>
  }

  export type PermissionsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<PermissionsCreateWithoutUsersInput, PermissionsUncheckedCreateWithoutUsersInput> | PermissionsCreateWithoutUsersInput[] | PermissionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: PermissionsCreateOrConnectWithoutUsersInput | PermissionsCreateOrConnectWithoutUsersInput[]
    upsert?: PermissionsUpsertWithWhereUniqueWithoutUsersInput | PermissionsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: PermissionsCreateManyUsersInputEnvelope
    set?: PermissionsWhereUniqueInput | PermissionsWhereUniqueInput[]
    disconnect?: PermissionsWhereUniqueInput | PermissionsWhereUniqueInput[]
    delete?: PermissionsWhereUniqueInput | PermissionsWhereUniqueInput[]
    connect?: PermissionsWhereUniqueInput | PermissionsWhereUniqueInput[]
    update?: PermissionsUpdateWithWhereUniqueWithoutUsersInput | PermissionsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: PermissionsUpdateManyWithWhereWithoutUsersInput | PermissionsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: PermissionsScalarWhereInput | PermissionsScalarWhereInput[]
  }

  export type TicketsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<TicketsCreateWithoutUsersInput, TicketsUncheckedCreateWithoutUsersInput> | TicketsCreateWithoutUsersInput[] | TicketsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: TicketsCreateOrConnectWithoutUsersInput | TicketsCreateOrConnectWithoutUsersInput[]
    upsert?: TicketsUpsertWithWhereUniqueWithoutUsersInput | TicketsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: TicketsCreateManyUsersInputEnvelope
    set?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
    disconnect?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
    delete?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
    connect?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
    update?: TicketsUpdateWithWhereUniqueWithoutUsersInput | TicketsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: TicketsUpdateManyWithWhereWithoutUsersInput | TicketsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: TicketsScalarWhereInput | TicketsScalarWhereInput[]
  }

  export type NotificationsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<NotificationsCreateWithoutUsersInput, NotificationsUncheckedCreateWithoutUsersInput> | NotificationsCreateWithoutUsersInput[] | NotificationsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: NotificationsCreateOrConnectWithoutUsersInput | NotificationsCreateOrConnectWithoutUsersInput[]
    upsert?: NotificationsUpsertWithWhereUniqueWithoutUsersInput | NotificationsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: NotificationsCreateManyUsersInputEnvelope
    set?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    disconnect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    delete?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    connect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    update?: NotificationsUpdateWithWhereUniqueWithoutUsersInput | NotificationsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: NotificationsUpdateManyWithWhereWithoutUsersInput | NotificationsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: NotificationsScalarWhereInput | NotificationsScalarWhereInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type PermissionsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<PermissionsCreateWithoutUsersInput, PermissionsUncheckedCreateWithoutUsersInput> | PermissionsCreateWithoutUsersInput[] | PermissionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: PermissionsCreateOrConnectWithoutUsersInput | PermissionsCreateOrConnectWithoutUsersInput[]
    upsert?: PermissionsUpsertWithWhereUniqueWithoutUsersInput | PermissionsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: PermissionsCreateManyUsersInputEnvelope
    set?: PermissionsWhereUniqueInput | PermissionsWhereUniqueInput[]
    disconnect?: PermissionsWhereUniqueInput | PermissionsWhereUniqueInput[]
    delete?: PermissionsWhereUniqueInput | PermissionsWhereUniqueInput[]
    connect?: PermissionsWhereUniqueInput | PermissionsWhereUniqueInput[]
    update?: PermissionsUpdateWithWhereUniqueWithoutUsersInput | PermissionsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: PermissionsUpdateManyWithWhereWithoutUsersInput | PermissionsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: PermissionsScalarWhereInput | PermissionsScalarWhereInput[]
  }

  export type TicketsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<TicketsCreateWithoutUsersInput, TicketsUncheckedCreateWithoutUsersInput> | TicketsCreateWithoutUsersInput[] | TicketsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: TicketsCreateOrConnectWithoutUsersInput | TicketsCreateOrConnectWithoutUsersInput[]
    upsert?: TicketsUpsertWithWhereUniqueWithoutUsersInput | TicketsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: TicketsCreateManyUsersInputEnvelope
    set?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
    disconnect?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
    delete?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
    connect?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
    update?: TicketsUpdateWithWhereUniqueWithoutUsersInput | TicketsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: TicketsUpdateManyWithWhereWithoutUsersInput | TicketsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: TicketsScalarWhereInput | TicketsScalarWhereInput[]
  }

  export type NotificationsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<NotificationsCreateWithoutUsersInput, NotificationsUncheckedCreateWithoutUsersInput> | NotificationsCreateWithoutUsersInput[] | NotificationsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: NotificationsCreateOrConnectWithoutUsersInput | NotificationsCreateOrConnectWithoutUsersInput[]
    upsert?: NotificationsUpsertWithWhereUniqueWithoutUsersInput | NotificationsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: NotificationsCreateManyUsersInputEnvelope
    set?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    disconnect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    delete?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    connect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    update?: NotificationsUpdateWithWhereUniqueWithoutUsersInput | NotificationsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: NotificationsUpdateManyWithWhereWithoutUsersInput | NotificationsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: NotificationsScalarWhereInput | NotificationsScalarWhereInput[]
  }

  export type UsersCreateNestedOneWithoutPermissionInput = {
    create?: XOR<UsersCreateWithoutPermissionInput, UsersUncheckedCreateWithoutPermissionInput>
    connectOrCreate?: UsersCreateOrConnectWithoutPermissionInput
    connect?: UsersWhereUniqueInput
  }

  export type SubAccountsCreateNestedOneWithoutPermissionsInput = {
    create?: XOR<SubAccountsCreateWithoutPermissionsInput, SubAccountsUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: SubAccountsCreateOrConnectWithoutPermissionsInput
    connect?: SubAccountsWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UsersUpdateOneRequiredWithoutPermissionNestedInput = {
    create?: XOR<UsersCreateWithoutPermissionInput, UsersUncheckedCreateWithoutPermissionInput>
    connectOrCreate?: UsersCreateOrConnectWithoutPermissionInput
    upsert?: UsersUpsertWithoutPermissionInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutPermissionInput, UsersUpdateWithoutPermissionInput>, UsersUncheckedUpdateWithoutPermissionInput>
  }

  export type SubAccountsUpdateOneRequiredWithoutPermissionsNestedInput = {
    create?: XOR<SubAccountsCreateWithoutPermissionsInput, SubAccountsUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: SubAccountsCreateOrConnectWithoutPermissionsInput
    upsert?: SubAccountsUpsertWithoutPermissionsInput
    connect?: SubAccountsWhereUniqueInput
    update?: XOR<XOR<SubAccountsUpdateToOneWithWhereWithoutPermissionsInput, SubAccountsUpdateWithoutPermissionsInput>, SubAccountsUncheckedUpdateWithoutPermissionsInput>
  }

  export type UsersCreateNestedManyWithoutAgencyInput = {
    create?: XOR<UsersCreateWithoutAgencyInput, UsersUncheckedCreateWithoutAgencyInput> | UsersCreateWithoutAgencyInput[] | UsersUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: UsersCreateOrConnectWithoutAgencyInput | UsersCreateOrConnectWithoutAgencyInput[]
    createMany?: UsersCreateManyAgencyInputEnvelope
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
  }

  export type SubAccountsCreateNestedManyWithoutAgencyInput = {
    create?: XOR<SubAccountsCreateWithoutAgencyInput, SubAccountsUncheckedCreateWithoutAgencyInput> | SubAccountsCreateWithoutAgencyInput[] | SubAccountsUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: SubAccountsCreateOrConnectWithoutAgencyInput | SubAccountsCreateOrConnectWithoutAgencyInput[]
    createMany?: SubAccountsCreateManyAgencyInputEnvelope
    connect?: SubAccountsWhereUniqueInput | SubAccountsWhereUniqueInput[]
  }

  export type AgencySidebarOptionCreateNestedManyWithoutAgencyInput = {
    create?: XOR<AgencySidebarOptionCreateWithoutAgencyInput, AgencySidebarOptionUncheckedCreateWithoutAgencyInput> | AgencySidebarOptionCreateWithoutAgencyInput[] | AgencySidebarOptionUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AgencySidebarOptionCreateOrConnectWithoutAgencyInput | AgencySidebarOptionCreateOrConnectWithoutAgencyInput[]
    createMany?: AgencySidebarOptionCreateManyAgencyInputEnvelope
    connect?: AgencySidebarOptionWhereUniqueInput | AgencySidebarOptionWhereUniqueInput[]
  }

  export type InvitationsCreateNestedManyWithoutAgencyInput = {
    create?: XOR<InvitationsCreateWithoutAgencyInput, InvitationsUncheckedCreateWithoutAgencyInput> | InvitationsCreateWithoutAgencyInput[] | InvitationsUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: InvitationsCreateOrConnectWithoutAgencyInput | InvitationsCreateOrConnectWithoutAgencyInput[]
    createMany?: InvitationsCreateManyAgencyInputEnvelope
    connect?: InvitationsWhereUniqueInput | InvitationsWhereUniqueInput[]
  }

  export type NotificationsCreateNestedManyWithoutAgencyInput = {
    create?: XOR<NotificationsCreateWithoutAgencyInput, NotificationsUncheckedCreateWithoutAgencyInput> | NotificationsCreateWithoutAgencyInput[] | NotificationsUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: NotificationsCreateOrConnectWithoutAgencyInput | NotificationsCreateOrConnectWithoutAgencyInput[]
    createMany?: NotificationsCreateManyAgencyInputEnvelope
    connect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
  }

  export type SubscriptionsCreateNestedOneWithoutAgencyInput = {
    create?: XOR<SubscriptionsCreateWithoutAgencyInput, SubscriptionsUncheckedCreateWithoutAgencyInput>
    connectOrCreate?: SubscriptionsCreateOrConnectWithoutAgencyInput
    connect?: SubscriptionsWhereUniqueInput
  }

  export type AddOnsCreateNestedManyWithoutAgencyInput = {
    create?: XOR<AddOnsCreateWithoutAgencyInput, AddOnsUncheckedCreateWithoutAgencyInput> | AddOnsCreateWithoutAgencyInput[] | AddOnsUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AddOnsCreateOrConnectWithoutAgencyInput | AddOnsCreateOrConnectWithoutAgencyInput[]
    createMany?: AddOnsCreateManyAgencyInputEnvelope
    connect?: AddOnsWhereUniqueInput | AddOnsWhereUniqueInput[]
  }

  export type UsersUncheckedCreateNestedManyWithoutAgencyInput = {
    create?: XOR<UsersCreateWithoutAgencyInput, UsersUncheckedCreateWithoutAgencyInput> | UsersCreateWithoutAgencyInput[] | UsersUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: UsersCreateOrConnectWithoutAgencyInput | UsersCreateOrConnectWithoutAgencyInput[]
    createMany?: UsersCreateManyAgencyInputEnvelope
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
  }

  export type SubAccountsUncheckedCreateNestedManyWithoutAgencyInput = {
    create?: XOR<SubAccountsCreateWithoutAgencyInput, SubAccountsUncheckedCreateWithoutAgencyInput> | SubAccountsCreateWithoutAgencyInput[] | SubAccountsUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: SubAccountsCreateOrConnectWithoutAgencyInput | SubAccountsCreateOrConnectWithoutAgencyInput[]
    createMany?: SubAccountsCreateManyAgencyInputEnvelope
    connect?: SubAccountsWhereUniqueInput | SubAccountsWhereUniqueInput[]
  }

  export type AgencySidebarOptionUncheckedCreateNestedManyWithoutAgencyInput = {
    create?: XOR<AgencySidebarOptionCreateWithoutAgencyInput, AgencySidebarOptionUncheckedCreateWithoutAgencyInput> | AgencySidebarOptionCreateWithoutAgencyInput[] | AgencySidebarOptionUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AgencySidebarOptionCreateOrConnectWithoutAgencyInput | AgencySidebarOptionCreateOrConnectWithoutAgencyInput[]
    createMany?: AgencySidebarOptionCreateManyAgencyInputEnvelope
    connect?: AgencySidebarOptionWhereUniqueInput | AgencySidebarOptionWhereUniqueInput[]
  }

  export type InvitationsUncheckedCreateNestedManyWithoutAgencyInput = {
    create?: XOR<InvitationsCreateWithoutAgencyInput, InvitationsUncheckedCreateWithoutAgencyInput> | InvitationsCreateWithoutAgencyInput[] | InvitationsUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: InvitationsCreateOrConnectWithoutAgencyInput | InvitationsCreateOrConnectWithoutAgencyInput[]
    createMany?: InvitationsCreateManyAgencyInputEnvelope
    connect?: InvitationsWhereUniqueInput | InvitationsWhereUniqueInput[]
  }

  export type NotificationsUncheckedCreateNestedManyWithoutAgencyInput = {
    create?: XOR<NotificationsCreateWithoutAgencyInput, NotificationsUncheckedCreateWithoutAgencyInput> | NotificationsCreateWithoutAgencyInput[] | NotificationsUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: NotificationsCreateOrConnectWithoutAgencyInput | NotificationsCreateOrConnectWithoutAgencyInput[]
    createMany?: NotificationsCreateManyAgencyInputEnvelope
    connect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
  }

  export type SubscriptionsUncheckedCreateNestedOneWithoutAgencyInput = {
    create?: XOR<SubscriptionsCreateWithoutAgencyInput, SubscriptionsUncheckedCreateWithoutAgencyInput>
    connectOrCreate?: SubscriptionsCreateOrConnectWithoutAgencyInput
    connect?: SubscriptionsWhereUniqueInput
  }

  export type AddOnsUncheckedCreateNestedManyWithoutAgencyInput = {
    create?: XOR<AddOnsCreateWithoutAgencyInput, AddOnsUncheckedCreateWithoutAgencyInput> | AddOnsCreateWithoutAgencyInput[] | AddOnsUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AddOnsCreateOrConnectWithoutAgencyInput | AddOnsCreateOrConnectWithoutAgencyInput[]
    createMany?: AddOnsCreateManyAgencyInputEnvelope
    connect?: AddOnsWhereUniqueInput | AddOnsWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UsersUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<UsersCreateWithoutAgencyInput, UsersUncheckedCreateWithoutAgencyInput> | UsersCreateWithoutAgencyInput[] | UsersUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: UsersCreateOrConnectWithoutAgencyInput | UsersCreateOrConnectWithoutAgencyInput[]
    upsert?: UsersUpsertWithWhereUniqueWithoutAgencyInput | UsersUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: UsersCreateManyAgencyInputEnvelope
    set?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    disconnect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    delete?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    update?: UsersUpdateWithWhereUniqueWithoutAgencyInput | UsersUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: UsersUpdateManyWithWhereWithoutAgencyInput | UsersUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: UsersScalarWhereInput | UsersScalarWhereInput[]
  }

  export type SubAccountsUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<SubAccountsCreateWithoutAgencyInput, SubAccountsUncheckedCreateWithoutAgencyInput> | SubAccountsCreateWithoutAgencyInput[] | SubAccountsUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: SubAccountsCreateOrConnectWithoutAgencyInput | SubAccountsCreateOrConnectWithoutAgencyInput[]
    upsert?: SubAccountsUpsertWithWhereUniqueWithoutAgencyInput | SubAccountsUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: SubAccountsCreateManyAgencyInputEnvelope
    set?: SubAccountsWhereUniqueInput | SubAccountsWhereUniqueInput[]
    disconnect?: SubAccountsWhereUniqueInput | SubAccountsWhereUniqueInput[]
    delete?: SubAccountsWhereUniqueInput | SubAccountsWhereUniqueInput[]
    connect?: SubAccountsWhereUniqueInput | SubAccountsWhereUniqueInput[]
    update?: SubAccountsUpdateWithWhereUniqueWithoutAgencyInput | SubAccountsUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: SubAccountsUpdateManyWithWhereWithoutAgencyInput | SubAccountsUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: SubAccountsScalarWhereInput | SubAccountsScalarWhereInput[]
  }

  export type AgencySidebarOptionUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<AgencySidebarOptionCreateWithoutAgencyInput, AgencySidebarOptionUncheckedCreateWithoutAgencyInput> | AgencySidebarOptionCreateWithoutAgencyInput[] | AgencySidebarOptionUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AgencySidebarOptionCreateOrConnectWithoutAgencyInput | AgencySidebarOptionCreateOrConnectWithoutAgencyInput[]
    upsert?: AgencySidebarOptionUpsertWithWhereUniqueWithoutAgencyInput | AgencySidebarOptionUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: AgencySidebarOptionCreateManyAgencyInputEnvelope
    set?: AgencySidebarOptionWhereUniqueInput | AgencySidebarOptionWhereUniqueInput[]
    disconnect?: AgencySidebarOptionWhereUniqueInput | AgencySidebarOptionWhereUniqueInput[]
    delete?: AgencySidebarOptionWhereUniqueInput | AgencySidebarOptionWhereUniqueInput[]
    connect?: AgencySidebarOptionWhereUniqueInput | AgencySidebarOptionWhereUniqueInput[]
    update?: AgencySidebarOptionUpdateWithWhereUniqueWithoutAgencyInput | AgencySidebarOptionUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: AgencySidebarOptionUpdateManyWithWhereWithoutAgencyInput | AgencySidebarOptionUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: AgencySidebarOptionScalarWhereInput | AgencySidebarOptionScalarWhereInput[]
  }

  export type InvitationsUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<InvitationsCreateWithoutAgencyInput, InvitationsUncheckedCreateWithoutAgencyInput> | InvitationsCreateWithoutAgencyInput[] | InvitationsUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: InvitationsCreateOrConnectWithoutAgencyInput | InvitationsCreateOrConnectWithoutAgencyInput[]
    upsert?: InvitationsUpsertWithWhereUniqueWithoutAgencyInput | InvitationsUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: InvitationsCreateManyAgencyInputEnvelope
    set?: InvitationsWhereUniqueInput | InvitationsWhereUniqueInput[]
    disconnect?: InvitationsWhereUniqueInput | InvitationsWhereUniqueInput[]
    delete?: InvitationsWhereUniqueInput | InvitationsWhereUniqueInput[]
    connect?: InvitationsWhereUniqueInput | InvitationsWhereUniqueInput[]
    update?: InvitationsUpdateWithWhereUniqueWithoutAgencyInput | InvitationsUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: InvitationsUpdateManyWithWhereWithoutAgencyInput | InvitationsUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: InvitationsScalarWhereInput | InvitationsScalarWhereInput[]
  }

  export type NotificationsUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<NotificationsCreateWithoutAgencyInput, NotificationsUncheckedCreateWithoutAgencyInput> | NotificationsCreateWithoutAgencyInput[] | NotificationsUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: NotificationsCreateOrConnectWithoutAgencyInput | NotificationsCreateOrConnectWithoutAgencyInput[]
    upsert?: NotificationsUpsertWithWhereUniqueWithoutAgencyInput | NotificationsUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: NotificationsCreateManyAgencyInputEnvelope
    set?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    disconnect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    delete?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    connect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    update?: NotificationsUpdateWithWhereUniqueWithoutAgencyInput | NotificationsUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: NotificationsUpdateManyWithWhereWithoutAgencyInput | NotificationsUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: NotificationsScalarWhereInput | NotificationsScalarWhereInput[]
  }

  export type SubscriptionsUpdateOneWithoutAgencyNestedInput = {
    create?: XOR<SubscriptionsCreateWithoutAgencyInput, SubscriptionsUncheckedCreateWithoutAgencyInput>
    connectOrCreate?: SubscriptionsCreateOrConnectWithoutAgencyInput
    upsert?: SubscriptionsUpsertWithoutAgencyInput
    disconnect?: SubscriptionsWhereInput | boolean
    delete?: SubscriptionsWhereInput | boolean
    connect?: SubscriptionsWhereUniqueInput
    update?: XOR<XOR<SubscriptionsUpdateToOneWithWhereWithoutAgencyInput, SubscriptionsUpdateWithoutAgencyInput>, SubscriptionsUncheckedUpdateWithoutAgencyInput>
  }

  export type AddOnsUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<AddOnsCreateWithoutAgencyInput, AddOnsUncheckedCreateWithoutAgencyInput> | AddOnsCreateWithoutAgencyInput[] | AddOnsUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AddOnsCreateOrConnectWithoutAgencyInput | AddOnsCreateOrConnectWithoutAgencyInput[]
    upsert?: AddOnsUpsertWithWhereUniqueWithoutAgencyInput | AddOnsUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: AddOnsCreateManyAgencyInputEnvelope
    set?: AddOnsWhereUniqueInput | AddOnsWhereUniqueInput[]
    disconnect?: AddOnsWhereUniqueInput | AddOnsWhereUniqueInput[]
    delete?: AddOnsWhereUniqueInput | AddOnsWhereUniqueInput[]
    connect?: AddOnsWhereUniqueInput | AddOnsWhereUniqueInput[]
    update?: AddOnsUpdateWithWhereUniqueWithoutAgencyInput | AddOnsUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: AddOnsUpdateManyWithWhereWithoutAgencyInput | AddOnsUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: AddOnsScalarWhereInput | AddOnsScalarWhereInput[]
  }

  export type UsersUncheckedUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<UsersCreateWithoutAgencyInput, UsersUncheckedCreateWithoutAgencyInput> | UsersCreateWithoutAgencyInput[] | UsersUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: UsersCreateOrConnectWithoutAgencyInput | UsersCreateOrConnectWithoutAgencyInput[]
    upsert?: UsersUpsertWithWhereUniqueWithoutAgencyInput | UsersUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: UsersCreateManyAgencyInputEnvelope
    set?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    disconnect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    delete?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    update?: UsersUpdateWithWhereUniqueWithoutAgencyInput | UsersUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: UsersUpdateManyWithWhereWithoutAgencyInput | UsersUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: UsersScalarWhereInput | UsersScalarWhereInput[]
  }

  export type SubAccountsUncheckedUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<SubAccountsCreateWithoutAgencyInput, SubAccountsUncheckedCreateWithoutAgencyInput> | SubAccountsCreateWithoutAgencyInput[] | SubAccountsUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: SubAccountsCreateOrConnectWithoutAgencyInput | SubAccountsCreateOrConnectWithoutAgencyInput[]
    upsert?: SubAccountsUpsertWithWhereUniqueWithoutAgencyInput | SubAccountsUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: SubAccountsCreateManyAgencyInputEnvelope
    set?: SubAccountsWhereUniqueInput | SubAccountsWhereUniqueInput[]
    disconnect?: SubAccountsWhereUniqueInput | SubAccountsWhereUniqueInput[]
    delete?: SubAccountsWhereUniqueInput | SubAccountsWhereUniqueInput[]
    connect?: SubAccountsWhereUniqueInput | SubAccountsWhereUniqueInput[]
    update?: SubAccountsUpdateWithWhereUniqueWithoutAgencyInput | SubAccountsUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: SubAccountsUpdateManyWithWhereWithoutAgencyInput | SubAccountsUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: SubAccountsScalarWhereInput | SubAccountsScalarWhereInput[]
  }

  export type AgencySidebarOptionUncheckedUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<AgencySidebarOptionCreateWithoutAgencyInput, AgencySidebarOptionUncheckedCreateWithoutAgencyInput> | AgencySidebarOptionCreateWithoutAgencyInput[] | AgencySidebarOptionUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AgencySidebarOptionCreateOrConnectWithoutAgencyInput | AgencySidebarOptionCreateOrConnectWithoutAgencyInput[]
    upsert?: AgencySidebarOptionUpsertWithWhereUniqueWithoutAgencyInput | AgencySidebarOptionUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: AgencySidebarOptionCreateManyAgencyInputEnvelope
    set?: AgencySidebarOptionWhereUniqueInput | AgencySidebarOptionWhereUniqueInput[]
    disconnect?: AgencySidebarOptionWhereUniqueInput | AgencySidebarOptionWhereUniqueInput[]
    delete?: AgencySidebarOptionWhereUniqueInput | AgencySidebarOptionWhereUniqueInput[]
    connect?: AgencySidebarOptionWhereUniqueInput | AgencySidebarOptionWhereUniqueInput[]
    update?: AgencySidebarOptionUpdateWithWhereUniqueWithoutAgencyInput | AgencySidebarOptionUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: AgencySidebarOptionUpdateManyWithWhereWithoutAgencyInput | AgencySidebarOptionUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: AgencySidebarOptionScalarWhereInput | AgencySidebarOptionScalarWhereInput[]
  }

  export type InvitationsUncheckedUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<InvitationsCreateWithoutAgencyInput, InvitationsUncheckedCreateWithoutAgencyInput> | InvitationsCreateWithoutAgencyInput[] | InvitationsUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: InvitationsCreateOrConnectWithoutAgencyInput | InvitationsCreateOrConnectWithoutAgencyInput[]
    upsert?: InvitationsUpsertWithWhereUniqueWithoutAgencyInput | InvitationsUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: InvitationsCreateManyAgencyInputEnvelope
    set?: InvitationsWhereUniqueInput | InvitationsWhereUniqueInput[]
    disconnect?: InvitationsWhereUniqueInput | InvitationsWhereUniqueInput[]
    delete?: InvitationsWhereUniqueInput | InvitationsWhereUniqueInput[]
    connect?: InvitationsWhereUniqueInput | InvitationsWhereUniqueInput[]
    update?: InvitationsUpdateWithWhereUniqueWithoutAgencyInput | InvitationsUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: InvitationsUpdateManyWithWhereWithoutAgencyInput | InvitationsUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: InvitationsScalarWhereInput | InvitationsScalarWhereInput[]
  }

  export type NotificationsUncheckedUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<NotificationsCreateWithoutAgencyInput, NotificationsUncheckedCreateWithoutAgencyInput> | NotificationsCreateWithoutAgencyInput[] | NotificationsUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: NotificationsCreateOrConnectWithoutAgencyInput | NotificationsCreateOrConnectWithoutAgencyInput[]
    upsert?: NotificationsUpsertWithWhereUniqueWithoutAgencyInput | NotificationsUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: NotificationsCreateManyAgencyInputEnvelope
    set?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    disconnect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    delete?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    connect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    update?: NotificationsUpdateWithWhereUniqueWithoutAgencyInput | NotificationsUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: NotificationsUpdateManyWithWhereWithoutAgencyInput | NotificationsUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: NotificationsScalarWhereInput | NotificationsScalarWhereInput[]
  }

  export type SubscriptionsUncheckedUpdateOneWithoutAgencyNestedInput = {
    create?: XOR<SubscriptionsCreateWithoutAgencyInput, SubscriptionsUncheckedCreateWithoutAgencyInput>
    connectOrCreate?: SubscriptionsCreateOrConnectWithoutAgencyInput
    upsert?: SubscriptionsUpsertWithoutAgencyInput
    disconnect?: SubscriptionsWhereInput | boolean
    delete?: SubscriptionsWhereInput | boolean
    connect?: SubscriptionsWhereUniqueInput
    update?: XOR<XOR<SubscriptionsUpdateToOneWithWhereWithoutAgencyInput, SubscriptionsUpdateWithoutAgencyInput>, SubscriptionsUncheckedUpdateWithoutAgencyInput>
  }

  export type AddOnsUncheckedUpdateManyWithoutAgencyNestedInput = {
    create?: XOR<AddOnsCreateWithoutAgencyInput, AddOnsUncheckedCreateWithoutAgencyInput> | AddOnsCreateWithoutAgencyInput[] | AddOnsUncheckedCreateWithoutAgencyInput[]
    connectOrCreate?: AddOnsCreateOrConnectWithoutAgencyInput | AddOnsCreateOrConnectWithoutAgencyInput[]
    upsert?: AddOnsUpsertWithWhereUniqueWithoutAgencyInput | AddOnsUpsertWithWhereUniqueWithoutAgencyInput[]
    createMany?: AddOnsCreateManyAgencyInputEnvelope
    set?: AddOnsWhereUniqueInput | AddOnsWhereUniqueInput[]
    disconnect?: AddOnsWhereUniqueInput | AddOnsWhereUniqueInput[]
    delete?: AddOnsWhereUniqueInput | AddOnsWhereUniqueInput[]
    connect?: AddOnsWhereUniqueInput | AddOnsWhereUniqueInput[]
    update?: AddOnsUpdateWithWhereUniqueWithoutAgencyInput | AddOnsUpdateWithWhereUniqueWithoutAgencyInput[]
    updateMany?: AddOnsUpdateManyWithWhereWithoutAgencyInput | AddOnsUpdateManyWithWhereWithoutAgencyInput[]
    deleteMany?: AddOnsScalarWhereInput | AddOnsScalarWhereInput[]
  }

  export type AgencyCreateNestedOneWithoutSidebarOptionInput = {
    create?: XOR<AgencyCreateWithoutSidebarOptionInput, AgencyUncheckedCreateWithoutSidebarOptionInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutSidebarOptionInput
    connect?: AgencyWhereUniqueInput
  }

  export type SubAccountsCreateNestedOneWithoutSidebarOptionInput = {
    create?: XOR<SubAccountsCreateWithoutSidebarOptionInput, SubAccountsUncheckedCreateWithoutSidebarOptionInput>
    connectOrCreate?: SubAccountsCreateOrConnectWithoutSidebarOptionInput
    connect?: SubAccountsWhereUniqueInput
  }

  export type EnumIconFieldUpdateOperationsInput = {
    set?: $Enums.Icon
  }

  export type AgencyUpdateOneRequiredWithoutSidebarOptionNestedInput = {
    create?: XOR<AgencyCreateWithoutSidebarOptionInput, AgencyUncheckedCreateWithoutSidebarOptionInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutSidebarOptionInput
    upsert?: AgencyUpsertWithoutSidebarOptionInput
    connect?: AgencyWhereUniqueInput
    update?: XOR<XOR<AgencyUpdateToOneWithWhereWithoutSidebarOptionInput, AgencyUpdateWithoutSidebarOptionInput>, AgencyUncheckedUpdateWithoutSidebarOptionInput>
  }

  export type SubAccountsUpdateOneWithoutSidebarOptionNestedInput = {
    create?: XOR<SubAccountsCreateWithoutSidebarOptionInput, SubAccountsUncheckedCreateWithoutSidebarOptionInput>
    connectOrCreate?: SubAccountsCreateOrConnectWithoutSidebarOptionInput
    upsert?: SubAccountsUpsertWithoutSidebarOptionInput
    disconnect?: SubAccountsWhereInput | boolean
    delete?: SubAccountsWhereInput | boolean
    connect?: SubAccountsWhereUniqueInput
    update?: XOR<XOR<SubAccountsUpdateToOneWithWhereWithoutSidebarOptionInput, SubAccountsUpdateWithoutSidebarOptionInput>, SubAccountsUncheckedUpdateWithoutSidebarOptionInput>
  }

  export type AgencyCreateNestedOneWithoutSubAccountInput = {
    create?: XOR<AgencyCreateWithoutSubAccountInput, AgencyUncheckedCreateWithoutSubAccountInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutSubAccountInput
    connect?: AgencyWhereUniqueInput
  }

  export type AgencySidebarOptionCreateNestedManyWithoutSubAccountsInput = {
    create?: XOR<AgencySidebarOptionCreateWithoutSubAccountsInput, AgencySidebarOptionUncheckedCreateWithoutSubAccountsInput> | AgencySidebarOptionCreateWithoutSubAccountsInput[] | AgencySidebarOptionUncheckedCreateWithoutSubAccountsInput[]
    connectOrCreate?: AgencySidebarOptionCreateOrConnectWithoutSubAccountsInput | AgencySidebarOptionCreateOrConnectWithoutSubAccountsInput[]
    createMany?: AgencySidebarOptionCreateManySubAccountsInputEnvelope
    connect?: AgencySidebarOptionWhereUniqueInput | AgencySidebarOptionWhereUniqueInput[]
  }

  export type PermissionsCreateNestedManyWithoutSubAcctountInput = {
    create?: XOR<PermissionsCreateWithoutSubAcctountInput, PermissionsUncheckedCreateWithoutSubAcctountInput> | PermissionsCreateWithoutSubAcctountInput[] | PermissionsUncheckedCreateWithoutSubAcctountInput[]
    connectOrCreate?: PermissionsCreateOrConnectWithoutSubAcctountInput | PermissionsCreateOrConnectWithoutSubAcctountInput[]
    createMany?: PermissionsCreateManySubAcctountInputEnvelope
    connect?: PermissionsWhereUniqueInput | PermissionsWhereUniqueInput[]
  }

  export type FunnelsCreateNestedManyWithoutSubAccountInput = {
    create?: XOR<FunnelsCreateWithoutSubAccountInput, FunnelsUncheckedCreateWithoutSubAccountInput> | FunnelsCreateWithoutSubAccountInput[] | FunnelsUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: FunnelsCreateOrConnectWithoutSubAccountInput | FunnelsCreateOrConnectWithoutSubAccountInput[]
    createMany?: FunnelsCreateManySubAccountInputEnvelope
    connect?: FunnelsWhereUniqueInput | FunnelsWhereUniqueInput[]
  }

  export type MediaCreateNestedManyWithoutSubAccountsInput = {
    create?: XOR<MediaCreateWithoutSubAccountsInput, MediaUncheckedCreateWithoutSubAccountsInput> | MediaCreateWithoutSubAccountsInput[] | MediaUncheckedCreateWithoutSubAccountsInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutSubAccountsInput | MediaCreateOrConnectWithoutSubAccountsInput[]
    createMany?: MediaCreateManySubAccountsInputEnvelope
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
  }

  export type ContactsCreateNestedManyWithoutSubAccountsInput = {
    create?: XOR<ContactsCreateWithoutSubAccountsInput, ContactsUncheckedCreateWithoutSubAccountsInput> | ContactsCreateWithoutSubAccountsInput[] | ContactsUncheckedCreateWithoutSubAccountsInput[]
    connectOrCreate?: ContactsCreateOrConnectWithoutSubAccountsInput | ContactsCreateOrConnectWithoutSubAccountsInput[]
    createMany?: ContactsCreateManySubAccountsInputEnvelope
    connect?: ContactsWhereUniqueInput | ContactsWhereUniqueInput[]
  }

  export type TriggersCreateNestedManyWithoutSubAccountsInput = {
    create?: XOR<TriggersCreateWithoutSubAccountsInput, TriggersUncheckedCreateWithoutSubAccountsInput> | TriggersCreateWithoutSubAccountsInput[] | TriggersUncheckedCreateWithoutSubAccountsInput[]
    connectOrCreate?: TriggersCreateOrConnectWithoutSubAccountsInput | TriggersCreateOrConnectWithoutSubAccountsInput[]
    createMany?: TriggersCreateManySubAccountsInputEnvelope
    connect?: TriggersWhereUniqueInput | TriggersWhereUniqueInput[]
  }

  export type AutomationsCreateNestedManyWithoutSubAccountsInput = {
    create?: XOR<AutomationsCreateWithoutSubAccountsInput, AutomationsUncheckedCreateWithoutSubAccountsInput> | AutomationsCreateWithoutSubAccountsInput[] | AutomationsUncheckedCreateWithoutSubAccountsInput[]
    connectOrCreate?: AutomationsCreateOrConnectWithoutSubAccountsInput | AutomationsCreateOrConnectWithoutSubAccountsInput[]
    createMany?: AutomationsCreateManySubAccountsInputEnvelope
    connect?: AutomationsWhereUniqueInput | AutomationsWhereUniqueInput[]
  }

  export type PipelinesCreateNestedManyWithoutSubAccountInput = {
    create?: XOR<PipelinesCreateWithoutSubAccountInput, PipelinesUncheckedCreateWithoutSubAccountInput> | PipelinesCreateWithoutSubAccountInput[] | PipelinesUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: PipelinesCreateOrConnectWithoutSubAccountInput | PipelinesCreateOrConnectWithoutSubAccountInput[]
    createMany?: PipelinesCreateManySubAccountInputEnvelope
    connect?: PipelinesWhereUniqueInput | PipelinesWhereUniqueInput[]
  }

  export type TagsCreateNestedManyWithoutSubAccountsInput = {
    create?: XOR<TagsCreateWithoutSubAccountsInput, TagsUncheckedCreateWithoutSubAccountsInput> | TagsCreateWithoutSubAccountsInput[] | TagsUncheckedCreateWithoutSubAccountsInput[]
    connectOrCreate?: TagsCreateOrConnectWithoutSubAccountsInput | TagsCreateOrConnectWithoutSubAccountsInput[]
    createMany?: TagsCreateManySubAccountsInputEnvelope
    connect?: TagsWhereUniqueInput | TagsWhereUniqueInput[]
  }

  export type NotificationsCreateNestedManyWithoutSubAccountsInput = {
    create?: XOR<NotificationsCreateWithoutSubAccountsInput, NotificationsUncheckedCreateWithoutSubAccountsInput> | NotificationsCreateWithoutSubAccountsInput[] | NotificationsUncheckedCreateWithoutSubAccountsInput[]
    connectOrCreate?: NotificationsCreateOrConnectWithoutSubAccountsInput | NotificationsCreateOrConnectWithoutSubAccountsInput[]
    createMany?: NotificationsCreateManySubAccountsInputEnvelope
    connect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
  }

  export type SubAccountSidebarOptionCreateNestedManyWithoutSubAccountInput = {
    create?: XOR<SubAccountSidebarOptionCreateWithoutSubAccountInput, SubAccountSidebarOptionUncheckedCreateWithoutSubAccountInput> | SubAccountSidebarOptionCreateWithoutSubAccountInput[] | SubAccountSidebarOptionUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: SubAccountSidebarOptionCreateOrConnectWithoutSubAccountInput | SubAccountSidebarOptionCreateOrConnectWithoutSubAccountInput[]
    createMany?: SubAccountSidebarOptionCreateManySubAccountInputEnvelope
    connect?: SubAccountSidebarOptionWhereUniqueInput | SubAccountSidebarOptionWhereUniqueInput[]
  }

  export type AgencySidebarOptionUncheckedCreateNestedManyWithoutSubAccountsInput = {
    create?: XOR<AgencySidebarOptionCreateWithoutSubAccountsInput, AgencySidebarOptionUncheckedCreateWithoutSubAccountsInput> | AgencySidebarOptionCreateWithoutSubAccountsInput[] | AgencySidebarOptionUncheckedCreateWithoutSubAccountsInput[]
    connectOrCreate?: AgencySidebarOptionCreateOrConnectWithoutSubAccountsInput | AgencySidebarOptionCreateOrConnectWithoutSubAccountsInput[]
    createMany?: AgencySidebarOptionCreateManySubAccountsInputEnvelope
    connect?: AgencySidebarOptionWhereUniqueInput | AgencySidebarOptionWhereUniqueInput[]
  }

  export type PermissionsUncheckedCreateNestedManyWithoutSubAcctountInput = {
    create?: XOR<PermissionsCreateWithoutSubAcctountInput, PermissionsUncheckedCreateWithoutSubAcctountInput> | PermissionsCreateWithoutSubAcctountInput[] | PermissionsUncheckedCreateWithoutSubAcctountInput[]
    connectOrCreate?: PermissionsCreateOrConnectWithoutSubAcctountInput | PermissionsCreateOrConnectWithoutSubAcctountInput[]
    createMany?: PermissionsCreateManySubAcctountInputEnvelope
    connect?: PermissionsWhereUniqueInput | PermissionsWhereUniqueInput[]
  }

  export type FunnelsUncheckedCreateNestedManyWithoutSubAccountInput = {
    create?: XOR<FunnelsCreateWithoutSubAccountInput, FunnelsUncheckedCreateWithoutSubAccountInput> | FunnelsCreateWithoutSubAccountInput[] | FunnelsUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: FunnelsCreateOrConnectWithoutSubAccountInput | FunnelsCreateOrConnectWithoutSubAccountInput[]
    createMany?: FunnelsCreateManySubAccountInputEnvelope
    connect?: FunnelsWhereUniqueInput | FunnelsWhereUniqueInput[]
  }

  export type MediaUncheckedCreateNestedManyWithoutSubAccountsInput = {
    create?: XOR<MediaCreateWithoutSubAccountsInput, MediaUncheckedCreateWithoutSubAccountsInput> | MediaCreateWithoutSubAccountsInput[] | MediaUncheckedCreateWithoutSubAccountsInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutSubAccountsInput | MediaCreateOrConnectWithoutSubAccountsInput[]
    createMany?: MediaCreateManySubAccountsInputEnvelope
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
  }

  export type ContactsUncheckedCreateNestedManyWithoutSubAccountsInput = {
    create?: XOR<ContactsCreateWithoutSubAccountsInput, ContactsUncheckedCreateWithoutSubAccountsInput> | ContactsCreateWithoutSubAccountsInput[] | ContactsUncheckedCreateWithoutSubAccountsInput[]
    connectOrCreate?: ContactsCreateOrConnectWithoutSubAccountsInput | ContactsCreateOrConnectWithoutSubAccountsInput[]
    createMany?: ContactsCreateManySubAccountsInputEnvelope
    connect?: ContactsWhereUniqueInput | ContactsWhereUniqueInput[]
  }

  export type TriggersUncheckedCreateNestedManyWithoutSubAccountsInput = {
    create?: XOR<TriggersCreateWithoutSubAccountsInput, TriggersUncheckedCreateWithoutSubAccountsInput> | TriggersCreateWithoutSubAccountsInput[] | TriggersUncheckedCreateWithoutSubAccountsInput[]
    connectOrCreate?: TriggersCreateOrConnectWithoutSubAccountsInput | TriggersCreateOrConnectWithoutSubAccountsInput[]
    createMany?: TriggersCreateManySubAccountsInputEnvelope
    connect?: TriggersWhereUniqueInput | TriggersWhereUniqueInput[]
  }

  export type AutomationsUncheckedCreateNestedManyWithoutSubAccountsInput = {
    create?: XOR<AutomationsCreateWithoutSubAccountsInput, AutomationsUncheckedCreateWithoutSubAccountsInput> | AutomationsCreateWithoutSubAccountsInput[] | AutomationsUncheckedCreateWithoutSubAccountsInput[]
    connectOrCreate?: AutomationsCreateOrConnectWithoutSubAccountsInput | AutomationsCreateOrConnectWithoutSubAccountsInput[]
    createMany?: AutomationsCreateManySubAccountsInputEnvelope
    connect?: AutomationsWhereUniqueInput | AutomationsWhereUniqueInput[]
  }

  export type PipelinesUncheckedCreateNestedManyWithoutSubAccountInput = {
    create?: XOR<PipelinesCreateWithoutSubAccountInput, PipelinesUncheckedCreateWithoutSubAccountInput> | PipelinesCreateWithoutSubAccountInput[] | PipelinesUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: PipelinesCreateOrConnectWithoutSubAccountInput | PipelinesCreateOrConnectWithoutSubAccountInput[]
    createMany?: PipelinesCreateManySubAccountInputEnvelope
    connect?: PipelinesWhereUniqueInput | PipelinesWhereUniqueInput[]
  }

  export type TagsUncheckedCreateNestedManyWithoutSubAccountsInput = {
    create?: XOR<TagsCreateWithoutSubAccountsInput, TagsUncheckedCreateWithoutSubAccountsInput> | TagsCreateWithoutSubAccountsInput[] | TagsUncheckedCreateWithoutSubAccountsInput[]
    connectOrCreate?: TagsCreateOrConnectWithoutSubAccountsInput | TagsCreateOrConnectWithoutSubAccountsInput[]
    createMany?: TagsCreateManySubAccountsInputEnvelope
    connect?: TagsWhereUniqueInput | TagsWhereUniqueInput[]
  }

  export type NotificationsUncheckedCreateNestedManyWithoutSubAccountsInput = {
    create?: XOR<NotificationsCreateWithoutSubAccountsInput, NotificationsUncheckedCreateWithoutSubAccountsInput> | NotificationsCreateWithoutSubAccountsInput[] | NotificationsUncheckedCreateWithoutSubAccountsInput[]
    connectOrCreate?: NotificationsCreateOrConnectWithoutSubAccountsInput | NotificationsCreateOrConnectWithoutSubAccountsInput[]
    createMany?: NotificationsCreateManySubAccountsInputEnvelope
    connect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
  }

  export type SubAccountSidebarOptionUncheckedCreateNestedManyWithoutSubAccountInput = {
    create?: XOR<SubAccountSidebarOptionCreateWithoutSubAccountInput, SubAccountSidebarOptionUncheckedCreateWithoutSubAccountInput> | SubAccountSidebarOptionCreateWithoutSubAccountInput[] | SubAccountSidebarOptionUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: SubAccountSidebarOptionCreateOrConnectWithoutSubAccountInput | SubAccountSidebarOptionCreateOrConnectWithoutSubAccountInput[]
    createMany?: SubAccountSidebarOptionCreateManySubAccountInputEnvelope
    connect?: SubAccountSidebarOptionWhereUniqueInput | SubAccountSidebarOptionWhereUniqueInput[]
  }

  export type AgencyUpdateOneRequiredWithoutSubAccountNestedInput = {
    create?: XOR<AgencyCreateWithoutSubAccountInput, AgencyUncheckedCreateWithoutSubAccountInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutSubAccountInput
    upsert?: AgencyUpsertWithoutSubAccountInput
    connect?: AgencyWhereUniqueInput
    update?: XOR<XOR<AgencyUpdateToOneWithWhereWithoutSubAccountInput, AgencyUpdateWithoutSubAccountInput>, AgencyUncheckedUpdateWithoutSubAccountInput>
  }

  export type AgencySidebarOptionUpdateManyWithoutSubAccountsNestedInput = {
    create?: XOR<AgencySidebarOptionCreateWithoutSubAccountsInput, AgencySidebarOptionUncheckedCreateWithoutSubAccountsInput> | AgencySidebarOptionCreateWithoutSubAccountsInput[] | AgencySidebarOptionUncheckedCreateWithoutSubAccountsInput[]
    connectOrCreate?: AgencySidebarOptionCreateOrConnectWithoutSubAccountsInput | AgencySidebarOptionCreateOrConnectWithoutSubAccountsInput[]
    upsert?: AgencySidebarOptionUpsertWithWhereUniqueWithoutSubAccountsInput | AgencySidebarOptionUpsertWithWhereUniqueWithoutSubAccountsInput[]
    createMany?: AgencySidebarOptionCreateManySubAccountsInputEnvelope
    set?: AgencySidebarOptionWhereUniqueInput | AgencySidebarOptionWhereUniqueInput[]
    disconnect?: AgencySidebarOptionWhereUniqueInput | AgencySidebarOptionWhereUniqueInput[]
    delete?: AgencySidebarOptionWhereUniqueInput | AgencySidebarOptionWhereUniqueInput[]
    connect?: AgencySidebarOptionWhereUniqueInput | AgencySidebarOptionWhereUniqueInput[]
    update?: AgencySidebarOptionUpdateWithWhereUniqueWithoutSubAccountsInput | AgencySidebarOptionUpdateWithWhereUniqueWithoutSubAccountsInput[]
    updateMany?: AgencySidebarOptionUpdateManyWithWhereWithoutSubAccountsInput | AgencySidebarOptionUpdateManyWithWhereWithoutSubAccountsInput[]
    deleteMany?: AgencySidebarOptionScalarWhereInput | AgencySidebarOptionScalarWhereInput[]
  }

  export type PermissionsUpdateManyWithoutSubAcctountNestedInput = {
    create?: XOR<PermissionsCreateWithoutSubAcctountInput, PermissionsUncheckedCreateWithoutSubAcctountInput> | PermissionsCreateWithoutSubAcctountInput[] | PermissionsUncheckedCreateWithoutSubAcctountInput[]
    connectOrCreate?: PermissionsCreateOrConnectWithoutSubAcctountInput | PermissionsCreateOrConnectWithoutSubAcctountInput[]
    upsert?: PermissionsUpsertWithWhereUniqueWithoutSubAcctountInput | PermissionsUpsertWithWhereUniqueWithoutSubAcctountInput[]
    createMany?: PermissionsCreateManySubAcctountInputEnvelope
    set?: PermissionsWhereUniqueInput | PermissionsWhereUniqueInput[]
    disconnect?: PermissionsWhereUniqueInput | PermissionsWhereUniqueInput[]
    delete?: PermissionsWhereUniqueInput | PermissionsWhereUniqueInput[]
    connect?: PermissionsWhereUniqueInput | PermissionsWhereUniqueInput[]
    update?: PermissionsUpdateWithWhereUniqueWithoutSubAcctountInput | PermissionsUpdateWithWhereUniqueWithoutSubAcctountInput[]
    updateMany?: PermissionsUpdateManyWithWhereWithoutSubAcctountInput | PermissionsUpdateManyWithWhereWithoutSubAcctountInput[]
    deleteMany?: PermissionsScalarWhereInput | PermissionsScalarWhereInput[]
  }

  export type FunnelsUpdateManyWithoutSubAccountNestedInput = {
    create?: XOR<FunnelsCreateWithoutSubAccountInput, FunnelsUncheckedCreateWithoutSubAccountInput> | FunnelsCreateWithoutSubAccountInput[] | FunnelsUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: FunnelsCreateOrConnectWithoutSubAccountInput | FunnelsCreateOrConnectWithoutSubAccountInput[]
    upsert?: FunnelsUpsertWithWhereUniqueWithoutSubAccountInput | FunnelsUpsertWithWhereUniqueWithoutSubAccountInput[]
    createMany?: FunnelsCreateManySubAccountInputEnvelope
    set?: FunnelsWhereUniqueInput | FunnelsWhereUniqueInput[]
    disconnect?: FunnelsWhereUniqueInput | FunnelsWhereUniqueInput[]
    delete?: FunnelsWhereUniqueInput | FunnelsWhereUniqueInput[]
    connect?: FunnelsWhereUniqueInput | FunnelsWhereUniqueInput[]
    update?: FunnelsUpdateWithWhereUniqueWithoutSubAccountInput | FunnelsUpdateWithWhereUniqueWithoutSubAccountInput[]
    updateMany?: FunnelsUpdateManyWithWhereWithoutSubAccountInput | FunnelsUpdateManyWithWhereWithoutSubAccountInput[]
    deleteMany?: FunnelsScalarWhereInput | FunnelsScalarWhereInput[]
  }

  export type MediaUpdateManyWithoutSubAccountsNestedInput = {
    create?: XOR<MediaCreateWithoutSubAccountsInput, MediaUncheckedCreateWithoutSubAccountsInput> | MediaCreateWithoutSubAccountsInput[] | MediaUncheckedCreateWithoutSubAccountsInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutSubAccountsInput | MediaCreateOrConnectWithoutSubAccountsInput[]
    upsert?: MediaUpsertWithWhereUniqueWithoutSubAccountsInput | MediaUpsertWithWhereUniqueWithoutSubAccountsInput[]
    createMany?: MediaCreateManySubAccountsInputEnvelope
    set?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    disconnect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    delete?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    update?: MediaUpdateWithWhereUniqueWithoutSubAccountsInput | MediaUpdateWithWhereUniqueWithoutSubAccountsInput[]
    updateMany?: MediaUpdateManyWithWhereWithoutSubAccountsInput | MediaUpdateManyWithWhereWithoutSubAccountsInput[]
    deleteMany?: MediaScalarWhereInput | MediaScalarWhereInput[]
  }

  export type ContactsUpdateManyWithoutSubAccountsNestedInput = {
    create?: XOR<ContactsCreateWithoutSubAccountsInput, ContactsUncheckedCreateWithoutSubAccountsInput> | ContactsCreateWithoutSubAccountsInput[] | ContactsUncheckedCreateWithoutSubAccountsInput[]
    connectOrCreate?: ContactsCreateOrConnectWithoutSubAccountsInput | ContactsCreateOrConnectWithoutSubAccountsInput[]
    upsert?: ContactsUpsertWithWhereUniqueWithoutSubAccountsInput | ContactsUpsertWithWhereUniqueWithoutSubAccountsInput[]
    createMany?: ContactsCreateManySubAccountsInputEnvelope
    set?: ContactsWhereUniqueInput | ContactsWhereUniqueInput[]
    disconnect?: ContactsWhereUniqueInput | ContactsWhereUniqueInput[]
    delete?: ContactsWhereUniqueInput | ContactsWhereUniqueInput[]
    connect?: ContactsWhereUniqueInput | ContactsWhereUniqueInput[]
    update?: ContactsUpdateWithWhereUniqueWithoutSubAccountsInput | ContactsUpdateWithWhereUniqueWithoutSubAccountsInput[]
    updateMany?: ContactsUpdateManyWithWhereWithoutSubAccountsInput | ContactsUpdateManyWithWhereWithoutSubAccountsInput[]
    deleteMany?: ContactsScalarWhereInput | ContactsScalarWhereInput[]
  }

  export type TriggersUpdateManyWithoutSubAccountsNestedInput = {
    create?: XOR<TriggersCreateWithoutSubAccountsInput, TriggersUncheckedCreateWithoutSubAccountsInput> | TriggersCreateWithoutSubAccountsInput[] | TriggersUncheckedCreateWithoutSubAccountsInput[]
    connectOrCreate?: TriggersCreateOrConnectWithoutSubAccountsInput | TriggersCreateOrConnectWithoutSubAccountsInput[]
    upsert?: TriggersUpsertWithWhereUniqueWithoutSubAccountsInput | TriggersUpsertWithWhereUniqueWithoutSubAccountsInput[]
    createMany?: TriggersCreateManySubAccountsInputEnvelope
    set?: TriggersWhereUniqueInput | TriggersWhereUniqueInput[]
    disconnect?: TriggersWhereUniqueInput | TriggersWhereUniqueInput[]
    delete?: TriggersWhereUniqueInput | TriggersWhereUniqueInput[]
    connect?: TriggersWhereUniqueInput | TriggersWhereUniqueInput[]
    update?: TriggersUpdateWithWhereUniqueWithoutSubAccountsInput | TriggersUpdateWithWhereUniqueWithoutSubAccountsInput[]
    updateMany?: TriggersUpdateManyWithWhereWithoutSubAccountsInput | TriggersUpdateManyWithWhereWithoutSubAccountsInput[]
    deleteMany?: TriggersScalarWhereInput | TriggersScalarWhereInput[]
  }

  export type AutomationsUpdateManyWithoutSubAccountsNestedInput = {
    create?: XOR<AutomationsCreateWithoutSubAccountsInput, AutomationsUncheckedCreateWithoutSubAccountsInput> | AutomationsCreateWithoutSubAccountsInput[] | AutomationsUncheckedCreateWithoutSubAccountsInput[]
    connectOrCreate?: AutomationsCreateOrConnectWithoutSubAccountsInput | AutomationsCreateOrConnectWithoutSubAccountsInput[]
    upsert?: AutomationsUpsertWithWhereUniqueWithoutSubAccountsInput | AutomationsUpsertWithWhereUniqueWithoutSubAccountsInput[]
    createMany?: AutomationsCreateManySubAccountsInputEnvelope
    set?: AutomationsWhereUniqueInput | AutomationsWhereUniqueInput[]
    disconnect?: AutomationsWhereUniqueInput | AutomationsWhereUniqueInput[]
    delete?: AutomationsWhereUniqueInput | AutomationsWhereUniqueInput[]
    connect?: AutomationsWhereUniqueInput | AutomationsWhereUniqueInput[]
    update?: AutomationsUpdateWithWhereUniqueWithoutSubAccountsInput | AutomationsUpdateWithWhereUniqueWithoutSubAccountsInput[]
    updateMany?: AutomationsUpdateManyWithWhereWithoutSubAccountsInput | AutomationsUpdateManyWithWhereWithoutSubAccountsInput[]
    deleteMany?: AutomationsScalarWhereInput | AutomationsScalarWhereInput[]
  }

  export type PipelinesUpdateManyWithoutSubAccountNestedInput = {
    create?: XOR<PipelinesCreateWithoutSubAccountInput, PipelinesUncheckedCreateWithoutSubAccountInput> | PipelinesCreateWithoutSubAccountInput[] | PipelinesUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: PipelinesCreateOrConnectWithoutSubAccountInput | PipelinesCreateOrConnectWithoutSubAccountInput[]
    upsert?: PipelinesUpsertWithWhereUniqueWithoutSubAccountInput | PipelinesUpsertWithWhereUniqueWithoutSubAccountInput[]
    createMany?: PipelinesCreateManySubAccountInputEnvelope
    set?: PipelinesWhereUniqueInput | PipelinesWhereUniqueInput[]
    disconnect?: PipelinesWhereUniqueInput | PipelinesWhereUniqueInput[]
    delete?: PipelinesWhereUniqueInput | PipelinesWhereUniqueInput[]
    connect?: PipelinesWhereUniqueInput | PipelinesWhereUniqueInput[]
    update?: PipelinesUpdateWithWhereUniqueWithoutSubAccountInput | PipelinesUpdateWithWhereUniqueWithoutSubAccountInput[]
    updateMany?: PipelinesUpdateManyWithWhereWithoutSubAccountInput | PipelinesUpdateManyWithWhereWithoutSubAccountInput[]
    deleteMany?: PipelinesScalarWhereInput | PipelinesScalarWhereInput[]
  }

  export type TagsUpdateManyWithoutSubAccountsNestedInput = {
    create?: XOR<TagsCreateWithoutSubAccountsInput, TagsUncheckedCreateWithoutSubAccountsInput> | TagsCreateWithoutSubAccountsInput[] | TagsUncheckedCreateWithoutSubAccountsInput[]
    connectOrCreate?: TagsCreateOrConnectWithoutSubAccountsInput | TagsCreateOrConnectWithoutSubAccountsInput[]
    upsert?: TagsUpsertWithWhereUniqueWithoutSubAccountsInput | TagsUpsertWithWhereUniqueWithoutSubAccountsInput[]
    createMany?: TagsCreateManySubAccountsInputEnvelope
    set?: TagsWhereUniqueInput | TagsWhereUniqueInput[]
    disconnect?: TagsWhereUniqueInput | TagsWhereUniqueInput[]
    delete?: TagsWhereUniqueInput | TagsWhereUniqueInput[]
    connect?: TagsWhereUniqueInput | TagsWhereUniqueInput[]
    update?: TagsUpdateWithWhereUniqueWithoutSubAccountsInput | TagsUpdateWithWhereUniqueWithoutSubAccountsInput[]
    updateMany?: TagsUpdateManyWithWhereWithoutSubAccountsInput | TagsUpdateManyWithWhereWithoutSubAccountsInput[]
    deleteMany?: TagsScalarWhereInput | TagsScalarWhereInput[]
  }

  export type NotificationsUpdateManyWithoutSubAccountsNestedInput = {
    create?: XOR<NotificationsCreateWithoutSubAccountsInput, NotificationsUncheckedCreateWithoutSubAccountsInput> | NotificationsCreateWithoutSubAccountsInput[] | NotificationsUncheckedCreateWithoutSubAccountsInput[]
    connectOrCreate?: NotificationsCreateOrConnectWithoutSubAccountsInput | NotificationsCreateOrConnectWithoutSubAccountsInput[]
    upsert?: NotificationsUpsertWithWhereUniqueWithoutSubAccountsInput | NotificationsUpsertWithWhereUniqueWithoutSubAccountsInput[]
    createMany?: NotificationsCreateManySubAccountsInputEnvelope
    set?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    disconnect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    delete?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    connect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    update?: NotificationsUpdateWithWhereUniqueWithoutSubAccountsInput | NotificationsUpdateWithWhereUniqueWithoutSubAccountsInput[]
    updateMany?: NotificationsUpdateManyWithWhereWithoutSubAccountsInput | NotificationsUpdateManyWithWhereWithoutSubAccountsInput[]
    deleteMany?: NotificationsScalarWhereInput | NotificationsScalarWhereInput[]
  }

  export type SubAccountSidebarOptionUpdateManyWithoutSubAccountNestedInput = {
    create?: XOR<SubAccountSidebarOptionCreateWithoutSubAccountInput, SubAccountSidebarOptionUncheckedCreateWithoutSubAccountInput> | SubAccountSidebarOptionCreateWithoutSubAccountInput[] | SubAccountSidebarOptionUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: SubAccountSidebarOptionCreateOrConnectWithoutSubAccountInput | SubAccountSidebarOptionCreateOrConnectWithoutSubAccountInput[]
    upsert?: SubAccountSidebarOptionUpsertWithWhereUniqueWithoutSubAccountInput | SubAccountSidebarOptionUpsertWithWhereUniqueWithoutSubAccountInput[]
    createMany?: SubAccountSidebarOptionCreateManySubAccountInputEnvelope
    set?: SubAccountSidebarOptionWhereUniqueInput | SubAccountSidebarOptionWhereUniqueInput[]
    disconnect?: SubAccountSidebarOptionWhereUniqueInput | SubAccountSidebarOptionWhereUniqueInput[]
    delete?: SubAccountSidebarOptionWhereUniqueInput | SubAccountSidebarOptionWhereUniqueInput[]
    connect?: SubAccountSidebarOptionWhereUniqueInput | SubAccountSidebarOptionWhereUniqueInput[]
    update?: SubAccountSidebarOptionUpdateWithWhereUniqueWithoutSubAccountInput | SubAccountSidebarOptionUpdateWithWhereUniqueWithoutSubAccountInput[]
    updateMany?: SubAccountSidebarOptionUpdateManyWithWhereWithoutSubAccountInput | SubAccountSidebarOptionUpdateManyWithWhereWithoutSubAccountInput[]
    deleteMany?: SubAccountSidebarOptionScalarWhereInput | SubAccountSidebarOptionScalarWhereInput[]
  }

  export type AgencySidebarOptionUncheckedUpdateManyWithoutSubAccountsNestedInput = {
    create?: XOR<AgencySidebarOptionCreateWithoutSubAccountsInput, AgencySidebarOptionUncheckedCreateWithoutSubAccountsInput> | AgencySidebarOptionCreateWithoutSubAccountsInput[] | AgencySidebarOptionUncheckedCreateWithoutSubAccountsInput[]
    connectOrCreate?: AgencySidebarOptionCreateOrConnectWithoutSubAccountsInput | AgencySidebarOptionCreateOrConnectWithoutSubAccountsInput[]
    upsert?: AgencySidebarOptionUpsertWithWhereUniqueWithoutSubAccountsInput | AgencySidebarOptionUpsertWithWhereUniqueWithoutSubAccountsInput[]
    createMany?: AgencySidebarOptionCreateManySubAccountsInputEnvelope
    set?: AgencySidebarOptionWhereUniqueInput | AgencySidebarOptionWhereUniqueInput[]
    disconnect?: AgencySidebarOptionWhereUniqueInput | AgencySidebarOptionWhereUniqueInput[]
    delete?: AgencySidebarOptionWhereUniqueInput | AgencySidebarOptionWhereUniqueInput[]
    connect?: AgencySidebarOptionWhereUniqueInput | AgencySidebarOptionWhereUniqueInput[]
    update?: AgencySidebarOptionUpdateWithWhereUniqueWithoutSubAccountsInput | AgencySidebarOptionUpdateWithWhereUniqueWithoutSubAccountsInput[]
    updateMany?: AgencySidebarOptionUpdateManyWithWhereWithoutSubAccountsInput | AgencySidebarOptionUpdateManyWithWhereWithoutSubAccountsInput[]
    deleteMany?: AgencySidebarOptionScalarWhereInput | AgencySidebarOptionScalarWhereInput[]
  }

  export type PermissionsUncheckedUpdateManyWithoutSubAcctountNestedInput = {
    create?: XOR<PermissionsCreateWithoutSubAcctountInput, PermissionsUncheckedCreateWithoutSubAcctountInput> | PermissionsCreateWithoutSubAcctountInput[] | PermissionsUncheckedCreateWithoutSubAcctountInput[]
    connectOrCreate?: PermissionsCreateOrConnectWithoutSubAcctountInput | PermissionsCreateOrConnectWithoutSubAcctountInput[]
    upsert?: PermissionsUpsertWithWhereUniqueWithoutSubAcctountInput | PermissionsUpsertWithWhereUniqueWithoutSubAcctountInput[]
    createMany?: PermissionsCreateManySubAcctountInputEnvelope
    set?: PermissionsWhereUniqueInput | PermissionsWhereUniqueInput[]
    disconnect?: PermissionsWhereUniqueInput | PermissionsWhereUniqueInput[]
    delete?: PermissionsWhereUniqueInput | PermissionsWhereUniqueInput[]
    connect?: PermissionsWhereUniqueInput | PermissionsWhereUniqueInput[]
    update?: PermissionsUpdateWithWhereUniqueWithoutSubAcctountInput | PermissionsUpdateWithWhereUniqueWithoutSubAcctountInput[]
    updateMany?: PermissionsUpdateManyWithWhereWithoutSubAcctountInput | PermissionsUpdateManyWithWhereWithoutSubAcctountInput[]
    deleteMany?: PermissionsScalarWhereInput | PermissionsScalarWhereInput[]
  }

  export type FunnelsUncheckedUpdateManyWithoutSubAccountNestedInput = {
    create?: XOR<FunnelsCreateWithoutSubAccountInput, FunnelsUncheckedCreateWithoutSubAccountInput> | FunnelsCreateWithoutSubAccountInput[] | FunnelsUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: FunnelsCreateOrConnectWithoutSubAccountInput | FunnelsCreateOrConnectWithoutSubAccountInput[]
    upsert?: FunnelsUpsertWithWhereUniqueWithoutSubAccountInput | FunnelsUpsertWithWhereUniqueWithoutSubAccountInput[]
    createMany?: FunnelsCreateManySubAccountInputEnvelope
    set?: FunnelsWhereUniqueInput | FunnelsWhereUniqueInput[]
    disconnect?: FunnelsWhereUniqueInput | FunnelsWhereUniqueInput[]
    delete?: FunnelsWhereUniqueInput | FunnelsWhereUniqueInput[]
    connect?: FunnelsWhereUniqueInput | FunnelsWhereUniqueInput[]
    update?: FunnelsUpdateWithWhereUniqueWithoutSubAccountInput | FunnelsUpdateWithWhereUniqueWithoutSubAccountInput[]
    updateMany?: FunnelsUpdateManyWithWhereWithoutSubAccountInput | FunnelsUpdateManyWithWhereWithoutSubAccountInput[]
    deleteMany?: FunnelsScalarWhereInput | FunnelsScalarWhereInput[]
  }

  export type MediaUncheckedUpdateManyWithoutSubAccountsNestedInput = {
    create?: XOR<MediaCreateWithoutSubAccountsInput, MediaUncheckedCreateWithoutSubAccountsInput> | MediaCreateWithoutSubAccountsInput[] | MediaUncheckedCreateWithoutSubAccountsInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutSubAccountsInput | MediaCreateOrConnectWithoutSubAccountsInput[]
    upsert?: MediaUpsertWithWhereUniqueWithoutSubAccountsInput | MediaUpsertWithWhereUniqueWithoutSubAccountsInput[]
    createMany?: MediaCreateManySubAccountsInputEnvelope
    set?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    disconnect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    delete?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    update?: MediaUpdateWithWhereUniqueWithoutSubAccountsInput | MediaUpdateWithWhereUniqueWithoutSubAccountsInput[]
    updateMany?: MediaUpdateManyWithWhereWithoutSubAccountsInput | MediaUpdateManyWithWhereWithoutSubAccountsInput[]
    deleteMany?: MediaScalarWhereInput | MediaScalarWhereInput[]
  }

  export type ContactsUncheckedUpdateManyWithoutSubAccountsNestedInput = {
    create?: XOR<ContactsCreateWithoutSubAccountsInput, ContactsUncheckedCreateWithoutSubAccountsInput> | ContactsCreateWithoutSubAccountsInput[] | ContactsUncheckedCreateWithoutSubAccountsInput[]
    connectOrCreate?: ContactsCreateOrConnectWithoutSubAccountsInput | ContactsCreateOrConnectWithoutSubAccountsInput[]
    upsert?: ContactsUpsertWithWhereUniqueWithoutSubAccountsInput | ContactsUpsertWithWhereUniqueWithoutSubAccountsInput[]
    createMany?: ContactsCreateManySubAccountsInputEnvelope
    set?: ContactsWhereUniqueInput | ContactsWhereUniqueInput[]
    disconnect?: ContactsWhereUniqueInput | ContactsWhereUniqueInput[]
    delete?: ContactsWhereUniqueInput | ContactsWhereUniqueInput[]
    connect?: ContactsWhereUniqueInput | ContactsWhereUniqueInput[]
    update?: ContactsUpdateWithWhereUniqueWithoutSubAccountsInput | ContactsUpdateWithWhereUniqueWithoutSubAccountsInput[]
    updateMany?: ContactsUpdateManyWithWhereWithoutSubAccountsInput | ContactsUpdateManyWithWhereWithoutSubAccountsInput[]
    deleteMany?: ContactsScalarWhereInput | ContactsScalarWhereInput[]
  }

  export type TriggersUncheckedUpdateManyWithoutSubAccountsNestedInput = {
    create?: XOR<TriggersCreateWithoutSubAccountsInput, TriggersUncheckedCreateWithoutSubAccountsInput> | TriggersCreateWithoutSubAccountsInput[] | TriggersUncheckedCreateWithoutSubAccountsInput[]
    connectOrCreate?: TriggersCreateOrConnectWithoutSubAccountsInput | TriggersCreateOrConnectWithoutSubAccountsInput[]
    upsert?: TriggersUpsertWithWhereUniqueWithoutSubAccountsInput | TriggersUpsertWithWhereUniqueWithoutSubAccountsInput[]
    createMany?: TriggersCreateManySubAccountsInputEnvelope
    set?: TriggersWhereUniqueInput | TriggersWhereUniqueInput[]
    disconnect?: TriggersWhereUniqueInput | TriggersWhereUniqueInput[]
    delete?: TriggersWhereUniqueInput | TriggersWhereUniqueInput[]
    connect?: TriggersWhereUniqueInput | TriggersWhereUniqueInput[]
    update?: TriggersUpdateWithWhereUniqueWithoutSubAccountsInput | TriggersUpdateWithWhereUniqueWithoutSubAccountsInput[]
    updateMany?: TriggersUpdateManyWithWhereWithoutSubAccountsInput | TriggersUpdateManyWithWhereWithoutSubAccountsInput[]
    deleteMany?: TriggersScalarWhereInput | TriggersScalarWhereInput[]
  }

  export type AutomationsUncheckedUpdateManyWithoutSubAccountsNestedInput = {
    create?: XOR<AutomationsCreateWithoutSubAccountsInput, AutomationsUncheckedCreateWithoutSubAccountsInput> | AutomationsCreateWithoutSubAccountsInput[] | AutomationsUncheckedCreateWithoutSubAccountsInput[]
    connectOrCreate?: AutomationsCreateOrConnectWithoutSubAccountsInput | AutomationsCreateOrConnectWithoutSubAccountsInput[]
    upsert?: AutomationsUpsertWithWhereUniqueWithoutSubAccountsInput | AutomationsUpsertWithWhereUniqueWithoutSubAccountsInput[]
    createMany?: AutomationsCreateManySubAccountsInputEnvelope
    set?: AutomationsWhereUniqueInput | AutomationsWhereUniqueInput[]
    disconnect?: AutomationsWhereUniqueInput | AutomationsWhereUniqueInput[]
    delete?: AutomationsWhereUniqueInput | AutomationsWhereUniqueInput[]
    connect?: AutomationsWhereUniqueInput | AutomationsWhereUniqueInput[]
    update?: AutomationsUpdateWithWhereUniqueWithoutSubAccountsInput | AutomationsUpdateWithWhereUniqueWithoutSubAccountsInput[]
    updateMany?: AutomationsUpdateManyWithWhereWithoutSubAccountsInput | AutomationsUpdateManyWithWhereWithoutSubAccountsInput[]
    deleteMany?: AutomationsScalarWhereInput | AutomationsScalarWhereInput[]
  }

  export type PipelinesUncheckedUpdateManyWithoutSubAccountNestedInput = {
    create?: XOR<PipelinesCreateWithoutSubAccountInput, PipelinesUncheckedCreateWithoutSubAccountInput> | PipelinesCreateWithoutSubAccountInput[] | PipelinesUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: PipelinesCreateOrConnectWithoutSubAccountInput | PipelinesCreateOrConnectWithoutSubAccountInput[]
    upsert?: PipelinesUpsertWithWhereUniqueWithoutSubAccountInput | PipelinesUpsertWithWhereUniqueWithoutSubAccountInput[]
    createMany?: PipelinesCreateManySubAccountInputEnvelope
    set?: PipelinesWhereUniqueInput | PipelinesWhereUniqueInput[]
    disconnect?: PipelinesWhereUniqueInput | PipelinesWhereUniqueInput[]
    delete?: PipelinesWhereUniqueInput | PipelinesWhereUniqueInput[]
    connect?: PipelinesWhereUniqueInput | PipelinesWhereUniqueInput[]
    update?: PipelinesUpdateWithWhereUniqueWithoutSubAccountInput | PipelinesUpdateWithWhereUniqueWithoutSubAccountInput[]
    updateMany?: PipelinesUpdateManyWithWhereWithoutSubAccountInput | PipelinesUpdateManyWithWhereWithoutSubAccountInput[]
    deleteMany?: PipelinesScalarWhereInput | PipelinesScalarWhereInput[]
  }

  export type TagsUncheckedUpdateManyWithoutSubAccountsNestedInput = {
    create?: XOR<TagsCreateWithoutSubAccountsInput, TagsUncheckedCreateWithoutSubAccountsInput> | TagsCreateWithoutSubAccountsInput[] | TagsUncheckedCreateWithoutSubAccountsInput[]
    connectOrCreate?: TagsCreateOrConnectWithoutSubAccountsInput | TagsCreateOrConnectWithoutSubAccountsInput[]
    upsert?: TagsUpsertWithWhereUniqueWithoutSubAccountsInput | TagsUpsertWithWhereUniqueWithoutSubAccountsInput[]
    createMany?: TagsCreateManySubAccountsInputEnvelope
    set?: TagsWhereUniqueInput | TagsWhereUniqueInput[]
    disconnect?: TagsWhereUniqueInput | TagsWhereUniqueInput[]
    delete?: TagsWhereUniqueInput | TagsWhereUniqueInput[]
    connect?: TagsWhereUniqueInput | TagsWhereUniqueInput[]
    update?: TagsUpdateWithWhereUniqueWithoutSubAccountsInput | TagsUpdateWithWhereUniqueWithoutSubAccountsInput[]
    updateMany?: TagsUpdateManyWithWhereWithoutSubAccountsInput | TagsUpdateManyWithWhereWithoutSubAccountsInput[]
    deleteMany?: TagsScalarWhereInput | TagsScalarWhereInput[]
  }

  export type NotificationsUncheckedUpdateManyWithoutSubAccountsNestedInput = {
    create?: XOR<NotificationsCreateWithoutSubAccountsInput, NotificationsUncheckedCreateWithoutSubAccountsInput> | NotificationsCreateWithoutSubAccountsInput[] | NotificationsUncheckedCreateWithoutSubAccountsInput[]
    connectOrCreate?: NotificationsCreateOrConnectWithoutSubAccountsInput | NotificationsCreateOrConnectWithoutSubAccountsInput[]
    upsert?: NotificationsUpsertWithWhereUniqueWithoutSubAccountsInput | NotificationsUpsertWithWhereUniqueWithoutSubAccountsInput[]
    createMany?: NotificationsCreateManySubAccountsInputEnvelope
    set?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    disconnect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    delete?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    connect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    update?: NotificationsUpdateWithWhereUniqueWithoutSubAccountsInput | NotificationsUpdateWithWhereUniqueWithoutSubAccountsInput[]
    updateMany?: NotificationsUpdateManyWithWhereWithoutSubAccountsInput | NotificationsUpdateManyWithWhereWithoutSubAccountsInput[]
    deleteMany?: NotificationsScalarWhereInput | NotificationsScalarWhereInput[]
  }

  export type SubAccountSidebarOptionUncheckedUpdateManyWithoutSubAccountNestedInput = {
    create?: XOR<SubAccountSidebarOptionCreateWithoutSubAccountInput, SubAccountSidebarOptionUncheckedCreateWithoutSubAccountInput> | SubAccountSidebarOptionCreateWithoutSubAccountInput[] | SubAccountSidebarOptionUncheckedCreateWithoutSubAccountInput[]
    connectOrCreate?: SubAccountSidebarOptionCreateOrConnectWithoutSubAccountInput | SubAccountSidebarOptionCreateOrConnectWithoutSubAccountInput[]
    upsert?: SubAccountSidebarOptionUpsertWithWhereUniqueWithoutSubAccountInput | SubAccountSidebarOptionUpsertWithWhereUniqueWithoutSubAccountInput[]
    createMany?: SubAccountSidebarOptionCreateManySubAccountInputEnvelope
    set?: SubAccountSidebarOptionWhereUniqueInput | SubAccountSidebarOptionWhereUniqueInput[]
    disconnect?: SubAccountSidebarOptionWhereUniqueInput | SubAccountSidebarOptionWhereUniqueInput[]
    delete?: SubAccountSidebarOptionWhereUniqueInput | SubAccountSidebarOptionWhereUniqueInput[]
    connect?: SubAccountSidebarOptionWhereUniqueInput | SubAccountSidebarOptionWhereUniqueInput[]
    update?: SubAccountSidebarOptionUpdateWithWhereUniqueWithoutSubAccountInput | SubAccountSidebarOptionUpdateWithWhereUniqueWithoutSubAccountInput[]
    updateMany?: SubAccountSidebarOptionUpdateManyWithWhereWithoutSubAccountInput | SubAccountSidebarOptionUpdateManyWithWhereWithoutSubAccountInput[]
    deleteMany?: SubAccountSidebarOptionScalarWhereInput | SubAccountSidebarOptionScalarWhereInput[]
  }

  export type LaneCreateNestedManyWithoutPipelineInput = {
    create?: XOR<LaneCreateWithoutPipelineInput, LaneUncheckedCreateWithoutPipelineInput> | LaneCreateWithoutPipelineInput[] | LaneUncheckedCreateWithoutPipelineInput[]
    connectOrCreate?: LaneCreateOrConnectWithoutPipelineInput | LaneCreateOrConnectWithoutPipelineInput[]
    createMany?: LaneCreateManyPipelineInputEnvelope
    connect?: LaneWhereUniqueInput | LaneWhereUniqueInput[]
  }

  export type SubAccountsCreateNestedOneWithoutPipelineInput = {
    create?: XOR<SubAccountsCreateWithoutPipelineInput, SubAccountsUncheckedCreateWithoutPipelineInput>
    connectOrCreate?: SubAccountsCreateOrConnectWithoutPipelineInput
    connect?: SubAccountsWhereUniqueInput
  }

  export type LaneUncheckedCreateNestedManyWithoutPipelineInput = {
    create?: XOR<LaneCreateWithoutPipelineInput, LaneUncheckedCreateWithoutPipelineInput> | LaneCreateWithoutPipelineInput[] | LaneUncheckedCreateWithoutPipelineInput[]
    connectOrCreate?: LaneCreateOrConnectWithoutPipelineInput | LaneCreateOrConnectWithoutPipelineInput[]
    createMany?: LaneCreateManyPipelineInputEnvelope
    connect?: LaneWhereUniqueInput | LaneWhereUniqueInput[]
  }

  export type LaneUpdateManyWithoutPipelineNestedInput = {
    create?: XOR<LaneCreateWithoutPipelineInput, LaneUncheckedCreateWithoutPipelineInput> | LaneCreateWithoutPipelineInput[] | LaneUncheckedCreateWithoutPipelineInput[]
    connectOrCreate?: LaneCreateOrConnectWithoutPipelineInput | LaneCreateOrConnectWithoutPipelineInput[]
    upsert?: LaneUpsertWithWhereUniqueWithoutPipelineInput | LaneUpsertWithWhereUniqueWithoutPipelineInput[]
    createMany?: LaneCreateManyPipelineInputEnvelope
    set?: LaneWhereUniqueInput | LaneWhereUniqueInput[]
    disconnect?: LaneWhereUniqueInput | LaneWhereUniqueInput[]
    delete?: LaneWhereUniqueInput | LaneWhereUniqueInput[]
    connect?: LaneWhereUniqueInput | LaneWhereUniqueInput[]
    update?: LaneUpdateWithWhereUniqueWithoutPipelineInput | LaneUpdateWithWhereUniqueWithoutPipelineInput[]
    updateMany?: LaneUpdateManyWithWhereWithoutPipelineInput | LaneUpdateManyWithWhereWithoutPipelineInput[]
    deleteMany?: LaneScalarWhereInput | LaneScalarWhereInput[]
  }

  export type SubAccountsUpdateOneRequiredWithoutPipelineNestedInput = {
    create?: XOR<SubAccountsCreateWithoutPipelineInput, SubAccountsUncheckedCreateWithoutPipelineInput>
    connectOrCreate?: SubAccountsCreateOrConnectWithoutPipelineInput
    upsert?: SubAccountsUpsertWithoutPipelineInput
    connect?: SubAccountsWhereUniqueInput
    update?: XOR<XOR<SubAccountsUpdateToOneWithWhereWithoutPipelineInput, SubAccountsUpdateWithoutPipelineInput>, SubAccountsUncheckedUpdateWithoutPipelineInput>
  }

  export type LaneUncheckedUpdateManyWithoutPipelineNestedInput = {
    create?: XOR<LaneCreateWithoutPipelineInput, LaneUncheckedCreateWithoutPipelineInput> | LaneCreateWithoutPipelineInput[] | LaneUncheckedCreateWithoutPipelineInput[]
    connectOrCreate?: LaneCreateOrConnectWithoutPipelineInput | LaneCreateOrConnectWithoutPipelineInput[]
    upsert?: LaneUpsertWithWhereUniqueWithoutPipelineInput | LaneUpsertWithWhereUniqueWithoutPipelineInput[]
    createMany?: LaneCreateManyPipelineInputEnvelope
    set?: LaneWhereUniqueInput | LaneWhereUniqueInput[]
    disconnect?: LaneWhereUniqueInput | LaneWhereUniqueInput[]
    delete?: LaneWhereUniqueInput | LaneWhereUniqueInput[]
    connect?: LaneWhereUniqueInput | LaneWhereUniqueInput[]
    update?: LaneUpdateWithWhereUniqueWithoutPipelineInput | LaneUpdateWithWhereUniqueWithoutPipelineInput[]
    updateMany?: LaneUpdateManyWithWhereWithoutPipelineInput | LaneUpdateManyWithWhereWithoutPipelineInput[]
    deleteMany?: LaneScalarWhereInput | LaneScalarWhereInput[]
  }

  export type SubAccountsCreateNestedOneWithoutTriggerInput = {
    create?: XOR<SubAccountsCreateWithoutTriggerInput, SubAccountsUncheckedCreateWithoutTriggerInput>
    connectOrCreate?: SubAccountsCreateOrConnectWithoutTriggerInput
    connect?: SubAccountsWhereUniqueInput
  }

  export type AutomationsCreateNestedManyWithoutTriggerInput = {
    create?: XOR<AutomationsCreateWithoutTriggerInput, AutomationsUncheckedCreateWithoutTriggerInput> | AutomationsCreateWithoutTriggerInput[] | AutomationsUncheckedCreateWithoutTriggerInput[]
    connectOrCreate?: AutomationsCreateOrConnectWithoutTriggerInput | AutomationsCreateOrConnectWithoutTriggerInput[]
    createMany?: AutomationsCreateManyTriggerInputEnvelope
    connect?: AutomationsWhereUniqueInput | AutomationsWhereUniqueInput[]
  }

  export type AutomationsUncheckedCreateNestedManyWithoutTriggerInput = {
    create?: XOR<AutomationsCreateWithoutTriggerInput, AutomationsUncheckedCreateWithoutTriggerInput> | AutomationsCreateWithoutTriggerInput[] | AutomationsUncheckedCreateWithoutTriggerInput[]
    connectOrCreate?: AutomationsCreateOrConnectWithoutTriggerInput | AutomationsCreateOrConnectWithoutTriggerInput[]
    createMany?: AutomationsCreateManyTriggerInputEnvelope
    connect?: AutomationsWhereUniqueInput | AutomationsWhereUniqueInput[]
  }

  export type EnumTriggerTypesFieldUpdateOperationsInput = {
    set?: $Enums.TriggerTypes
  }

  export type SubAccountsUpdateOneRequiredWithoutTriggerNestedInput = {
    create?: XOR<SubAccountsCreateWithoutTriggerInput, SubAccountsUncheckedCreateWithoutTriggerInput>
    connectOrCreate?: SubAccountsCreateOrConnectWithoutTriggerInput
    upsert?: SubAccountsUpsertWithoutTriggerInput
    connect?: SubAccountsWhereUniqueInput
    update?: XOR<XOR<SubAccountsUpdateToOneWithWhereWithoutTriggerInput, SubAccountsUpdateWithoutTriggerInput>, SubAccountsUncheckedUpdateWithoutTriggerInput>
  }

  export type AutomationsUpdateManyWithoutTriggerNestedInput = {
    create?: XOR<AutomationsCreateWithoutTriggerInput, AutomationsUncheckedCreateWithoutTriggerInput> | AutomationsCreateWithoutTriggerInput[] | AutomationsUncheckedCreateWithoutTriggerInput[]
    connectOrCreate?: AutomationsCreateOrConnectWithoutTriggerInput | AutomationsCreateOrConnectWithoutTriggerInput[]
    upsert?: AutomationsUpsertWithWhereUniqueWithoutTriggerInput | AutomationsUpsertWithWhereUniqueWithoutTriggerInput[]
    createMany?: AutomationsCreateManyTriggerInputEnvelope
    set?: AutomationsWhereUniqueInput | AutomationsWhereUniqueInput[]
    disconnect?: AutomationsWhereUniqueInput | AutomationsWhereUniqueInput[]
    delete?: AutomationsWhereUniqueInput | AutomationsWhereUniqueInput[]
    connect?: AutomationsWhereUniqueInput | AutomationsWhereUniqueInput[]
    update?: AutomationsUpdateWithWhereUniqueWithoutTriggerInput | AutomationsUpdateWithWhereUniqueWithoutTriggerInput[]
    updateMany?: AutomationsUpdateManyWithWhereWithoutTriggerInput | AutomationsUpdateManyWithWhereWithoutTriggerInput[]
    deleteMany?: AutomationsScalarWhereInput | AutomationsScalarWhereInput[]
  }

  export type AutomationsUncheckedUpdateManyWithoutTriggerNestedInput = {
    create?: XOR<AutomationsCreateWithoutTriggerInput, AutomationsUncheckedCreateWithoutTriggerInput> | AutomationsCreateWithoutTriggerInput[] | AutomationsUncheckedCreateWithoutTriggerInput[]
    connectOrCreate?: AutomationsCreateOrConnectWithoutTriggerInput | AutomationsCreateOrConnectWithoutTriggerInput[]
    upsert?: AutomationsUpsertWithWhereUniqueWithoutTriggerInput | AutomationsUpsertWithWhereUniqueWithoutTriggerInput[]
    createMany?: AutomationsCreateManyTriggerInputEnvelope
    set?: AutomationsWhereUniqueInput | AutomationsWhereUniqueInput[]
    disconnect?: AutomationsWhereUniqueInput | AutomationsWhereUniqueInput[]
    delete?: AutomationsWhereUniqueInput | AutomationsWhereUniqueInput[]
    connect?: AutomationsWhereUniqueInput | AutomationsWhereUniqueInput[]
    update?: AutomationsUpdateWithWhereUniqueWithoutTriggerInput | AutomationsUpdateWithWhereUniqueWithoutTriggerInput[]
    updateMany?: AutomationsUpdateManyWithWhereWithoutTriggerInput | AutomationsUpdateManyWithWhereWithoutTriggerInput[]
    deleteMany?: AutomationsScalarWhereInput | AutomationsScalarWhereInput[]
  }

  export type TriggersCreateNestedOneWithoutAutomationsInput = {
    create?: XOR<TriggersCreateWithoutAutomationsInput, TriggersUncheckedCreateWithoutAutomationsInput>
    connectOrCreate?: TriggersCreateOrConnectWithoutAutomationsInput
    connect?: TriggersWhereUniqueInput
  }

  export type SubAccountsCreateNestedOneWithoutAutomationInput = {
    create?: XOR<SubAccountsCreateWithoutAutomationInput, SubAccountsUncheckedCreateWithoutAutomationInput>
    connectOrCreate?: SubAccountsCreateOrConnectWithoutAutomationInput
    connect?: SubAccountsWhereUniqueInput
  }

  export type ActionsCreateNestedManyWithoutAutomationsInput = {
    create?: XOR<ActionsCreateWithoutAutomationsInput, ActionsUncheckedCreateWithoutAutomationsInput> | ActionsCreateWithoutAutomationsInput[] | ActionsUncheckedCreateWithoutAutomationsInput[]
    connectOrCreate?: ActionsCreateOrConnectWithoutAutomationsInput | ActionsCreateOrConnectWithoutAutomationsInput[]
    createMany?: ActionsCreateManyAutomationsInputEnvelope
    connect?: ActionsWhereUniqueInput | ActionsWhereUniqueInput[]
  }

  export type AutomationInstanceCreateNestedManyWithoutAutomationsInput = {
    create?: XOR<AutomationInstanceCreateWithoutAutomationsInput, AutomationInstanceUncheckedCreateWithoutAutomationsInput> | AutomationInstanceCreateWithoutAutomationsInput[] | AutomationInstanceUncheckedCreateWithoutAutomationsInput[]
    connectOrCreate?: AutomationInstanceCreateOrConnectWithoutAutomationsInput | AutomationInstanceCreateOrConnectWithoutAutomationsInput[]
    createMany?: AutomationInstanceCreateManyAutomationsInputEnvelope
    connect?: AutomationInstanceWhereUniqueInput | AutomationInstanceWhereUniqueInput[]
  }

  export type ActionsUncheckedCreateNestedManyWithoutAutomationsInput = {
    create?: XOR<ActionsCreateWithoutAutomationsInput, ActionsUncheckedCreateWithoutAutomationsInput> | ActionsCreateWithoutAutomationsInput[] | ActionsUncheckedCreateWithoutAutomationsInput[]
    connectOrCreate?: ActionsCreateOrConnectWithoutAutomationsInput | ActionsCreateOrConnectWithoutAutomationsInput[]
    createMany?: ActionsCreateManyAutomationsInputEnvelope
    connect?: ActionsWhereUniqueInput | ActionsWhereUniqueInput[]
  }

  export type AutomationInstanceUncheckedCreateNestedManyWithoutAutomationsInput = {
    create?: XOR<AutomationInstanceCreateWithoutAutomationsInput, AutomationInstanceUncheckedCreateWithoutAutomationsInput> | AutomationInstanceCreateWithoutAutomationsInput[] | AutomationInstanceUncheckedCreateWithoutAutomationsInput[]
    connectOrCreate?: AutomationInstanceCreateOrConnectWithoutAutomationsInput | AutomationInstanceCreateOrConnectWithoutAutomationsInput[]
    createMany?: AutomationInstanceCreateManyAutomationsInputEnvelope
    connect?: AutomationInstanceWhereUniqueInput | AutomationInstanceWhereUniqueInput[]
  }

  export type TriggersUpdateOneWithoutAutomationsNestedInput = {
    create?: XOR<TriggersCreateWithoutAutomationsInput, TriggersUncheckedCreateWithoutAutomationsInput>
    connectOrCreate?: TriggersCreateOrConnectWithoutAutomationsInput
    upsert?: TriggersUpsertWithoutAutomationsInput
    disconnect?: TriggersWhereInput | boolean
    delete?: TriggersWhereInput | boolean
    connect?: TriggersWhereUniqueInput
    update?: XOR<XOR<TriggersUpdateToOneWithWhereWithoutAutomationsInput, TriggersUpdateWithoutAutomationsInput>, TriggersUncheckedUpdateWithoutAutomationsInput>
  }

  export type SubAccountsUpdateOneRequiredWithoutAutomationNestedInput = {
    create?: XOR<SubAccountsCreateWithoutAutomationInput, SubAccountsUncheckedCreateWithoutAutomationInput>
    connectOrCreate?: SubAccountsCreateOrConnectWithoutAutomationInput
    upsert?: SubAccountsUpsertWithoutAutomationInput
    connect?: SubAccountsWhereUniqueInput
    update?: XOR<XOR<SubAccountsUpdateToOneWithWhereWithoutAutomationInput, SubAccountsUpdateWithoutAutomationInput>, SubAccountsUncheckedUpdateWithoutAutomationInput>
  }

  export type ActionsUpdateManyWithoutAutomationsNestedInput = {
    create?: XOR<ActionsCreateWithoutAutomationsInput, ActionsUncheckedCreateWithoutAutomationsInput> | ActionsCreateWithoutAutomationsInput[] | ActionsUncheckedCreateWithoutAutomationsInput[]
    connectOrCreate?: ActionsCreateOrConnectWithoutAutomationsInput | ActionsCreateOrConnectWithoutAutomationsInput[]
    upsert?: ActionsUpsertWithWhereUniqueWithoutAutomationsInput | ActionsUpsertWithWhereUniqueWithoutAutomationsInput[]
    createMany?: ActionsCreateManyAutomationsInputEnvelope
    set?: ActionsWhereUniqueInput | ActionsWhereUniqueInput[]
    disconnect?: ActionsWhereUniqueInput | ActionsWhereUniqueInput[]
    delete?: ActionsWhereUniqueInput | ActionsWhereUniqueInput[]
    connect?: ActionsWhereUniqueInput | ActionsWhereUniqueInput[]
    update?: ActionsUpdateWithWhereUniqueWithoutAutomationsInput | ActionsUpdateWithWhereUniqueWithoutAutomationsInput[]
    updateMany?: ActionsUpdateManyWithWhereWithoutAutomationsInput | ActionsUpdateManyWithWhereWithoutAutomationsInput[]
    deleteMany?: ActionsScalarWhereInput | ActionsScalarWhereInput[]
  }

  export type AutomationInstanceUpdateManyWithoutAutomationsNestedInput = {
    create?: XOR<AutomationInstanceCreateWithoutAutomationsInput, AutomationInstanceUncheckedCreateWithoutAutomationsInput> | AutomationInstanceCreateWithoutAutomationsInput[] | AutomationInstanceUncheckedCreateWithoutAutomationsInput[]
    connectOrCreate?: AutomationInstanceCreateOrConnectWithoutAutomationsInput | AutomationInstanceCreateOrConnectWithoutAutomationsInput[]
    upsert?: AutomationInstanceUpsertWithWhereUniqueWithoutAutomationsInput | AutomationInstanceUpsertWithWhereUniqueWithoutAutomationsInput[]
    createMany?: AutomationInstanceCreateManyAutomationsInputEnvelope
    set?: AutomationInstanceWhereUniqueInput | AutomationInstanceWhereUniqueInput[]
    disconnect?: AutomationInstanceWhereUniqueInput | AutomationInstanceWhereUniqueInput[]
    delete?: AutomationInstanceWhereUniqueInput | AutomationInstanceWhereUniqueInput[]
    connect?: AutomationInstanceWhereUniqueInput | AutomationInstanceWhereUniqueInput[]
    update?: AutomationInstanceUpdateWithWhereUniqueWithoutAutomationsInput | AutomationInstanceUpdateWithWhereUniqueWithoutAutomationsInput[]
    updateMany?: AutomationInstanceUpdateManyWithWhereWithoutAutomationsInput | AutomationInstanceUpdateManyWithWhereWithoutAutomationsInput[]
    deleteMany?: AutomationInstanceScalarWhereInput | AutomationInstanceScalarWhereInput[]
  }

  export type ActionsUncheckedUpdateManyWithoutAutomationsNestedInput = {
    create?: XOR<ActionsCreateWithoutAutomationsInput, ActionsUncheckedCreateWithoutAutomationsInput> | ActionsCreateWithoutAutomationsInput[] | ActionsUncheckedCreateWithoutAutomationsInput[]
    connectOrCreate?: ActionsCreateOrConnectWithoutAutomationsInput | ActionsCreateOrConnectWithoutAutomationsInput[]
    upsert?: ActionsUpsertWithWhereUniqueWithoutAutomationsInput | ActionsUpsertWithWhereUniqueWithoutAutomationsInput[]
    createMany?: ActionsCreateManyAutomationsInputEnvelope
    set?: ActionsWhereUniqueInput | ActionsWhereUniqueInput[]
    disconnect?: ActionsWhereUniqueInput | ActionsWhereUniqueInput[]
    delete?: ActionsWhereUniqueInput | ActionsWhereUniqueInput[]
    connect?: ActionsWhereUniqueInput | ActionsWhereUniqueInput[]
    update?: ActionsUpdateWithWhereUniqueWithoutAutomationsInput | ActionsUpdateWithWhereUniqueWithoutAutomationsInput[]
    updateMany?: ActionsUpdateManyWithWhereWithoutAutomationsInput | ActionsUpdateManyWithWhereWithoutAutomationsInput[]
    deleteMany?: ActionsScalarWhereInput | ActionsScalarWhereInput[]
  }

  export type AutomationInstanceUncheckedUpdateManyWithoutAutomationsNestedInput = {
    create?: XOR<AutomationInstanceCreateWithoutAutomationsInput, AutomationInstanceUncheckedCreateWithoutAutomationsInput> | AutomationInstanceCreateWithoutAutomationsInput[] | AutomationInstanceUncheckedCreateWithoutAutomationsInput[]
    connectOrCreate?: AutomationInstanceCreateOrConnectWithoutAutomationsInput | AutomationInstanceCreateOrConnectWithoutAutomationsInput[]
    upsert?: AutomationInstanceUpsertWithWhereUniqueWithoutAutomationsInput | AutomationInstanceUpsertWithWhereUniqueWithoutAutomationsInput[]
    createMany?: AutomationInstanceCreateManyAutomationsInputEnvelope
    set?: AutomationInstanceWhereUniqueInput | AutomationInstanceWhereUniqueInput[]
    disconnect?: AutomationInstanceWhereUniqueInput | AutomationInstanceWhereUniqueInput[]
    delete?: AutomationInstanceWhereUniqueInput | AutomationInstanceWhereUniqueInput[]
    connect?: AutomationInstanceWhereUniqueInput | AutomationInstanceWhereUniqueInput[]
    update?: AutomationInstanceUpdateWithWhereUniqueWithoutAutomationsInput | AutomationInstanceUpdateWithWhereUniqueWithoutAutomationsInput[]
    updateMany?: AutomationInstanceUpdateManyWithWhereWithoutAutomationsInput | AutomationInstanceUpdateManyWithWhereWithoutAutomationsInput[]
    deleteMany?: AutomationInstanceScalarWhereInput | AutomationInstanceScalarWhereInput[]
  }

  export type AutomationsCreateNestedOneWithoutAutomationInstanceInput = {
    create?: XOR<AutomationsCreateWithoutAutomationInstanceInput, AutomationsUncheckedCreateWithoutAutomationInstanceInput>
    connectOrCreate?: AutomationsCreateOrConnectWithoutAutomationInstanceInput
    connect?: AutomationsWhereUniqueInput
  }

  export type AutomationsUpdateOneRequiredWithoutAutomationInstanceNestedInput = {
    create?: XOR<AutomationsCreateWithoutAutomationInstanceInput, AutomationsUncheckedCreateWithoutAutomationInstanceInput>
    connectOrCreate?: AutomationsCreateOrConnectWithoutAutomationInstanceInput
    upsert?: AutomationsUpsertWithoutAutomationInstanceInput
    connect?: AutomationsWhereUniqueInput
    update?: XOR<XOR<AutomationsUpdateToOneWithWhereWithoutAutomationInstanceInput, AutomationsUpdateWithoutAutomationInstanceInput>, AutomationsUncheckedUpdateWithoutAutomationInstanceInput>
  }

  export type AutomationsCreateNestedOneWithoutActionsInput = {
    create?: XOR<AutomationsCreateWithoutActionsInput, AutomationsUncheckedCreateWithoutActionsInput>
    connectOrCreate?: AutomationsCreateOrConnectWithoutActionsInput
    connect?: AutomationsWhereUniqueInput
  }

  export type EnumActionTypeFieldUpdateOperationsInput = {
    set?: $Enums.ActionType
  }

  export type AutomationsUpdateOneRequiredWithoutActionsNestedInput = {
    create?: XOR<AutomationsCreateWithoutActionsInput, AutomationsUncheckedCreateWithoutActionsInput>
    connectOrCreate?: AutomationsCreateOrConnectWithoutActionsInput
    upsert?: AutomationsUpsertWithoutActionsInput
    connect?: AutomationsWhereUniqueInput
    update?: XOR<XOR<AutomationsUpdateToOneWithWhereWithoutActionsInput, AutomationsUpdateWithoutActionsInput>, AutomationsUncheckedUpdateWithoutActionsInput>
  }

  export type SubAccountsCreateNestedOneWithoutContactInput = {
    create?: XOR<SubAccountsCreateWithoutContactInput, SubAccountsUncheckedCreateWithoutContactInput>
    connectOrCreate?: SubAccountsCreateOrConnectWithoutContactInput
    connect?: SubAccountsWhereUniqueInput
  }

  export type TicketsCreateNestedManyWithoutContactsInput = {
    create?: XOR<TicketsCreateWithoutContactsInput, TicketsUncheckedCreateWithoutContactsInput> | TicketsCreateWithoutContactsInput[] | TicketsUncheckedCreateWithoutContactsInput[]
    connectOrCreate?: TicketsCreateOrConnectWithoutContactsInput | TicketsCreateOrConnectWithoutContactsInput[]
    createMany?: TicketsCreateManyContactsInputEnvelope
    connect?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
  }

  export type TicketsUncheckedCreateNestedManyWithoutContactsInput = {
    create?: XOR<TicketsCreateWithoutContactsInput, TicketsUncheckedCreateWithoutContactsInput> | TicketsCreateWithoutContactsInput[] | TicketsUncheckedCreateWithoutContactsInput[]
    connectOrCreate?: TicketsCreateOrConnectWithoutContactsInput | TicketsCreateOrConnectWithoutContactsInput[]
    createMany?: TicketsCreateManyContactsInputEnvelope
    connect?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
  }

  export type SubAccountsUpdateOneRequiredWithoutContactNestedInput = {
    create?: XOR<SubAccountsCreateWithoutContactInput, SubAccountsUncheckedCreateWithoutContactInput>
    connectOrCreate?: SubAccountsCreateOrConnectWithoutContactInput
    upsert?: SubAccountsUpsertWithoutContactInput
    connect?: SubAccountsWhereUniqueInput
    update?: XOR<XOR<SubAccountsUpdateToOneWithWhereWithoutContactInput, SubAccountsUpdateWithoutContactInput>, SubAccountsUncheckedUpdateWithoutContactInput>
  }

  export type TicketsUpdateManyWithoutContactsNestedInput = {
    create?: XOR<TicketsCreateWithoutContactsInput, TicketsUncheckedCreateWithoutContactsInput> | TicketsCreateWithoutContactsInput[] | TicketsUncheckedCreateWithoutContactsInput[]
    connectOrCreate?: TicketsCreateOrConnectWithoutContactsInput | TicketsCreateOrConnectWithoutContactsInput[]
    upsert?: TicketsUpsertWithWhereUniqueWithoutContactsInput | TicketsUpsertWithWhereUniqueWithoutContactsInput[]
    createMany?: TicketsCreateManyContactsInputEnvelope
    set?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
    disconnect?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
    delete?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
    connect?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
    update?: TicketsUpdateWithWhereUniqueWithoutContactsInput | TicketsUpdateWithWhereUniqueWithoutContactsInput[]
    updateMany?: TicketsUpdateManyWithWhereWithoutContactsInput | TicketsUpdateManyWithWhereWithoutContactsInput[]
    deleteMany?: TicketsScalarWhereInput | TicketsScalarWhereInput[]
  }

  export type TicketsUncheckedUpdateManyWithoutContactsNestedInput = {
    create?: XOR<TicketsCreateWithoutContactsInput, TicketsUncheckedCreateWithoutContactsInput> | TicketsCreateWithoutContactsInput[] | TicketsUncheckedCreateWithoutContactsInput[]
    connectOrCreate?: TicketsCreateOrConnectWithoutContactsInput | TicketsCreateOrConnectWithoutContactsInput[]
    upsert?: TicketsUpsertWithWhereUniqueWithoutContactsInput | TicketsUpsertWithWhereUniqueWithoutContactsInput[]
    createMany?: TicketsCreateManyContactsInputEnvelope
    set?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
    disconnect?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
    delete?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
    connect?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
    update?: TicketsUpdateWithWhereUniqueWithoutContactsInput | TicketsUpdateWithWhereUniqueWithoutContactsInput[]
    updateMany?: TicketsUpdateManyWithWhereWithoutContactsInput | TicketsUpdateManyWithWhereWithoutContactsInput[]
    deleteMany?: TicketsScalarWhereInput | TicketsScalarWhereInput[]
  }

  export type SubAccountsCreateNestedOneWithoutMediaInput = {
    create?: XOR<SubAccountsCreateWithoutMediaInput, SubAccountsUncheckedCreateWithoutMediaInput>
    connectOrCreate?: SubAccountsCreateOrConnectWithoutMediaInput
    connect?: SubAccountsWhereUniqueInput
  }

  export type SubAccountsUpdateOneRequiredWithoutMediaNestedInput = {
    create?: XOR<SubAccountsCreateWithoutMediaInput, SubAccountsUncheckedCreateWithoutMediaInput>
    connectOrCreate?: SubAccountsCreateOrConnectWithoutMediaInput
    upsert?: SubAccountsUpsertWithoutMediaInput
    connect?: SubAccountsWhereUniqueInput
    update?: XOR<XOR<SubAccountsUpdateToOneWithWhereWithoutMediaInput, SubAccountsUpdateWithoutMediaInput>, SubAccountsUncheckedUpdateWithoutMediaInput>
  }

  export type PipelinesCreateNestedOneWithoutLaneInput = {
    create?: XOR<PipelinesCreateWithoutLaneInput, PipelinesUncheckedCreateWithoutLaneInput>
    connectOrCreate?: PipelinesCreateOrConnectWithoutLaneInput
    connect?: PipelinesWhereUniqueInput
  }

  export type TicketsCreateNestedManyWithoutLaneInput = {
    create?: XOR<TicketsCreateWithoutLaneInput, TicketsUncheckedCreateWithoutLaneInput> | TicketsCreateWithoutLaneInput[] | TicketsUncheckedCreateWithoutLaneInput[]
    connectOrCreate?: TicketsCreateOrConnectWithoutLaneInput | TicketsCreateOrConnectWithoutLaneInput[]
    createMany?: TicketsCreateManyLaneInputEnvelope
    connect?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
  }

  export type TicketsUncheckedCreateNestedManyWithoutLaneInput = {
    create?: XOR<TicketsCreateWithoutLaneInput, TicketsUncheckedCreateWithoutLaneInput> | TicketsCreateWithoutLaneInput[] | TicketsUncheckedCreateWithoutLaneInput[]
    connectOrCreate?: TicketsCreateOrConnectWithoutLaneInput | TicketsCreateOrConnectWithoutLaneInput[]
    createMany?: TicketsCreateManyLaneInputEnvelope
    connect?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
  }

  export type PipelinesUpdateOneRequiredWithoutLaneNestedInput = {
    create?: XOR<PipelinesCreateWithoutLaneInput, PipelinesUncheckedCreateWithoutLaneInput>
    connectOrCreate?: PipelinesCreateOrConnectWithoutLaneInput
    upsert?: PipelinesUpsertWithoutLaneInput
    connect?: PipelinesWhereUniqueInput
    update?: XOR<XOR<PipelinesUpdateToOneWithWhereWithoutLaneInput, PipelinesUpdateWithoutLaneInput>, PipelinesUncheckedUpdateWithoutLaneInput>
  }

  export type TicketsUpdateManyWithoutLaneNestedInput = {
    create?: XOR<TicketsCreateWithoutLaneInput, TicketsUncheckedCreateWithoutLaneInput> | TicketsCreateWithoutLaneInput[] | TicketsUncheckedCreateWithoutLaneInput[]
    connectOrCreate?: TicketsCreateOrConnectWithoutLaneInput | TicketsCreateOrConnectWithoutLaneInput[]
    upsert?: TicketsUpsertWithWhereUniqueWithoutLaneInput | TicketsUpsertWithWhereUniqueWithoutLaneInput[]
    createMany?: TicketsCreateManyLaneInputEnvelope
    set?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
    disconnect?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
    delete?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
    connect?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
    update?: TicketsUpdateWithWhereUniqueWithoutLaneInput | TicketsUpdateWithWhereUniqueWithoutLaneInput[]
    updateMany?: TicketsUpdateManyWithWhereWithoutLaneInput | TicketsUpdateManyWithWhereWithoutLaneInput[]
    deleteMany?: TicketsScalarWhereInput | TicketsScalarWhereInput[]
  }

  export type TicketsUncheckedUpdateManyWithoutLaneNestedInput = {
    create?: XOR<TicketsCreateWithoutLaneInput, TicketsUncheckedCreateWithoutLaneInput> | TicketsCreateWithoutLaneInput[] | TicketsUncheckedCreateWithoutLaneInput[]
    connectOrCreate?: TicketsCreateOrConnectWithoutLaneInput | TicketsCreateOrConnectWithoutLaneInput[]
    upsert?: TicketsUpsertWithWhereUniqueWithoutLaneInput | TicketsUpsertWithWhereUniqueWithoutLaneInput[]
    createMany?: TicketsCreateManyLaneInputEnvelope
    set?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
    disconnect?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
    delete?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
    connect?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
    update?: TicketsUpdateWithWhereUniqueWithoutLaneInput | TicketsUpdateWithWhereUniqueWithoutLaneInput[]
    updateMany?: TicketsUpdateManyWithWhereWithoutLaneInput | TicketsUpdateManyWithWhereWithoutLaneInput[]
    deleteMany?: TicketsScalarWhereInput | TicketsScalarWhereInput[]
  }

  export type LaneCreateNestedOneWithoutTicketsInput = {
    create?: XOR<LaneCreateWithoutTicketsInput, LaneUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: LaneCreateOrConnectWithoutTicketsInput
    connect?: LaneWhereUniqueInput
  }

  export type TagsCreateNestedManyWithoutTicketsInput = {
    create?: XOR<TagsCreateWithoutTicketsInput, TagsUncheckedCreateWithoutTicketsInput> | TagsCreateWithoutTicketsInput[] | TagsUncheckedCreateWithoutTicketsInput[]
    connectOrCreate?: TagsCreateOrConnectWithoutTicketsInput | TagsCreateOrConnectWithoutTicketsInput[]
    connect?: TagsWhereUniqueInput | TagsWhereUniqueInput[]
  }

  export type UsersCreateNestedOneWithoutTicketInput = {
    create?: XOR<UsersCreateWithoutTicketInput, UsersUncheckedCreateWithoutTicketInput>
    connectOrCreate?: UsersCreateOrConnectWithoutTicketInput
    connect?: UsersWhereUniqueInput
  }

  export type ContactsCreateNestedOneWithoutTicketsInput = {
    create?: XOR<ContactsCreateWithoutTicketsInput, ContactsUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: ContactsCreateOrConnectWithoutTicketsInput
    connect?: ContactsWhereUniqueInput
  }

  export type TagsUncheckedCreateNestedManyWithoutTicketsInput = {
    create?: XOR<TagsCreateWithoutTicketsInput, TagsUncheckedCreateWithoutTicketsInput> | TagsCreateWithoutTicketsInput[] | TagsUncheckedCreateWithoutTicketsInput[]
    connectOrCreate?: TagsCreateOrConnectWithoutTicketsInput | TagsCreateOrConnectWithoutTicketsInput[]
    connect?: TagsWhereUniqueInput | TagsWhereUniqueInput[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type LaneUpdateOneRequiredWithoutTicketsNestedInput = {
    create?: XOR<LaneCreateWithoutTicketsInput, LaneUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: LaneCreateOrConnectWithoutTicketsInput
    upsert?: LaneUpsertWithoutTicketsInput
    connect?: LaneWhereUniqueInput
    update?: XOR<XOR<LaneUpdateToOneWithWhereWithoutTicketsInput, LaneUpdateWithoutTicketsInput>, LaneUncheckedUpdateWithoutTicketsInput>
  }

  export type TagsUpdateManyWithoutTicketsNestedInput = {
    create?: XOR<TagsCreateWithoutTicketsInput, TagsUncheckedCreateWithoutTicketsInput> | TagsCreateWithoutTicketsInput[] | TagsUncheckedCreateWithoutTicketsInput[]
    connectOrCreate?: TagsCreateOrConnectWithoutTicketsInput | TagsCreateOrConnectWithoutTicketsInput[]
    upsert?: TagsUpsertWithWhereUniqueWithoutTicketsInput | TagsUpsertWithWhereUniqueWithoutTicketsInput[]
    set?: TagsWhereUniqueInput | TagsWhereUniqueInput[]
    disconnect?: TagsWhereUniqueInput | TagsWhereUniqueInput[]
    delete?: TagsWhereUniqueInput | TagsWhereUniqueInput[]
    connect?: TagsWhereUniqueInput | TagsWhereUniqueInput[]
    update?: TagsUpdateWithWhereUniqueWithoutTicketsInput | TagsUpdateWithWhereUniqueWithoutTicketsInput[]
    updateMany?: TagsUpdateManyWithWhereWithoutTicketsInput | TagsUpdateManyWithWhereWithoutTicketsInput[]
    deleteMany?: TagsScalarWhereInput | TagsScalarWhereInput[]
  }

  export type UsersUpdateOneWithoutTicketNestedInput = {
    create?: XOR<UsersCreateWithoutTicketInput, UsersUncheckedCreateWithoutTicketInput>
    connectOrCreate?: UsersCreateOrConnectWithoutTicketInput
    upsert?: UsersUpsertWithoutTicketInput
    disconnect?: UsersWhereInput | boolean
    delete?: UsersWhereInput | boolean
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutTicketInput, UsersUpdateWithoutTicketInput>, UsersUncheckedUpdateWithoutTicketInput>
  }

  export type ContactsUpdateOneWithoutTicketsNestedInput = {
    create?: XOR<ContactsCreateWithoutTicketsInput, ContactsUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: ContactsCreateOrConnectWithoutTicketsInput
    upsert?: ContactsUpsertWithoutTicketsInput
    disconnect?: ContactsWhereInput | boolean
    delete?: ContactsWhereInput | boolean
    connect?: ContactsWhereUniqueInput
    update?: XOR<XOR<ContactsUpdateToOneWithWhereWithoutTicketsInput, ContactsUpdateWithoutTicketsInput>, ContactsUncheckedUpdateWithoutTicketsInput>
  }

  export type TagsUncheckedUpdateManyWithoutTicketsNestedInput = {
    create?: XOR<TagsCreateWithoutTicketsInput, TagsUncheckedCreateWithoutTicketsInput> | TagsCreateWithoutTicketsInput[] | TagsUncheckedCreateWithoutTicketsInput[]
    connectOrCreate?: TagsCreateOrConnectWithoutTicketsInput | TagsCreateOrConnectWithoutTicketsInput[]
    upsert?: TagsUpsertWithWhereUniqueWithoutTicketsInput | TagsUpsertWithWhereUniqueWithoutTicketsInput[]
    set?: TagsWhereUniqueInput | TagsWhereUniqueInput[]
    disconnect?: TagsWhereUniqueInput | TagsWhereUniqueInput[]
    delete?: TagsWhereUniqueInput | TagsWhereUniqueInput[]
    connect?: TagsWhereUniqueInput | TagsWhereUniqueInput[]
    update?: TagsUpdateWithWhereUniqueWithoutTicketsInput | TagsUpdateWithWhereUniqueWithoutTicketsInput[]
    updateMany?: TagsUpdateManyWithWhereWithoutTicketsInput | TagsUpdateManyWithWhereWithoutTicketsInput[]
    deleteMany?: TagsScalarWhereInput | TagsScalarWhereInput[]
  }

  export type SubAccountsCreateNestedOneWithoutTagsInput = {
    create?: XOR<SubAccountsCreateWithoutTagsInput, SubAccountsUncheckedCreateWithoutTagsInput>
    connectOrCreate?: SubAccountsCreateOrConnectWithoutTagsInput
    connect?: SubAccountsWhereUniqueInput
  }

  export type TicketsCreateNestedManyWithoutTagsInput = {
    create?: XOR<TicketsCreateWithoutTagsInput, TicketsUncheckedCreateWithoutTagsInput> | TicketsCreateWithoutTagsInput[] | TicketsUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: TicketsCreateOrConnectWithoutTagsInput | TicketsCreateOrConnectWithoutTagsInput[]
    connect?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
  }

  export type TicketsUncheckedCreateNestedManyWithoutTagsInput = {
    create?: XOR<TicketsCreateWithoutTagsInput, TicketsUncheckedCreateWithoutTagsInput> | TicketsCreateWithoutTagsInput[] | TicketsUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: TicketsCreateOrConnectWithoutTagsInput | TicketsCreateOrConnectWithoutTagsInput[]
    connect?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
  }

  export type SubAccountsUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<SubAccountsCreateWithoutTagsInput, SubAccountsUncheckedCreateWithoutTagsInput>
    connectOrCreate?: SubAccountsCreateOrConnectWithoutTagsInput
    upsert?: SubAccountsUpsertWithoutTagsInput
    connect?: SubAccountsWhereUniqueInput
    update?: XOR<XOR<SubAccountsUpdateToOneWithWhereWithoutTagsInput, SubAccountsUpdateWithoutTagsInput>, SubAccountsUncheckedUpdateWithoutTagsInput>
  }

  export type TicketsUpdateManyWithoutTagsNestedInput = {
    create?: XOR<TicketsCreateWithoutTagsInput, TicketsUncheckedCreateWithoutTagsInput> | TicketsCreateWithoutTagsInput[] | TicketsUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: TicketsCreateOrConnectWithoutTagsInput | TicketsCreateOrConnectWithoutTagsInput[]
    upsert?: TicketsUpsertWithWhereUniqueWithoutTagsInput | TicketsUpsertWithWhereUniqueWithoutTagsInput[]
    set?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
    disconnect?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
    delete?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
    connect?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
    update?: TicketsUpdateWithWhereUniqueWithoutTagsInput | TicketsUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: TicketsUpdateManyWithWhereWithoutTagsInput | TicketsUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: TicketsScalarWhereInput | TicketsScalarWhereInput[]
  }

  export type TicketsUncheckedUpdateManyWithoutTagsNestedInput = {
    create?: XOR<TicketsCreateWithoutTagsInput, TicketsUncheckedCreateWithoutTagsInput> | TicketsCreateWithoutTagsInput[] | TicketsUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: TicketsCreateOrConnectWithoutTagsInput | TicketsCreateOrConnectWithoutTagsInput[]
    upsert?: TicketsUpsertWithWhereUniqueWithoutTagsInput | TicketsUpsertWithWhereUniqueWithoutTagsInput[]
    set?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
    disconnect?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
    delete?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
    connect?: TicketsWhereUniqueInput | TicketsWhereUniqueInput[]
    update?: TicketsUpdateWithWhereUniqueWithoutTagsInput | TicketsUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: TicketsUpdateManyWithWhereWithoutTagsInput | TicketsUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: TicketsScalarWhereInput | TicketsScalarWhereInput[]
  }

  export type SubAccountsCreateNestedOneWithoutSubAccountSidebarOptionInput = {
    create?: XOR<SubAccountsCreateWithoutSubAccountSidebarOptionInput, SubAccountsUncheckedCreateWithoutSubAccountSidebarOptionInput>
    connectOrCreate?: SubAccountsCreateOrConnectWithoutSubAccountSidebarOptionInput
    connect?: SubAccountsWhereUniqueInput
  }

  export type SubAccountsUpdateOneWithoutSubAccountSidebarOptionNestedInput = {
    create?: XOR<SubAccountsCreateWithoutSubAccountSidebarOptionInput, SubAccountsUncheckedCreateWithoutSubAccountSidebarOptionInput>
    connectOrCreate?: SubAccountsCreateOrConnectWithoutSubAccountSidebarOptionInput
    upsert?: SubAccountsUpsertWithoutSubAccountSidebarOptionInput
    disconnect?: SubAccountsWhereInput | boolean
    delete?: SubAccountsWhereInput | boolean
    connect?: SubAccountsWhereUniqueInput
    update?: XOR<XOR<SubAccountsUpdateToOneWithWhereWithoutSubAccountSidebarOptionInput, SubAccountsUpdateWithoutSubAccountSidebarOptionInput>, SubAccountsUncheckedUpdateWithoutSubAccountSidebarOptionInput>
  }

  export type AgencyCreateNestedOneWithoutInvitationInput = {
    create?: XOR<AgencyCreateWithoutInvitationInput, AgencyUncheckedCreateWithoutInvitationInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutInvitationInput
    connect?: AgencyWhereUniqueInput
  }

  export type EnumInvitationStatusFieldUpdateOperationsInput = {
    set?: $Enums.InvitationStatus
  }

  export type AgencyUpdateOneRequiredWithoutInvitationNestedInput = {
    create?: XOR<AgencyCreateWithoutInvitationInput, AgencyUncheckedCreateWithoutInvitationInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutInvitationInput
    upsert?: AgencyUpsertWithoutInvitationInput
    connect?: AgencyWhereUniqueInput
    update?: XOR<XOR<AgencyUpdateToOneWithWhereWithoutInvitationInput, AgencyUpdateWithoutInvitationInput>, AgencyUncheckedUpdateWithoutInvitationInput>
  }

  export type SubAccountsCreateNestedOneWithoutFunnelsInput = {
    create?: XOR<SubAccountsCreateWithoutFunnelsInput, SubAccountsUncheckedCreateWithoutFunnelsInput>
    connectOrCreate?: SubAccountsCreateOrConnectWithoutFunnelsInput
    connect?: SubAccountsWhereUniqueInput
  }

  export type FunelPagesCreateNestedManyWithoutFunnelInput = {
    create?: XOR<FunelPagesCreateWithoutFunnelInput, FunelPagesUncheckedCreateWithoutFunnelInput> | FunelPagesCreateWithoutFunnelInput[] | FunelPagesUncheckedCreateWithoutFunnelInput[]
    connectOrCreate?: FunelPagesCreateOrConnectWithoutFunnelInput | FunelPagesCreateOrConnectWithoutFunnelInput[]
    createMany?: FunelPagesCreateManyFunnelInputEnvelope
    connect?: FunelPagesWhereUniqueInput | FunelPagesWhereUniqueInput[]
  }

  export type ClassNameCreateNestedManyWithoutFunnelInput = {
    create?: XOR<ClassNameCreateWithoutFunnelInput, ClassNameUncheckedCreateWithoutFunnelInput> | ClassNameCreateWithoutFunnelInput[] | ClassNameUncheckedCreateWithoutFunnelInput[]
    connectOrCreate?: ClassNameCreateOrConnectWithoutFunnelInput | ClassNameCreateOrConnectWithoutFunnelInput[]
    createMany?: ClassNameCreateManyFunnelInputEnvelope
    connect?: ClassNameWhereUniqueInput | ClassNameWhereUniqueInput[]
  }

  export type FunelPagesUncheckedCreateNestedManyWithoutFunnelInput = {
    create?: XOR<FunelPagesCreateWithoutFunnelInput, FunelPagesUncheckedCreateWithoutFunnelInput> | FunelPagesCreateWithoutFunnelInput[] | FunelPagesUncheckedCreateWithoutFunnelInput[]
    connectOrCreate?: FunelPagesCreateOrConnectWithoutFunnelInput | FunelPagesCreateOrConnectWithoutFunnelInput[]
    createMany?: FunelPagesCreateManyFunnelInputEnvelope
    connect?: FunelPagesWhereUniqueInput | FunelPagesWhereUniqueInput[]
  }

  export type ClassNameUncheckedCreateNestedManyWithoutFunnelInput = {
    create?: XOR<ClassNameCreateWithoutFunnelInput, ClassNameUncheckedCreateWithoutFunnelInput> | ClassNameCreateWithoutFunnelInput[] | ClassNameUncheckedCreateWithoutFunnelInput[]
    connectOrCreate?: ClassNameCreateOrConnectWithoutFunnelInput | ClassNameCreateOrConnectWithoutFunnelInput[]
    createMany?: ClassNameCreateManyFunnelInputEnvelope
    connect?: ClassNameWhereUniqueInput | ClassNameWhereUniqueInput[]
  }

  export type SubAccountsUpdateOneRequiredWithoutFunnelsNestedInput = {
    create?: XOR<SubAccountsCreateWithoutFunnelsInput, SubAccountsUncheckedCreateWithoutFunnelsInput>
    connectOrCreate?: SubAccountsCreateOrConnectWithoutFunnelsInput
    upsert?: SubAccountsUpsertWithoutFunnelsInput
    connect?: SubAccountsWhereUniqueInput
    update?: XOR<XOR<SubAccountsUpdateToOneWithWhereWithoutFunnelsInput, SubAccountsUpdateWithoutFunnelsInput>, SubAccountsUncheckedUpdateWithoutFunnelsInput>
  }

  export type FunelPagesUpdateManyWithoutFunnelNestedInput = {
    create?: XOR<FunelPagesCreateWithoutFunnelInput, FunelPagesUncheckedCreateWithoutFunnelInput> | FunelPagesCreateWithoutFunnelInput[] | FunelPagesUncheckedCreateWithoutFunnelInput[]
    connectOrCreate?: FunelPagesCreateOrConnectWithoutFunnelInput | FunelPagesCreateOrConnectWithoutFunnelInput[]
    upsert?: FunelPagesUpsertWithWhereUniqueWithoutFunnelInput | FunelPagesUpsertWithWhereUniqueWithoutFunnelInput[]
    createMany?: FunelPagesCreateManyFunnelInputEnvelope
    set?: FunelPagesWhereUniqueInput | FunelPagesWhereUniqueInput[]
    disconnect?: FunelPagesWhereUniqueInput | FunelPagesWhereUniqueInput[]
    delete?: FunelPagesWhereUniqueInput | FunelPagesWhereUniqueInput[]
    connect?: FunelPagesWhereUniqueInput | FunelPagesWhereUniqueInput[]
    update?: FunelPagesUpdateWithWhereUniqueWithoutFunnelInput | FunelPagesUpdateWithWhereUniqueWithoutFunnelInput[]
    updateMany?: FunelPagesUpdateManyWithWhereWithoutFunnelInput | FunelPagesUpdateManyWithWhereWithoutFunnelInput[]
    deleteMany?: FunelPagesScalarWhereInput | FunelPagesScalarWhereInput[]
  }

  export type ClassNameUpdateManyWithoutFunnelNestedInput = {
    create?: XOR<ClassNameCreateWithoutFunnelInput, ClassNameUncheckedCreateWithoutFunnelInput> | ClassNameCreateWithoutFunnelInput[] | ClassNameUncheckedCreateWithoutFunnelInput[]
    connectOrCreate?: ClassNameCreateOrConnectWithoutFunnelInput | ClassNameCreateOrConnectWithoutFunnelInput[]
    upsert?: ClassNameUpsertWithWhereUniqueWithoutFunnelInput | ClassNameUpsertWithWhereUniqueWithoutFunnelInput[]
    createMany?: ClassNameCreateManyFunnelInputEnvelope
    set?: ClassNameWhereUniqueInput | ClassNameWhereUniqueInput[]
    disconnect?: ClassNameWhereUniqueInput | ClassNameWhereUniqueInput[]
    delete?: ClassNameWhereUniqueInput | ClassNameWhereUniqueInput[]
    connect?: ClassNameWhereUniqueInput | ClassNameWhereUniqueInput[]
    update?: ClassNameUpdateWithWhereUniqueWithoutFunnelInput | ClassNameUpdateWithWhereUniqueWithoutFunnelInput[]
    updateMany?: ClassNameUpdateManyWithWhereWithoutFunnelInput | ClassNameUpdateManyWithWhereWithoutFunnelInput[]
    deleteMany?: ClassNameScalarWhereInput | ClassNameScalarWhereInput[]
  }

  export type FunelPagesUncheckedUpdateManyWithoutFunnelNestedInput = {
    create?: XOR<FunelPagesCreateWithoutFunnelInput, FunelPagesUncheckedCreateWithoutFunnelInput> | FunelPagesCreateWithoutFunnelInput[] | FunelPagesUncheckedCreateWithoutFunnelInput[]
    connectOrCreate?: FunelPagesCreateOrConnectWithoutFunnelInput | FunelPagesCreateOrConnectWithoutFunnelInput[]
    upsert?: FunelPagesUpsertWithWhereUniqueWithoutFunnelInput | FunelPagesUpsertWithWhereUniqueWithoutFunnelInput[]
    createMany?: FunelPagesCreateManyFunnelInputEnvelope
    set?: FunelPagesWhereUniqueInput | FunelPagesWhereUniqueInput[]
    disconnect?: FunelPagesWhereUniqueInput | FunelPagesWhereUniqueInput[]
    delete?: FunelPagesWhereUniqueInput | FunelPagesWhereUniqueInput[]
    connect?: FunelPagesWhereUniqueInput | FunelPagesWhereUniqueInput[]
    update?: FunelPagesUpdateWithWhereUniqueWithoutFunnelInput | FunelPagesUpdateWithWhereUniqueWithoutFunnelInput[]
    updateMany?: FunelPagesUpdateManyWithWhereWithoutFunnelInput | FunelPagesUpdateManyWithWhereWithoutFunnelInput[]
    deleteMany?: FunelPagesScalarWhereInput | FunelPagesScalarWhereInput[]
  }

  export type ClassNameUncheckedUpdateManyWithoutFunnelNestedInput = {
    create?: XOR<ClassNameCreateWithoutFunnelInput, ClassNameUncheckedCreateWithoutFunnelInput> | ClassNameCreateWithoutFunnelInput[] | ClassNameUncheckedCreateWithoutFunnelInput[]
    connectOrCreate?: ClassNameCreateOrConnectWithoutFunnelInput | ClassNameCreateOrConnectWithoutFunnelInput[]
    upsert?: ClassNameUpsertWithWhereUniqueWithoutFunnelInput | ClassNameUpsertWithWhereUniqueWithoutFunnelInput[]
    createMany?: ClassNameCreateManyFunnelInputEnvelope
    set?: ClassNameWhereUniqueInput | ClassNameWhereUniqueInput[]
    disconnect?: ClassNameWhereUniqueInput | ClassNameWhereUniqueInput[]
    delete?: ClassNameWhereUniqueInput | ClassNameWhereUniqueInput[]
    connect?: ClassNameWhereUniqueInput | ClassNameWhereUniqueInput[]
    update?: ClassNameUpdateWithWhereUniqueWithoutFunnelInput | ClassNameUpdateWithWhereUniqueWithoutFunnelInput[]
    updateMany?: ClassNameUpdateManyWithWhereWithoutFunnelInput | ClassNameUpdateManyWithWhereWithoutFunnelInput[]
    deleteMany?: ClassNameScalarWhereInput | ClassNameScalarWhereInput[]
  }

  export type UsersCreateNestedOneWithoutNotificationInput = {
    create?: XOR<UsersCreateWithoutNotificationInput, UsersUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: UsersCreateOrConnectWithoutNotificationInput
    connect?: UsersWhereUniqueInput
  }

  export type AgencyCreateNestedOneWithoutNotificationInput = {
    create?: XOR<AgencyCreateWithoutNotificationInput, AgencyUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutNotificationInput
    connect?: AgencyWhereUniqueInput
  }

  export type SubAccountsCreateNestedOneWithoutNotificationInput = {
    create?: XOR<SubAccountsCreateWithoutNotificationInput, SubAccountsUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: SubAccountsCreateOrConnectWithoutNotificationInput
    connect?: SubAccountsWhereUniqueInput
  }

  export type UsersUpdateOneRequiredWithoutNotificationNestedInput = {
    create?: XOR<UsersCreateWithoutNotificationInput, UsersUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: UsersCreateOrConnectWithoutNotificationInput
    upsert?: UsersUpsertWithoutNotificationInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutNotificationInput, UsersUpdateWithoutNotificationInput>, UsersUncheckedUpdateWithoutNotificationInput>
  }

  export type AgencyUpdateOneRequiredWithoutNotificationNestedInput = {
    create?: XOR<AgencyCreateWithoutNotificationInput, AgencyUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutNotificationInput
    upsert?: AgencyUpsertWithoutNotificationInput
    connect?: AgencyWhereUniqueInput
    update?: XOR<XOR<AgencyUpdateToOneWithWhereWithoutNotificationInput, AgencyUpdateWithoutNotificationInput>, AgencyUncheckedUpdateWithoutNotificationInput>
  }

  export type SubAccountsUpdateOneWithoutNotificationNestedInput = {
    create?: XOR<SubAccountsCreateWithoutNotificationInput, SubAccountsUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: SubAccountsCreateOrConnectWithoutNotificationInput
    upsert?: SubAccountsUpsertWithoutNotificationInput
    disconnect?: SubAccountsWhereInput | boolean
    delete?: SubAccountsWhereInput | boolean
    connect?: SubAccountsWhereUniqueInput
    update?: XOR<XOR<SubAccountsUpdateToOneWithWhereWithoutNotificationInput, SubAccountsUpdateWithoutNotificationInput>, SubAccountsUncheckedUpdateWithoutNotificationInput>
  }

  export type AgencyCreateNestedOneWithoutSubscriptionInput = {
    create?: XOR<AgencyCreateWithoutSubscriptionInput, AgencyUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutSubscriptionInput
    connect?: AgencyWhereUniqueInput
  }

  export type NullableEnumPlansFieldUpdateOperationsInput = {
    set?: $Enums.Plans | null
  }

  export type AgencyUpdateOneWithoutSubscriptionNestedInput = {
    create?: XOR<AgencyCreateWithoutSubscriptionInput, AgencyUncheckedCreateWithoutSubscriptionInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutSubscriptionInput
    upsert?: AgencyUpsertWithoutSubscriptionInput
    disconnect?: AgencyWhereInput | boolean
    delete?: AgencyWhereInput | boolean
    connect?: AgencyWhereUniqueInput
    update?: XOR<XOR<AgencyUpdateToOneWithWhereWithoutSubscriptionInput, AgencyUpdateWithoutSubscriptionInput>, AgencyUncheckedUpdateWithoutSubscriptionInput>
  }

  export type FunnelsCreateNestedOneWithoutClassNameInput = {
    create?: XOR<FunnelsCreateWithoutClassNameInput, FunnelsUncheckedCreateWithoutClassNameInput>
    connectOrCreate?: FunnelsCreateOrConnectWithoutClassNameInput
    connect?: FunnelsWhereUniqueInput
  }

  export type FunnelsUpdateOneRequiredWithoutClassNameNestedInput = {
    create?: XOR<FunnelsCreateWithoutClassNameInput, FunnelsUncheckedCreateWithoutClassNameInput>
    connectOrCreate?: FunnelsCreateOrConnectWithoutClassNameInput
    upsert?: FunnelsUpsertWithoutClassNameInput
    connect?: FunnelsWhereUniqueInput
    update?: XOR<XOR<FunnelsUpdateToOneWithWhereWithoutClassNameInput, FunnelsUpdateWithoutClassNameInput>, FunnelsUncheckedUpdateWithoutClassNameInput>
  }

  export type FunnelsCreateNestedOneWithoutFunelPagesInput = {
    create?: XOR<FunnelsCreateWithoutFunelPagesInput, FunnelsUncheckedCreateWithoutFunelPagesInput>
    connectOrCreate?: FunnelsCreateOrConnectWithoutFunelPagesInput
    connect?: FunnelsWhereUniqueInput
  }

  export type FunnelsUpdateOneRequiredWithoutFunelPagesNestedInput = {
    create?: XOR<FunnelsCreateWithoutFunelPagesInput, FunnelsUncheckedCreateWithoutFunelPagesInput>
    connectOrCreate?: FunnelsCreateOrConnectWithoutFunelPagesInput
    upsert?: FunnelsUpsertWithoutFunelPagesInput
    connect?: FunnelsWhereUniqueInput
    update?: XOR<XOR<FunnelsUpdateToOneWithWhereWithoutFunelPagesInput, FunnelsUpdateWithoutFunelPagesInput>, FunnelsUncheckedUpdateWithoutFunelPagesInput>
  }

  export type AgencyCreateNestedOneWithoutAddOnsInput = {
    create?: XOR<AgencyCreateWithoutAddOnsInput, AgencyUncheckedCreateWithoutAddOnsInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutAddOnsInput
    connect?: AgencyWhereUniqueInput
  }

  export type AgencyUpdateOneWithoutAddOnsNestedInput = {
    create?: XOR<AgencyCreateWithoutAddOnsInput, AgencyUncheckedCreateWithoutAddOnsInput>
    connectOrCreate?: AgencyCreateOrConnectWithoutAddOnsInput
    upsert?: AgencyUpsertWithoutAddOnsInput
    disconnect?: AgencyWhereInput | boolean
    delete?: AgencyWhereInput | boolean
    connect?: AgencyWhereUniqueInput
    update?: XOR<XOR<AgencyUpdateToOneWithWhereWithoutAddOnsInput, AgencyUpdateWithoutAddOnsInput>, AgencyUncheckedUpdateWithoutAddOnsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumIconFilter<$PrismaModel = never> = {
    equals?: $Enums.Icon | EnumIconFieldRefInput<$PrismaModel>
    in?: $Enums.Icon[] | ListEnumIconFieldRefInput<$PrismaModel>
    notIn?: $Enums.Icon[] | ListEnumIconFieldRefInput<$PrismaModel>
    not?: NestedEnumIconFilter<$PrismaModel> | $Enums.Icon
  }

  export type NestedEnumIconWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Icon | EnumIconFieldRefInput<$PrismaModel>
    in?: $Enums.Icon[] | ListEnumIconFieldRefInput<$PrismaModel>
    notIn?: $Enums.Icon[] | ListEnumIconFieldRefInput<$PrismaModel>
    not?: NestedEnumIconWithAggregatesFilter<$PrismaModel> | $Enums.Icon
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIconFilter<$PrismaModel>
    _max?: NestedEnumIconFilter<$PrismaModel>
  }

  export type NestedEnumTriggerTypesFilter<$PrismaModel = never> = {
    equals?: $Enums.TriggerTypes | EnumTriggerTypesFieldRefInput<$PrismaModel>
    in?: $Enums.TriggerTypes[] | ListEnumTriggerTypesFieldRefInput<$PrismaModel>
    notIn?: $Enums.TriggerTypes[] | ListEnumTriggerTypesFieldRefInput<$PrismaModel>
    not?: NestedEnumTriggerTypesFilter<$PrismaModel> | $Enums.TriggerTypes
  }

  export type NestedEnumTriggerTypesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TriggerTypes | EnumTriggerTypesFieldRefInput<$PrismaModel>
    in?: $Enums.TriggerTypes[] | ListEnumTriggerTypesFieldRefInput<$PrismaModel>
    notIn?: $Enums.TriggerTypes[] | ListEnumTriggerTypesFieldRefInput<$PrismaModel>
    not?: NestedEnumTriggerTypesWithAggregatesFilter<$PrismaModel> | $Enums.TriggerTypes
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTriggerTypesFilter<$PrismaModel>
    _max?: NestedEnumTriggerTypesFilter<$PrismaModel>
  }

  export type NestedEnumActionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActionType | EnumActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActionType[] | ListEnumActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActionType[] | ListEnumActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActionTypeFilter<$PrismaModel> | $Enums.ActionType
  }

  export type NestedEnumActionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActionType | EnumActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActionType[] | ListEnumActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActionType[] | ListEnumActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActionTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActionTypeFilter<$PrismaModel>
    _max?: NestedEnumActionTypeFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumInvitationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationStatus | EnumInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationStatusFilter<$PrismaModel> | $Enums.InvitationStatus
  }

  export type NestedEnumInvitationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationStatus | EnumInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvitationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvitationStatusFilter<$PrismaModel>
    _max?: NestedEnumInvitationStatusFilter<$PrismaModel>
  }

  export type NestedEnumPlansNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Plans | EnumPlansFieldRefInput<$PrismaModel> | null
    in?: $Enums.Plans[] | ListEnumPlansFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Plans[] | ListEnumPlansFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPlansNullableFilter<$PrismaModel> | $Enums.Plans | null
  }

  export type NestedEnumPlansNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Plans | EnumPlansFieldRefInput<$PrismaModel> | null
    in?: $Enums.Plans[] | ListEnumPlansFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Plans[] | ListEnumPlansFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPlansNullableWithAggregatesFilter<$PrismaModel> | $Enums.Plans | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPlansNullableFilter<$PrismaModel>
    _max?: NestedEnumPlansNullableFilter<$PrismaModel>
  }

  export type AgencyCreateWithoutUserInput = {
    id?: string
    connectAccountId?: string | null
    customerId?: string
    name: string
    agencyLogo: string
    companyEmail: string
    companyPhone: string
    whiteLabel?: boolean
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    goal: number
    createdAt?: Date | string
    updatedAt?: Date | string
    SubAccount?: SubAccountsCreateNestedManyWithoutAgencyInput
    SidebarOption?: AgencySidebarOptionCreateNestedManyWithoutAgencyInput
    Invitation?: InvitationsCreateNestedManyWithoutAgencyInput
    Notification?: NotificationsCreateNestedManyWithoutAgencyInput
    Subscription?: SubscriptionsCreateNestedOneWithoutAgencyInput
    AddOns?: AddOnsCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUncheckedCreateWithoutUserInput = {
    id?: string
    connectAccountId?: string | null
    customerId?: string
    name: string
    agencyLogo: string
    companyEmail: string
    companyPhone: string
    whiteLabel?: boolean
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    goal: number
    createdAt?: Date | string
    updatedAt?: Date | string
    SubAccount?: SubAccountsUncheckedCreateNestedManyWithoutAgencyInput
    SidebarOption?: AgencySidebarOptionUncheckedCreateNestedManyWithoutAgencyInput
    Invitation?: InvitationsUncheckedCreateNestedManyWithoutAgencyInput
    Notification?: NotificationsUncheckedCreateNestedManyWithoutAgencyInput
    Subscription?: SubscriptionsUncheckedCreateNestedOneWithoutAgencyInput
    AddOns?: AddOnsUncheckedCreateNestedManyWithoutAgencyInput
  }

  export type AgencyCreateOrConnectWithoutUserInput = {
    where: AgencyWhereUniqueInput
    create: XOR<AgencyCreateWithoutUserInput, AgencyUncheckedCreateWithoutUserInput>
  }

  export type PermissionsCreateWithoutUsersInput = {
    id?: string
    access: boolean
    SubAcctount: SubAccountsCreateNestedOneWithoutPermissionsInput
  }

  export type PermissionsUncheckedCreateWithoutUsersInput = {
    id?: string
    subAccontId: string
    access: boolean
  }

  export type PermissionsCreateOrConnectWithoutUsersInput = {
    where: PermissionsWhereUniqueInput
    create: XOR<PermissionsCreateWithoutUsersInput, PermissionsUncheckedCreateWithoutUsersInput>
  }

  export type PermissionsCreateManyUsersInputEnvelope = {
    data: PermissionsCreateManyUsersInput | PermissionsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type TicketsCreateWithoutUsersInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: number
    value?: Decimal | DecimalJsLike | number | string | null
    description?: string | null
    Lane: LaneCreateNestedOneWithoutTicketsInput
    tags?: TagsCreateNestedManyWithoutTicketsInput
    Contacts?: ContactsCreateNestedOneWithoutTicketsInput
  }

  export type TicketsUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lineId: string
    order?: number
    value?: Decimal | DecimalJsLike | number | string | null
    description?: string | null
    contactId?: string | null
    tags?: TagsUncheckedCreateNestedManyWithoutTicketsInput
  }

  export type TicketsCreateOrConnectWithoutUsersInput = {
    where: TicketsWhereUniqueInput
    create: XOR<TicketsCreateWithoutUsersInput, TicketsUncheckedCreateWithoutUsersInput>
  }

  export type TicketsCreateManyUsersInputEnvelope = {
    data: TicketsCreateManyUsersInput | TicketsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type NotificationsCreateWithoutUsersInput = {
    id?: string
    notification: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Agency: AgencyCreateNestedOneWithoutNotificationInput
    SubAccounts?: SubAccountsCreateNestedOneWithoutNotificationInput
  }

  export type NotificationsUncheckedCreateWithoutUsersInput = {
    id?: string
    notification: string
    agencyId: string
    subAccountId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationsCreateOrConnectWithoutUsersInput = {
    where: NotificationsWhereUniqueInput
    create: XOR<NotificationsCreateWithoutUsersInput, NotificationsUncheckedCreateWithoutUsersInput>
  }

  export type NotificationsCreateManyUsersInputEnvelope = {
    data: NotificationsCreateManyUsersInput | NotificationsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type AgencyUpsertWithoutUserInput = {
    update: XOR<AgencyUpdateWithoutUserInput, AgencyUncheckedUpdateWithoutUserInput>
    create: XOR<AgencyCreateWithoutUserInput, AgencyUncheckedCreateWithoutUserInput>
    where?: AgencyWhereInput
  }

  export type AgencyUpdateToOneWithWhereWithoutUserInput = {
    where?: AgencyWhereInput
    data: XOR<AgencyUpdateWithoutUserInput, AgencyUncheckedUpdateWithoutUserInput>
  }

  export type AgencyUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    agencyLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    whiteLabel?: BoolFieldUpdateOperationsInput | boolean
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SubAccount?: SubAccountsUpdateManyWithoutAgencyNestedInput
    SidebarOption?: AgencySidebarOptionUpdateManyWithoutAgencyNestedInput
    Invitation?: InvitationsUpdateManyWithoutAgencyNestedInput
    Notification?: NotificationsUpdateManyWithoutAgencyNestedInput
    Subscription?: SubscriptionsUpdateOneWithoutAgencyNestedInput
    AddOns?: AddOnsUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    agencyLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    whiteLabel?: BoolFieldUpdateOperationsInput | boolean
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SubAccount?: SubAccountsUncheckedUpdateManyWithoutAgencyNestedInput
    SidebarOption?: AgencySidebarOptionUncheckedUpdateManyWithoutAgencyNestedInput
    Invitation?: InvitationsUncheckedUpdateManyWithoutAgencyNestedInput
    Notification?: NotificationsUncheckedUpdateManyWithoutAgencyNestedInput
    Subscription?: SubscriptionsUncheckedUpdateOneWithoutAgencyNestedInput
    AddOns?: AddOnsUncheckedUpdateManyWithoutAgencyNestedInput
  }

  export type PermissionsUpsertWithWhereUniqueWithoutUsersInput = {
    where: PermissionsWhereUniqueInput
    update: XOR<PermissionsUpdateWithoutUsersInput, PermissionsUncheckedUpdateWithoutUsersInput>
    create: XOR<PermissionsCreateWithoutUsersInput, PermissionsUncheckedCreateWithoutUsersInput>
  }

  export type PermissionsUpdateWithWhereUniqueWithoutUsersInput = {
    where: PermissionsWhereUniqueInput
    data: XOR<PermissionsUpdateWithoutUsersInput, PermissionsUncheckedUpdateWithoutUsersInput>
  }

  export type PermissionsUpdateManyWithWhereWithoutUsersInput = {
    where: PermissionsScalarWhereInput
    data: XOR<PermissionsUpdateManyMutationInput, PermissionsUncheckedUpdateManyWithoutUsersInput>
  }

  export type PermissionsScalarWhereInput = {
    AND?: PermissionsScalarWhereInput | PermissionsScalarWhereInput[]
    OR?: PermissionsScalarWhereInput[]
    NOT?: PermissionsScalarWhereInput | PermissionsScalarWhereInput[]
    id?: StringFilter<"Permissions"> | string
    email?: StringFilter<"Permissions"> | string
    subAccontId?: StringFilter<"Permissions"> | string
    access?: BoolFilter<"Permissions"> | boolean
  }

  export type TicketsUpsertWithWhereUniqueWithoutUsersInput = {
    where: TicketsWhereUniqueInput
    update: XOR<TicketsUpdateWithoutUsersInput, TicketsUncheckedUpdateWithoutUsersInput>
    create: XOR<TicketsCreateWithoutUsersInput, TicketsUncheckedCreateWithoutUsersInput>
  }

  export type TicketsUpdateWithWhereUniqueWithoutUsersInput = {
    where: TicketsWhereUniqueInput
    data: XOR<TicketsUpdateWithoutUsersInput, TicketsUncheckedUpdateWithoutUsersInput>
  }

  export type TicketsUpdateManyWithWhereWithoutUsersInput = {
    where: TicketsScalarWhereInput
    data: XOR<TicketsUpdateManyMutationInput, TicketsUncheckedUpdateManyWithoutUsersInput>
  }

  export type TicketsScalarWhereInput = {
    AND?: TicketsScalarWhereInput | TicketsScalarWhereInput[]
    OR?: TicketsScalarWhereInput[]
    NOT?: TicketsScalarWhereInput | TicketsScalarWhereInput[]
    id?: StringFilter<"Tickets"> | string
    name?: StringFilter<"Tickets"> | string
    createdAt?: DateTimeFilter<"Tickets"> | Date | string
    updatedAt?: DateTimeFilter<"Tickets"> | Date | string
    lineId?: StringFilter<"Tickets"> | string
    order?: IntFilter<"Tickets"> | number
    value?: DecimalNullableFilter<"Tickets"> | Decimal | DecimalJsLike | number | string | null
    description?: StringNullableFilter<"Tickets"> | string | null
    userId?: StringNullableFilter<"Tickets"> | string | null
    contactId?: StringNullableFilter<"Tickets"> | string | null
  }

  export type NotificationsUpsertWithWhereUniqueWithoutUsersInput = {
    where: NotificationsWhereUniqueInput
    update: XOR<NotificationsUpdateWithoutUsersInput, NotificationsUncheckedUpdateWithoutUsersInput>
    create: XOR<NotificationsCreateWithoutUsersInput, NotificationsUncheckedCreateWithoutUsersInput>
  }

  export type NotificationsUpdateWithWhereUniqueWithoutUsersInput = {
    where: NotificationsWhereUniqueInput
    data: XOR<NotificationsUpdateWithoutUsersInput, NotificationsUncheckedUpdateWithoutUsersInput>
  }

  export type NotificationsUpdateManyWithWhereWithoutUsersInput = {
    where: NotificationsScalarWhereInput
    data: XOR<NotificationsUpdateManyMutationInput, NotificationsUncheckedUpdateManyWithoutUsersInput>
  }

  export type NotificationsScalarWhereInput = {
    AND?: NotificationsScalarWhereInput | NotificationsScalarWhereInput[]
    OR?: NotificationsScalarWhereInput[]
    NOT?: NotificationsScalarWhereInput | NotificationsScalarWhereInput[]
    id?: StringFilter<"Notifications"> | string
    notification?: StringFilter<"Notifications"> | string
    agencyId?: StringFilter<"Notifications"> | string
    subAccountId?: StringNullableFilter<"Notifications"> | string | null
    userId?: StringFilter<"Notifications"> | string
    createdAt?: DateTimeFilter<"Notifications"> | Date | string
    updatedAt?: DateTimeFilter<"Notifications"> | Date | string
  }

  export type UsersCreateWithoutPermissionInput = {
    id?: string
    name: string
    avatarUrl: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.Role
    Agency?: AgencyCreateNestedOneWithoutUserInput
    Ticket?: TicketsCreateNestedManyWithoutUsersInput
    Notification?: NotificationsCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutPermissionInput = {
    id?: string
    name: string
    avatarUrl: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.Role
    agencyId?: string | null
    Ticket?: TicketsUncheckedCreateNestedManyWithoutUsersInput
    Notification?: NotificationsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutPermissionInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutPermissionInput, UsersUncheckedCreateWithoutPermissionInput>
  }

  export type SubAccountsCreateWithoutPermissionsInput = {
    id?: string
    connectAccountId?: string | null
    name: string
    subAcctountLogo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    Agency: AgencyCreateNestedOneWithoutSubAccountInput
    SidebarOption?: AgencySidebarOptionCreateNestedManyWithoutSubAccountsInput
    Funnels?: FunnelsCreateNestedManyWithoutSubAccountInput
    Media?: MediaCreateNestedManyWithoutSubAccountsInput
    Contact?: ContactsCreateNestedManyWithoutSubAccountsInput
    Trigger?: TriggersCreateNestedManyWithoutSubAccountsInput
    Automation?: AutomationsCreateNestedManyWithoutSubAccountsInput
    Pipeline?: PipelinesCreateNestedManyWithoutSubAccountInput
    Tags?: TagsCreateNestedManyWithoutSubAccountsInput
    Notification?: NotificationsCreateNestedManyWithoutSubAccountsInput
    SubAccountSidebarOption?: SubAccountSidebarOptionCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountsUncheckedCreateWithoutPermissionsInput = {
    id?: string
    connectAccountId?: string | null
    name: string
    subAcctountLogo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    agencyId: string
    SidebarOption?: AgencySidebarOptionUncheckedCreateNestedManyWithoutSubAccountsInput
    Funnels?: FunnelsUncheckedCreateNestedManyWithoutSubAccountInput
    Media?: MediaUncheckedCreateNestedManyWithoutSubAccountsInput
    Contact?: ContactsUncheckedCreateNestedManyWithoutSubAccountsInput
    Trigger?: TriggersUncheckedCreateNestedManyWithoutSubAccountsInput
    Automation?: AutomationsUncheckedCreateNestedManyWithoutSubAccountsInput
    Pipeline?: PipelinesUncheckedCreateNestedManyWithoutSubAccountInput
    Tags?: TagsUncheckedCreateNestedManyWithoutSubAccountsInput
    Notification?: NotificationsUncheckedCreateNestedManyWithoutSubAccountsInput
    SubAccountSidebarOption?: SubAccountSidebarOptionUncheckedCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountsCreateOrConnectWithoutPermissionsInput = {
    where: SubAccountsWhereUniqueInput
    create: XOR<SubAccountsCreateWithoutPermissionsInput, SubAccountsUncheckedCreateWithoutPermissionsInput>
  }

  export type UsersUpsertWithoutPermissionInput = {
    update: XOR<UsersUpdateWithoutPermissionInput, UsersUncheckedUpdateWithoutPermissionInput>
    create: XOR<UsersCreateWithoutPermissionInput, UsersUncheckedCreateWithoutPermissionInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutPermissionInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutPermissionInput, UsersUncheckedUpdateWithoutPermissionInput>
  }

  export type UsersUpdateWithoutPermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    Agency?: AgencyUpdateOneWithoutUserNestedInput
    Ticket?: TicketsUpdateManyWithoutUsersNestedInput
    Notification?: NotificationsUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutPermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
    Ticket?: TicketsUncheckedUpdateManyWithoutUsersNestedInput
    Notification?: NotificationsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type SubAccountsUpsertWithoutPermissionsInput = {
    update: XOR<SubAccountsUpdateWithoutPermissionsInput, SubAccountsUncheckedUpdateWithoutPermissionsInput>
    create: XOR<SubAccountsCreateWithoutPermissionsInput, SubAccountsUncheckedCreateWithoutPermissionsInput>
    where?: SubAccountsWhereInput
  }

  export type SubAccountsUpdateToOneWithWhereWithoutPermissionsInput = {
    where?: SubAccountsWhereInput
    data: XOR<SubAccountsUpdateWithoutPermissionsInput, SubAccountsUncheckedUpdateWithoutPermissionsInput>
  }

  export type SubAccountsUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAcctountLogo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    Agency?: AgencyUpdateOneRequiredWithoutSubAccountNestedInput
    SidebarOption?: AgencySidebarOptionUpdateManyWithoutSubAccountsNestedInput
    Funnels?: FunnelsUpdateManyWithoutSubAccountNestedInput
    Media?: MediaUpdateManyWithoutSubAccountsNestedInput
    Contact?: ContactsUpdateManyWithoutSubAccountsNestedInput
    Trigger?: TriggersUpdateManyWithoutSubAccountsNestedInput
    Automation?: AutomationsUpdateManyWithoutSubAccountsNestedInput
    Pipeline?: PipelinesUpdateManyWithoutSubAccountNestedInput
    Tags?: TagsUpdateManyWithoutSubAccountsNestedInput
    Notification?: NotificationsUpdateManyWithoutSubAccountsNestedInput
    SubAccountSidebarOption?: SubAccountSidebarOptionUpdateManyWithoutSubAccountNestedInput
  }

  export type SubAccountsUncheckedUpdateWithoutPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAcctountLogo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    SidebarOption?: AgencySidebarOptionUncheckedUpdateManyWithoutSubAccountsNestedInput
    Funnels?: FunnelsUncheckedUpdateManyWithoutSubAccountNestedInput
    Media?: MediaUncheckedUpdateManyWithoutSubAccountsNestedInput
    Contact?: ContactsUncheckedUpdateManyWithoutSubAccountsNestedInput
    Trigger?: TriggersUncheckedUpdateManyWithoutSubAccountsNestedInput
    Automation?: AutomationsUncheckedUpdateManyWithoutSubAccountsNestedInput
    Pipeline?: PipelinesUncheckedUpdateManyWithoutSubAccountNestedInput
    Tags?: TagsUncheckedUpdateManyWithoutSubAccountsNestedInput
    Notification?: NotificationsUncheckedUpdateManyWithoutSubAccountsNestedInput
    SubAccountSidebarOption?: SubAccountSidebarOptionUncheckedUpdateManyWithoutSubAccountNestedInput
  }

  export type UsersCreateWithoutAgencyInput = {
    id?: string
    name: string
    avatarUrl: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.Role
    Permission?: PermissionsCreateNestedManyWithoutUsersInput
    Ticket?: TicketsCreateNestedManyWithoutUsersInput
    Notification?: NotificationsCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutAgencyInput = {
    id?: string
    name: string
    avatarUrl: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.Role
    Permission?: PermissionsUncheckedCreateNestedManyWithoutUsersInput
    Ticket?: TicketsUncheckedCreateNestedManyWithoutUsersInput
    Notification?: NotificationsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutAgencyInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutAgencyInput, UsersUncheckedCreateWithoutAgencyInput>
  }

  export type UsersCreateManyAgencyInputEnvelope = {
    data: UsersCreateManyAgencyInput | UsersCreateManyAgencyInput[]
    skipDuplicates?: boolean
  }

  export type SubAccountsCreateWithoutAgencyInput = {
    id?: string
    connectAccountId?: string | null
    name: string
    subAcctountLogo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    SidebarOption?: AgencySidebarOptionCreateNestedManyWithoutSubAccountsInput
    Permissions?: PermissionsCreateNestedManyWithoutSubAcctountInput
    Funnels?: FunnelsCreateNestedManyWithoutSubAccountInput
    Media?: MediaCreateNestedManyWithoutSubAccountsInput
    Contact?: ContactsCreateNestedManyWithoutSubAccountsInput
    Trigger?: TriggersCreateNestedManyWithoutSubAccountsInput
    Automation?: AutomationsCreateNestedManyWithoutSubAccountsInput
    Pipeline?: PipelinesCreateNestedManyWithoutSubAccountInput
    Tags?: TagsCreateNestedManyWithoutSubAccountsInput
    Notification?: NotificationsCreateNestedManyWithoutSubAccountsInput
    SubAccountSidebarOption?: SubAccountSidebarOptionCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountsUncheckedCreateWithoutAgencyInput = {
    id?: string
    connectAccountId?: string | null
    name: string
    subAcctountLogo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    SidebarOption?: AgencySidebarOptionUncheckedCreateNestedManyWithoutSubAccountsInput
    Permissions?: PermissionsUncheckedCreateNestedManyWithoutSubAcctountInput
    Funnels?: FunnelsUncheckedCreateNestedManyWithoutSubAccountInput
    Media?: MediaUncheckedCreateNestedManyWithoutSubAccountsInput
    Contact?: ContactsUncheckedCreateNestedManyWithoutSubAccountsInput
    Trigger?: TriggersUncheckedCreateNestedManyWithoutSubAccountsInput
    Automation?: AutomationsUncheckedCreateNestedManyWithoutSubAccountsInput
    Pipeline?: PipelinesUncheckedCreateNestedManyWithoutSubAccountInput
    Tags?: TagsUncheckedCreateNestedManyWithoutSubAccountsInput
    Notification?: NotificationsUncheckedCreateNestedManyWithoutSubAccountsInput
    SubAccountSidebarOption?: SubAccountSidebarOptionUncheckedCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountsCreateOrConnectWithoutAgencyInput = {
    where: SubAccountsWhereUniqueInput
    create: XOR<SubAccountsCreateWithoutAgencyInput, SubAccountsUncheckedCreateWithoutAgencyInput>
  }

  export type SubAccountsCreateManyAgencyInputEnvelope = {
    data: SubAccountsCreateManyAgencyInput | SubAccountsCreateManyAgencyInput[]
    skipDuplicates?: boolean
  }

  export type AgencySidebarOptionCreateWithoutAgencyInput = {
    id?: string
    name?: string
    link?: string
    icon?: $Enums.Icon
    createdAt?: Date | string
    updatedAt?: Date | string
    SubAccounts?: SubAccountsCreateNestedOneWithoutSidebarOptionInput
  }

  export type AgencySidebarOptionUncheckedCreateWithoutAgencyInput = {
    id?: string
    name?: string
    link?: string
    icon?: $Enums.Icon
    createdAt?: Date | string
    updatedAt?: Date | string
    subAccountId?: string | null
  }

  export type AgencySidebarOptionCreateOrConnectWithoutAgencyInput = {
    where: AgencySidebarOptionWhereUniqueInput
    create: XOR<AgencySidebarOptionCreateWithoutAgencyInput, AgencySidebarOptionUncheckedCreateWithoutAgencyInput>
  }

  export type AgencySidebarOptionCreateManyAgencyInputEnvelope = {
    data: AgencySidebarOptionCreateManyAgencyInput | AgencySidebarOptionCreateManyAgencyInput[]
    skipDuplicates?: boolean
  }

  export type InvitationsCreateWithoutAgencyInput = {
    id?: string
    email: string
    status?: $Enums.InvitationStatus
    role?: $Enums.Role
  }

  export type InvitationsUncheckedCreateWithoutAgencyInput = {
    id?: string
    email: string
    status?: $Enums.InvitationStatus
    role?: $Enums.Role
  }

  export type InvitationsCreateOrConnectWithoutAgencyInput = {
    where: InvitationsWhereUniqueInput
    create: XOR<InvitationsCreateWithoutAgencyInput, InvitationsUncheckedCreateWithoutAgencyInput>
  }

  export type InvitationsCreateManyAgencyInputEnvelope = {
    data: InvitationsCreateManyAgencyInput | InvitationsCreateManyAgencyInput[]
    skipDuplicates?: boolean
  }

  export type NotificationsCreateWithoutAgencyInput = {
    id?: string
    notification: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Users: UsersCreateNestedOneWithoutNotificationInput
    SubAccounts?: SubAccountsCreateNestedOneWithoutNotificationInput
  }

  export type NotificationsUncheckedCreateWithoutAgencyInput = {
    id?: string
    notification: string
    subAccountId?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationsCreateOrConnectWithoutAgencyInput = {
    where: NotificationsWhereUniqueInput
    create: XOR<NotificationsCreateWithoutAgencyInput, NotificationsUncheckedCreateWithoutAgencyInput>
  }

  export type NotificationsCreateManyAgencyInputEnvelope = {
    data: NotificationsCreateManyAgencyInput | NotificationsCreateManyAgencyInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionsCreateWithoutAgencyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    plan?: $Enums.Plans | null
    price?: string | null
    active?: boolean
    priceId: string
    customerId: string
    currentPeriodEndDate: Date | string
    subscriptionId: string
  }

  export type SubscriptionsUncheckedCreateWithoutAgencyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    plan?: $Enums.Plans | null
    price?: string | null
    active?: boolean
    priceId: string
    customerId: string
    currentPeriodEndDate: Date | string
    subscriptionId: string
  }

  export type SubscriptionsCreateOrConnectWithoutAgencyInput = {
    where: SubscriptionsWhereUniqueInput
    create: XOR<SubscriptionsCreateWithoutAgencyInput, SubscriptionsUncheckedCreateWithoutAgencyInput>
  }

  export type AddOnsCreateWithoutAgencyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    active?: boolean
    priceId: string
  }

  export type AddOnsUncheckedCreateWithoutAgencyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    active?: boolean
    priceId: string
  }

  export type AddOnsCreateOrConnectWithoutAgencyInput = {
    where: AddOnsWhereUniqueInput
    create: XOR<AddOnsCreateWithoutAgencyInput, AddOnsUncheckedCreateWithoutAgencyInput>
  }

  export type AddOnsCreateManyAgencyInputEnvelope = {
    data: AddOnsCreateManyAgencyInput | AddOnsCreateManyAgencyInput[]
    skipDuplicates?: boolean
  }

  export type UsersUpsertWithWhereUniqueWithoutAgencyInput = {
    where: UsersWhereUniqueInput
    update: XOR<UsersUpdateWithoutAgencyInput, UsersUncheckedUpdateWithoutAgencyInput>
    create: XOR<UsersCreateWithoutAgencyInput, UsersUncheckedCreateWithoutAgencyInput>
  }

  export type UsersUpdateWithWhereUniqueWithoutAgencyInput = {
    where: UsersWhereUniqueInput
    data: XOR<UsersUpdateWithoutAgencyInput, UsersUncheckedUpdateWithoutAgencyInput>
  }

  export type UsersUpdateManyWithWhereWithoutAgencyInput = {
    where: UsersScalarWhereInput
    data: XOR<UsersUpdateManyMutationInput, UsersUncheckedUpdateManyWithoutAgencyInput>
  }

  export type UsersScalarWhereInput = {
    AND?: UsersScalarWhereInput | UsersScalarWhereInput[]
    OR?: UsersScalarWhereInput[]
    NOT?: UsersScalarWhereInput | UsersScalarWhereInput[]
    id?: StringFilter<"Users"> | string
    name?: StringFilter<"Users"> | string
    avatarUrl?: StringFilter<"Users"> | string
    email?: StringFilter<"Users"> | string
    createdAt?: DateTimeFilter<"Users"> | Date | string
    updatedAt?: DateTimeFilter<"Users"> | Date | string
    role?: EnumRoleFilter<"Users"> | $Enums.Role
    agencyId?: StringNullableFilter<"Users"> | string | null
  }

  export type SubAccountsUpsertWithWhereUniqueWithoutAgencyInput = {
    where: SubAccountsWhereUniqueInput
    update: XOR<SubAccountsUpdateWithoutAgencyInput, SubAccountsUncheckedUpdateWithoutAgencyInput>
    create: XOR<SubAccountsCreateWithoutAgencyInput, SubAccountsUncheckedCreateWithoutAgencyInput>
  }

  export type SubAccountsUpdateWithWhereUniqueWithoutAgencyInput = {
    where: SubAccountsWhereUniqueInput
    data: XOR<SubAccountsUpdateWithoutAgencyInput, SubAccountsUncheckedUpdateWithoutAgencyInput>
  }

  export type SubAccountsUpdateManyWithWhereWithoutAgencyInput = {
    where: SubAccountsScalarWhereInput
    data: XOR<SubAccountsUpdateManyMutationInput, SubAccountsUncheckedUpdateManyWithoutAgencyInput>
  }

  export type SubAccountsScalarWhereInput = {
    AND?: SubAccountsScalarWhereInput | SubAccountsScalarWhereInput[]
    OR?: SubAccountsScalarWhereInput[]
    NOT?: SubAccountsScalarWhereInput | SubAccountsScalarWhereInput[]
    id?: StringFilter<"SubAccounts"> | string
    connectAccountId?: StringNullableFilter<"SubAccounts"> | string | null
    name?: StringFilter<"SubAccounts"> | string
    subAcctountLogo?: StringFilter<"SubAccounts"> | string
    createdAt?: DateTimeFilter<"SubAccounts"> | Date | string
    updatedAt?: DateTimeFilter<"SubAccounts"> | Date | string
    companyEmail?: StringFilter<"SubAccounts"> | string
    companyPhone?: StringFilter<"SubAccounts"> | string
    goal?: IntFilter<"SubAccounts"> | number
    address?: StringFilter<"SubAccounts"> | string
    city?: StringFilter<"SubAccounts"> | string
    zipCode?: StringFilter<"SubAccounts"> | string
    state?: StringFilter<"SubAccounts"> | string
    country?: StringFilter<"SubAccounts"> | string
    agencyId?: StringFilter<"SubAccounts"> | string
  }

  export type AgencySidebarOptionUpsertWithWhereUniqueWithoutAgencyInput = {
    where: AgencySidebarOptionWhereUniqueInput
    update: XOR<AgencySidebarOptionUpdateWithoutAgencyInput, AgencySidebarOptionUncheckedUpdateWithoutAgencyInput>
    create: XOR<AgencySidebarOptionCreateWithoutAgencyInput, AgencySidebarOptionUncheckedCreateWithoutAgencyInput>
  }

  export type AgencySidebarOptionUpdateWithWhereUniqueWithoutAgencyInput = {
    where: AgencySidebarOptionWhereUniqueInput
    data: XOR<AgencySidebarOptionUpdateWithoutAgencyInput, AgencySidebarOptionUncheckedUpdateWithoutAgencyInput>
  }

  export type AgencySidebarOptionUpdateManyWithWhereWithoutAgencyInput = {
    where: AgencySidebarOptionScalarWhereInput
    data: XOR<AgencySidebarOptionUpdateManyMutationInput, AgencySidebarOptionUncheckedUpdateManyWithoutAgencyInput>
  }

  export type AgencySidebarOptionScalarWhereInput = {
    AND?: AgencySidebarOptionScalarWhereInput | AgencySidebarOptionScalarWhereInput[]
    OR?: AgencySidebarOptionScalarWhereInput[]
    NOT?: AgencySidebarOptionScalarWhereInput | AgencySidebarOptionScalarWhereInput[]
    id?: StringFilter<"AgencySidebarOption"> | string
    name?: StringFilter<"AgencySidebarOption"> | string
    link?: StringFilter<"AgencySidebarOption"> | string
    icon?: EnumIconFilter<"AgencySidebarOption"> | $Enums.Icon
    createdAt?: DateTimeFilter<"AgencySidebarOption"> | Date | string
    updatedAt?: DateTimeFilter<"AgencySidebarOption"> | Date | string
    agencyId?: StringFilter<"AgencySidebarOption"> | string
    subAccountId?: StringNullableFilter<"AgencySidebarOption"> | string | null
  }

  export type InvitationsUpsertWithWhereUniqueWithoutAgencyInput = {
    where: InvitationsWhereUniqueInput
    update: XOR<InvitationsUpdateWithoutAgencyInput, InvitationsUncheckedUpdateWithoutAgencyInput>
    create: XOR<InvitationsCreateWithoutAgencyInput, InvitationsUncheckedCreateWithoutAgencyInput>
  }

  export type InvitationsUpdateWithWhereUniqueWithoutAgencyInput = {
    where: InvitationsWhereUniqueInput
    data: XOR<InvitationsUpdateWithoutAgencyInput, InvitationsUncheckedUpdateWithoutAgencyInput>
  }

  export type InvitationsUpdateManyWithWhereWithoutAgencyInput = {
    where: InvitationsScalarWhereInput
    data: XOR<InvitationsUpdateManyMutationInput, InvitationsUncheckedUpdateManyWithoutAgencyInput>
  }

  export type InvitationsScalarWhereInput = {
    AND?: InvitationsScalarWhereInput | InvitationsScalarWhereInput[]
    OR?: InvitationsScalarWhereInput[]
    NOT?: InvitationsScalarWhereInput | InvitationsScalarWhereInput[]
    id?: StringFilter<"Invitations"> | string
    email?: StringFilter<"Invitations"> | string
    agencyId?: StringFilter<"Invitations"> | string
    status?: EnumInvitationStatusFilter<"Invitations"> | $Enums.InvitationStatus
    role?: EnumRoleFilter<"Invitations"> | $Enums.Role
  }

  export type NotificationsUpsertWithWhereUniqueWithoutAgencyInput = {
    where: NotificationsWhereUniqueInput
    update: XOR<NotificationsUpdateWithoutAgencyInput, NotificationsUncheckedUpdateWithoutAgencyInput>
    create: XOR<NotificationsCreateWithoutAgencyInput, NotificationsUncheckedCreateWithoutAgencyInput>
  }

  export type NotificationsUpdateWithWhereUniqueWithoutAgencyInput = {
    where: NotificationsWhereUniqueInput
    data: XOR<NotificationsUpdateWithoutAgencyInput, NotificationsUncheckedUpdateWithoutAgencyInput>
  }

  export type NotificationsUpdateManyWithWhereWithoutAgencyInput = {
    where: NotificationsScalarWhereInput
    data: XOR<NotificationsUpdateManyMutationInput, NotificationsUncheckedUpdateManyWithoutAgencyInput>
  }

  export type SubscriptionsUpsertWithoutAgencyInput = {
    update: XOR<SubscriptionsUpdateWithoutAgencyInput, SubscriptionsUncheckedUpdateWithoutAgencyInput>
    create: XOR<SubscriptionsCreateWithoutAgencyInput, SubscriptionsUncheckedCreateWithoutAgencyInput>
    where?: SubscriptionsWhereInput
  }

  export type SubscriptionsUpdateToOneWithWhereWithoutAgencyInput = {
    where?: SubscriptionsWhereInput
    data: XOR<SubscriptionsUpdateWithoutAgencyInput, SubscriptionsUncheckedUpdateWithoutAgencyInput>
  }

  export type SubscriptionsUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: NullableEnumPlansFieldUpdateOperationsInput | $Enums.Plans | null
    price?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    priceId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    currentPeriodEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
  }

  export type SubscriptionsUncheckedUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: NullableEnumPlansFieldUpdateOperationsInput | $Enums.Plans | null
    price?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    priceId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    currentPeriodEndDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
  }

  export type AddOnsUpsertWithWhereUniqueWithoutAgencyInput = {
    where: AddOnsWhereUniqueInput
    update: XOR<AddOnsUpdateWithoutAgencyInput, AddOnsUncheckedUpdateWithoutAgencyInput>
    create: XOR<AddOnsCreateWithoutAgencyInput, AddOnsUncheckedCreateWithoutAgencyInput>
  }

  export type AddOnsUpdateWithWhereUniqueWithoutAgencyInput = {
    where: AddOnsWhereUniqueInput
    data: XOR<AddOnsUpdateWithoutAgencyInput, AddOnsUncheckedUpdateWithoutAgencyInput>
  }

  export type AddOnsUpdateManyWithWhereWithoutAgencyInput = {
    where: AddOnsScalarWhereInput
    data: XOR<AddOnsUpdateManyMutationInput, AddOnsUncheckedUpdateManyWithoutAgencyInput>
  }

  export type AddOnsScalarWhereInput = {
    AND?: AddOnsScalarWhereInput | AddOnsScalarWhereInput[]
    OR?: AddOnsScalarWhereInput[]
    NOT?: AddOnsScalarWhereInput | AddOnsScalarWhereInput[]
    id?: StringFilter<"AddOns"> | string
    createdAt?: DateTimeFilter<"AddOns"> | Date | string
    updatedAt?: DateTimeFilter<"AddOns"> | Date | string
    name?: StringFilter<"AddOns"> | string
    active?: BoolFilter<"AddOns"> | boolean
    priceId?: StringFilter<"AddOns"> | string
    agencyId?: StringNullableFilter<"AddOns"> | string | null
  }

  export type AgencyCreateWithoutSidebarOptionInput = {
    id?: string
    connectAccountId?: string | null
    customerId?: string
    name: string
    agencyLogo: string
    companyEmail: string
    companyPhone: string
    whiteLabel?: boolean
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    goal: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UsersCreateNestedManyWithoutAgencyInput
    SubAccount?: SubAccountsCreateNestedManyWithoutAgencyInput
    Invitation?: InvitationsCreateNestedManyWithoutAgencyInput
    Notification?: NotificationsCreateNestedManyWithoutAgencyInput
    Subscription?: SubscriptionsCreateNestedOneWithoutAgencyInput
    AddOns?: AddOnsCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUncheckedCreateWithoutSidebarOptionInput = {
    id?: string
    connectAccountId?: string | null
    customerId?: string
    name: string
    agencyLogo: string
    companyEmail: string
    companyPhone: string
    whiteLabel?: boolean
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    goal: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UsersUncheckedCreateNestedManyWithoutAgencyInput
    SubAccount?: SubAccountsUncheckedCreateNestedManyWithoutAgencyInput
    Invitation?: InvitationsUncheckedCreateNestedManyWithoutAgencyInput
    Notification?: NotificationsUncheckedCreateNestedManyWithoutAgencyInput
    Subscription?: SubscriptionsUncheckedCreateNestedOneWithoutAgencyInput
    AddOns?: AddOnsUncheckedCreateNestedManyWithoutAgencyInput
  }

  export type AgencyCreateOrConnectWithoutSidebarOptionInput = {
    where: AgencyWhereUniqueInput
    create: XOR<AgencyCreateWithoutSidebarOptionInput, AgencyUncheckedCreateWithoutSidebarOptionInput>
  }

  export type SubAccountsCreateWithoutSidebarOptionInput = {
    id?: string
    connectAccountId?: string | null
    name: string
    subAcctountLogo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    Agency: AgencyCreateNestedOneWithoutSubAccountInput
    Permissions?: PermissionsCreateNestedManyWithoutSubAcctountInput
    Funnels?: FunnelsCreateNestedManyWithoutSubAccountInput
    Media?: MediaCreateNestedManyWithoutSubAccountsInput
    Contact?: ContactsCreateNestedManyWithoutSubAccountsInput
    Trigger?: TriggersCreateNestedManyWithoutSubAccountsInput
    Automation?: AutomationsCreateNestedManyWithoutSubAccountsInput
    Pipeline?: PipelinesCreateNestedManyWithoutSubAccountInput
    Tags?: TagsCreateNestedManyWithoutSubAccountsInput
    Notification?: NotificationsCreateNestedManyWithoutSubAccountsInput
    SubAccountSidebarOption?: SubAccountSidebarOptionCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountsUncheckedCreateWithoutSidebarOptionInput = {
    id?: string
    connectAccountId?: string | null
    name: string
    subAcctountLogo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    agencyId: string
    Permissions?: PermissionsUncheckedCreateNestedManyWithoutSubAcctountInput
    Funnels?: FunnelsUncheckedCreateNestedManyWithoutSubAccountInput
    Media?: MediaUncheckedCreateNestedManyWithoutSubAccountsInput
    Contact?: ContactsUncheckedCreateNestedManyWithoutSubAccountsInput
    Trigger?: TriggersUncheckedCreateNestedManyWithoutSubAccountsInput
    Automation?: AutomationsUncheckedCreateNestedManyWithoutSubAccountsInput
    Pipeline?: PipelinesUncheckedCreateNestedManyWithoutSubAccountInput
    Tags?: TagsUncheckedCreateNestedManyWithoutSubAccountsInput
    Notification?: NotificationsUncheckedCreateNestedManyWithoutSubAccountsInput
    SubAccountSidebarOption?: SubAccountSidebarOptionUncheckedCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountsCreateOrConnectWithoutSidebarOptionInput = {
    where: SubAccountsWhereUniqueInput
    create: XOR<SubAccountsCreateWithoutSidebarOptionInput, SubAccountsUncheckedCreateWithoutSidebarOptionInput>
  }

  export type AgencyUpsertWithoutSidebarOptionInput = {
    update: XOR<AgencyUpdateWithoutSidebarOptionInput, AgencyUncheckedUpdateWithoutSidebarOptionInput>
    create: XOR<AgencyCreateWithoutSidebarOptionInput, AgencyUncheckedCreateWithoutSidebarOptionInput>
    where?: AgencyWhereInput
  }

  export type AgencyUpdateToOneWithWhereWithoutSidebarOptionInput = {
    where?: AgencyWhereInput
    data: XOR<AgencyUpdateWithoutSidebarOptionInput, AgencyUncheckedUpdateWithoutSidebarOptionInput>
  }

  export type AgencyUpdateWithoutSidebarOptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    agencyLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    whiteLabel?: BoolFieldUpdateOperationsInput | boolean
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateManyWithoutAgencyNestedInput
    SubAccount?: SubAccountsUpdateManyWithoutAgencyNestedInput
    Invitation?: InvitationsUpdateManyWithoutAgencyNestedInput
    Notification?: NotificationsUpdateManyWithoutAgencyNestedInput
    Subscription?: SubscriptionsUpdateOneWithoutAgencyNestedInput
    AddOns?: AddOnsUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateWithoutSidebarOptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    agencyLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    whiteLabel?: BoolFieldUpdateOperationsInput | boolean
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUncheckedUpdateManyWithoutAgencyNestedInput
    SubAccount?: SubAccountsUncheckedUpdateManyWithoutAgencyNestedInput
    Invitation?: InvitationsUncheckedUpdateManyWithoutAgencyNestedInput
    Notification?: NotificationsUncheckedUpdateManyWithoutAgencyNestedInput
    Subscription?: SubscriptionsUncheckedUpdateOneWithoutAgencyNestedInput
    AddOns?: AddOnsUncheckedUpdateManyWithoutAgencyNestedInput
  }

  export type SubAccountsUpsertWithoutSidebarOptionInput = {
    update: XOR<SubAccountsUpdateWithoutSidebarOptionInput, SubAccountsUncheckedUpdateWithoutSidebarOptionInput>
    create: XOR<SubAccountsCreateWithoutSidebarOptionInput, SubAccountsUncheckedCreateWithoutSidebarOptionInput>
    where?: SubAccountsWhereInput
  }

  export type SubAccountsUpdateToOneWithWhereWithoutSidebarOptionInput = {
    where?: SubAccountsWhereInput
    data: XOR<SubAccountsUpdateWithoutSidebarOptionInput, SubAccountsUncheckedUpdateWithoutSidebarOptionInput>
  }

  export type SubAccountsUpdateWithoutSidebarOptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAcctountLogo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    Agency?: AgencyUpdateOneRequiredWithoutSubAccountNestedInput
    Permissions?: PermissionsUpdateManyWithoutSubAcctountNestedInput
    Funnels?: FunnelsUpdateManyWithoutSubAccountNestedInput
    Media?: MediaUpdateManyWithoutSubAccountsNestedInput
    Contact?: ContactsUpdateManyWithoutSubAccountsNestedInput
    Trigger?: TriggersUpdateManyWithoutSubAccountsNestedInput
    Automation?: AutomationsUpdateManyWithoutSubAccountsNestedInput
    Pipeline?: PipelinesUpdateManyWithoutSubAccountNestedInput
    Tags?: TagsUpdateManyWithoutSubAccountsNestedInput
    Notification?: NotificationsUpdateManyWithoutSubAccountsNestedInput
    SubAccountSidebarOption?: SubAccountSidebarOptionUpdateManyWithoutSubAccountNestedInput
  }

  export type SubAccountsUncheckedUpdateWithoutSidebarOptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAcctountLogo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    Permissions?: PermissionsUncheckedUpdateManyWithoutSubAcctountNestedInput
    Funnels?: FunnelsUncheckedUpdateManyWithoutSubAccountNestedInput
    Media?: MediaUncheckedUpdateManyWithoutSubAccountsNestedInput
    Contact?: ContactsUncheckedUpdateManyWithoutSubAccountsNestedInput
    Trigger?: TriggersUncheckedUpdateManyWithoutSubAccountsNestedInput
    Automation?: AutomationsUncheckedUpdateManyWithoutSubAccountsNestedInput
    Pipeline?: PipelinesUncheckedUpdateManyWithoutSubAccountNestedInput
    Tags?: TagsUncheckedUpdateManyWithoutSubAccountsNestedInput
    Notification?: NotificationsUncheckedUpdateManyWithoutSubAccountsNestedInput
    SubAccountSidebarOption?: SubAccountSidebarOptionUncheckedUpdateManyWithoutSubAccountNestedInput
  }

  export type AgencyCreateWithoutSubAccountInput = {
    id?: string
    connectAccountId?: string | null
    customerId?: string
    name: string
    agencyLogo: string
    companyEmail: string
    companyPhone: string
    whiteLabel?: boolean
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    goal: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UsersCreateNestedManyWithoutAgencyInput
    SidebarOption?: AgencySidebarOptionCreateNestedManyWithoutAgencyInput
    Invitation?: InvitationsCreateNestedManyWithoutAgencyInput
    Notification?: NotificationsCreateNestedManyWithoutAgencyInput
    Subscription?: SubscriptionsCreateNestedOneWithoutAgencyInput
    AddOns?: AddOnsCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUncheckedCreateWithoutSubAccountInput = {
    id?: string
    connectAccountId?: string | null
    customerId?: string
    name: string
    agencyLogo: string
    companyEmail: string
    companyPhone: string
    whiteLabel?: boolean
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    goal: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UsersUncheckedCreateNestedManyWithoutAgencyInput
    SidebarOption?: AgencySidebarOptionUncheckedCreateNestedManyWithoutAgencyInput
    Invitation?: InvitationsUncheckedCreateNestedManyWithoutAgencyInput
    Notification?: NotificationsUncheckedCreateNestedManyWithoutAgencyInput
    Subscription?: SubscriptionsUncheckedCreateNestedOneWithoutAgencyInput
    AddOns?: AddOnsUncheckedCreateNestedManyWithoutAgencyInput
  }

  export type AgencyCreateOrConnectWithoutSubAccountInput = {
    where: AgencyWhereUniqueInput
    create: XOR<AgencyCreateWithoutSubAccountInput, AgencyUncheckedCreateWithoutSubAccountInput>
  }

  export type AgencySidebarOptionCreateWithoutSubAccountsInput = {
    id?: string
    name?: string
    link?: string
    icon?: $Enums.Icon
    createdAt?: Date | string
    updatedAt?: Date | string
    Agency: AgencyCreateNestedOneWithoutSidebarOptionInput
  }

  export type AgencySidebarOptionUncheckedCreateWithoutSubAccountsInput = {
    id?: string
    name?: string
    link?: string
    icon?: $Enums.Icon
    createdAt?: Date | string
    updatedAt?: Date | string
    agencyId: string
  }

  export type AgencySidebarOptionCreateOrConnectWithoutSubAccountsInput = {
    where: AgencySidebarOptionWhereUniqueInput
    create: XOR<AgencySidebarOptionCreateWithoutSubAccountsInput, AgencySidebarOptionUncheckedCreateWithoutSubAccountsInput>
  }

  export type AgencySidebarOptionCreateManySubAccountsInputEnvelope = {
    data: AgencySidebarOptionCreateManySubAccountsInput | AgencySidebarOptionCreateManySubAccountsInput[]
    skipDuplicates?: boolean
  }

  export type PermissionsCreateWithoutSubAcctountInput = {
    id?: string
    access: boolean
    Users: UsersCreateNestedOneWithoutPermissionInput
  }

  export type PermissionsUncheckedCreateWithoutSubAcctountInput = {
    id?: string
    email: string
    access: boolean
  }

  export type PermissionsCreateOrConnectWithoutSubAcctountInput = {
    where: PermissionsWhereUniqueInput
    create: XOR<PermissionsCreateWithoutSubAcctountInput, PermissionsUncheckedCreateWithoutSubAcctountInput>
  }

  export type PermissionsCreateManySubAcctountInputEnvelope = {
    data: PermissionsCreateManySubAcctountInput | PermissionsCreateManySubAcctountInput[]
    skipDuplicates?: boolean
  }

  export type FunnelsCreateWithoutSubAccountInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    published?: boolean
    subDomainName?: string | null
    favicon?: string | null
    liveProducts?: string | null
    FunelPages?: FunelPagesCreateNestedManyWithoutFunnelInput
    className?: ClassNameCreateNestedManyWithoutFunnelInput
  }

  export type FunnelsUncheckedCreateWithoutSubAccountInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    published?: boolean
    subDomainName?: string | null
    favicon?: string | null
    liveProducts?: string | null
    FunelPages?: FunelPagesUncheckedCreateNestedManyWithoutFunnelInput
    className?: ClassNameUncheckedCreateNestedManyWithoutFunnelInput
  }

  export type FunnelsCreateOrConnectWithoutSubAccountInput = {
    where: FunnelsWhereUniqueInput
    create: XOR<FunnelsCreateWithoutSubAccountInput, FunnelsUncheckedCreateWithoutSubAccountInput>
  }

  export type FunnelsCreateManySubAccountInputEnvelope = {
    data: FunnelsCreateManySubAccountInput | FunnelsCreateManySubAccountInput[]
    skipDuplicates?: boolean
  }

  export type MediaCreateWithoutSubAccountsInput = {
    id?: string
    type?: string | null
    name: string
    link: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MediaUncheckedCreateWithoutSubAccountsInput = {
    id?: string
    type?: string | null
    name: string
    link: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MediaCreateOrConnectWithoutSubAccountsInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutSubAccountsInput, MediaUncheckedCreateWithoutSubAccountsInput>
  }

  export type MediaCreateManySubAccountsInputEnvelope = {
    data: MediaCreateManySubAccountsInput | MediaCreateManySubAccountsInput[]
    skipDuplicates?: boolean
  }

  export type ContactsCreateWithoutSubAccountsInput = {
    id?: string
    name: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Tickets?: TicketsCreateNestedManyWithoutContactsInput
  }

  export type ContactsUncheckedCreateWithoutSubAccountsInput = {
    id?: string
    name: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Tickets?: TicketsUncheckedCreateNestedManyWithoutContactsInput
  }

  export type ContactsCreateOrConnectWithoutSubAccountsInput = {
    where: ContactsWhereUniqueInput
    create: XOR<ContactsCreateWithoutSubAccountsInput, ContactsUncheckedCreateWithoutSubAccountsInput>
  }

  export type ContactsCreateManySubAccountsInputEnvelope = {
    data: ContactsCreateManySubAccountsInput | ContactsCreateManySubAccountsInput[]
    skipDuplicates?: boolean
  }

  export type TriggersCreateWithoutSubAccountsInput = {
    id?: string
    name: string
    type: $Enums.TriggerTypes
    createdAt?: Date | string
    updatedAt?: Date | string
    Automations?: AutomationsCreateNestedManyWithoutTriggerInput
  }

  export type TriggersUncheckedCreateWithoutSubAccountsInput = {
    id?: string
    name: string
    type: $Enums.TriggerTypes
    createdAt?: Date | string
    updatedAt?: Date | string
    Automations?: AutomationsUncheckedCreateNestedManyWithoutTriggerInput
  }

  export type TriggersCreateOrConnectWithoutSubAccountsInput = {
    where: TriggersWhereUniqueInput
    create: XOR<TriggersCreateWithoutSubAccountsInput, TriggersUncheckedCreateWithoutSubAccountsInput>
  }

  export type TriggersCreateManySubAccountsInputEnvelope = {
    data: TriggersCreateManySubAccountsInput | TriggersCreateManySubAccountsInput[]
    skipDuplicates?: boolean
  }

  export type AutomationsCreateWithoutSubAccountsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    published?: boolean
    Trigger?: TriggersCreateNestedOneWithoutAutomationsInput
    Actions?: ActionsCreateNestedManyWithoutAutomationsInput
    AutomationInstance?: AutomationInstanceCreateNestedManyWithoutAutomationsInput
  }

  export type AutomationsUncheckedCreateWithoutSubAccountsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    triggerId?: string | null
    published?: boolean
    Actions?: ActionsUncheckedCreateNestedManyWithoutAutomationsInput
    AutomationInstance?: AutomationInstanceUncheckedCreateNestedManyWithoutAutomationsInput
  }

  export type AutomationsCreateOrConnectWithoutSubAccountsInput = {
    where: AutomationsWhereUniqueInput
    create: XOR<AutomationsCreateWithoutSubAccountsInput, AutomationsUncheckedCreateWithoutSubAccountsInput>
  }

  export type AutomationsCreateManySubAccountsInputEnvelope = {
    data: AutomationsCreateManySubAccountsInput | AutomationsCreateManySubAccountsInput[]
    skipDuplicates?: boolean
  }

  export type PipelinesCreateWithoutSubAccountInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Lane?: LaneCreateNestedManyWithoutPipelineInput
  }

  export type PipelinesUncheckedCreateWithoutSubAccountInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Lane?: LaneUncheckedCreateNestedManyWithoutPipelineInput
  }

  export type PipelinesCreateOrConnectWithoutSubAccountInput = {
    where: PipelinesWhereUniqueInput
    create: XOR<PipelinesCreateWithoutSubAccountInput, PipelinesUncheckedCreateWithoutSubAccountInput>
  }

  export type PipelinesCreateManySubAccountInputEnvelope = {
    data: PipelinesCreateManySubAccountInput | PipelinesCreateManySubAccountInput[]
    skipDuplicates?: boolean
  }

  export type TagsCreateWithoutSubAccountsInput = {
    id?: string
    nane: string
    color: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Tickets?: TicketsCreateNestedManyWithoutTagsInput
  }

  export type TagsUncheckedCreateWithoutSubAccountsInput = {
    id?: string
    nane: string
    color: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Tickets?: TicketsUncheckedCreateNestedManyWithoutTagsInput
  }

  export type TagsCreateOrConnectWithoutSubAccountsInput = {
    where: TagsWhereUniqueInput
    create: XOR<TagsCreateWithoutSubAccountsInput, TagsUncheckedCreateWithoutSubAccountsInput>
  }

  export type TagsCreateManySubAccountsInputEnvelope = {
    data: TagsCreateManySubAccountsInput | TagsCreateManySubAccountsInput[]
    skipDuplicates?: boolean
  }

  export type NotificationsCreateWithoutSubAccountsInput = {
    id?: string
    notification: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Users: UsersCreateNestedOneWithoutNotificationInput
    Agency: AgencyCreateNestedOneWithoutNotificationInput
  }

  export type NotificationsUncheckedCreateWithoutSubAccountsInput = {
    id?: string
    notification: string
    agencyId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationsCreateOrConnectWithoutSubAccountsInput = {
    where: NotificationsWhereUniqueInput
    create: XOR<NotificationsCreateWithoutSubAccountsInput, NotificationsUncheckedCreateWithoutSubAccountsInput>
  }

  export type NotificationsCreateManySubAccountsInputEnvelope = {
    data: NotificationsCreateManySubAccountsInput | NotificationsCreateManySubAccountsInput[]
    skipDuplicates?: boolean
  }

  export type SubAccountSidebarOptionCreateWithoutSubAccountInput = {
    id?: string
    name: string
    link?: string
    icon?: $Enums.Icon
    createdAt?: Date | string
    updatedAt?: Date | string
    subAccount?: string | null
  }

  export type SubAccountSidebarOptionUncheckedCreateWithoutSubAccountInput = {
    id?: string
    name: string
    link?: string
    icon?: $Enums.Icon
    createdAt?: Date | string
    updatedAt?: Date | string
    subAccount?: string | null
  }

  export type SubAccountSidebarOptionCreateOrConnectWithoutSubAccountInput = {
    where: SubAccountSidebarOptionWhereUniqueInput
    create: XOR<SubAccountSidebarOptionCreateWithoutSubAccountInput, SubAccountSidebarOptionUncheckedCreateWithoutSubAccountInput>
  }

  export type SubAccountSidebarOptionCreateManySubAccountInputEnvelope = {
    data: SubAccountSidebarOptionCreateManySubAccountInput | SubAccountSidebarOptionCreateManySubAccountInput[]
    skipDuplicates?: boolean
  }

  export type AgencyUpsertWithoutSubAccountInput = {
    update: XOR<AgencyUpdateWithoutSubAccountInput, AgencyUncheckedUpdateWithoutSubAccountInput>
    create: XOR<AgencyCreateWithoutSubAccountInput, AgencyUncheckedCreateWithoutSubAccountInput>
    where?: AgencyWhereInput
  }

  export type AgencyUpdateToOneWithWhereWithoutSubAccountInput = {
    where?: AgencyWhereInput
    data: XOR<AgencyUpdateWithoutSubAccountInput, AgencyUncheckedUpdateWithoutSubAccountInput>
  }

  export type AgencyUpdateWithoutSubAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    agencyLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    whiteLabel?: BoolFieldUpdateOperationsInput | boolean
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateManyWithoutAgencyNestedInput
    SidebarOption?: AgencySidebarOptionUpdateManyWithoutAgencyNestedInput
    Invitation?: InvitationsUpdateManyWithoutAgencyNestedInput
    Notification?: NotificationsUpdateManyWithoutAgencyNestedInput
    Subscription?: SubscriptionsUpdateOneWithoutAgencyNestedInput
    AddOns?: AddOnsUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateWithoutSubAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    agencyLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    whiteLabel?: BoolFieldUpdateOperationsInput | boolean
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUncheckedUpdateManyWithoutAgencyNestedInput
    SidebarOption?: AgencySidebarOptionUncheckedUpdateManyWithoutAgencyNestedInput
    Invitation?: InvitationsUncheckedUpdateManyWithoutAgencyNestedInput
    Notification?: NotificationsUncheckedUpdateManyWithoutAgencyNestedInput
    Subscription?: SubscriptionsUncheckedUpdateOneWithoutAgencyNestedInput
    AddOns?: AddOnsUncheckedUpdateManyWithoutAgencyNestedInput
  }

  export type AgencySidebarOptionUpsertWithWhereUniqueWithoutSubAccountsInput = {
    where: AgencySidebarOptionWhereUniqueInput
    update: XOR<AgencySidebarOptionUpdateWithoutSubAccountsInput, AgencySidebarOptionUncheckedUpdateWithoutSubAccountsInput>
    create: XOR<AgencySidebarOptionCreateWithoutSubAccountsInput, AgencySidebarOptionUncheckedCreateWithoutSubAccountsInput>
  }

  export type AgencySidebarOptionUpdateWithWhereUniqueWithoutSubAccountsInput = {
    where: AgencySidebarOptionWhereUniqueInput
    data: XOR<AgencySidebarOptionUpdateWithoutSubAccountsInput, AgencySidebarOptionUncheckedUpdateWithoutSubAccountsInput>
  }

  export type AgencySidebarOptionUpdateManyWithWhereWithoutSubAccountsInput = {
    where: AgencySidebarOptionScalarWhereInput
    data: XOR<AgencySidebarOptionUpdateManyMutationInput, AgencySidebarOptionUncheckedUpdateManyWithoutSubAccountsInput>
  }

  export type PermissionsUpsertWithWhereUniqueWithoutSubAcctountInput = {
    where: PermissionsWhereUniqueInput
    update: XOR<PermissionsUpdateWithoutSubAcctountInput, PermissionsUncheckedUpdateWithoutSubAcctountInput>
    create: XOR<PermissionsCreateWithoutSubAcctountInput, PermissionsUncheckedCreateWithoutSubAcctountInput>
  }

  export type PermissionsUpdateWithWhereUniqueWithoutSubAcctountInput = {
    where: PermissionsWhereUniqueInput
    data: XOR<PermissionsUpdateWithoutSubAcctountInput, PermissionsUncheckedUpdateWithoutSubAcctountInput>
  }

  export type PermissionsUpdateManyWithWhereWithoutSubAcctountInput = {
    where: PermissionsScalarWhereInput
    data: XOR<PermissionsUpdateManyMutationInput, PermissionsUncheckedUpdateManyWithoutSubAcctountInput>
  }

  export type FunnelsUpsertWithWhereUniqueWithoutSubAccountInput = {
    where: FunnelsWhereUniqueInput
    update: XOR<FunnelsUpdateWithoutSubAccountInput, FunnelsUncheckedUpdateWithoutSubAccountInput>
    create: XOR<FunnelsCreateWithoutSubAccountInput, FunnelsUncheckedCreateWithoutSubAccountInput>
  }

  export type FunnelsUpdateWithWhereUniqueWithoutSubAccountInput = {
    where: FunnelsWhereUniqueInput
    data: XOR<FunnelsUpdateWithoutSubAccountInput, FunnelsUncheckedUpdateWithoutSubAccountInput>
  }

  export type FunnelsUpdateManyWithWhereWithoutSubAccountInput = {
    where: FunnelsScalarWhereInput
    data: XOR<FunnelsUpdateManyMutationInput, FunnelsUncheckedUpdateManyWithoutSubAccountInput>
  }

  export type FunnelsScalarWhereInput = {
    AND?: FunnelsScalarWhereInput | FunnelsScalarWhereInput[]
    OR?: FunnelsScalarWhereInput[]
    NOT?: FunnelsScalarWhereInput | FunnelsScalarWhereInput[]
    id?: StringFilter<"Funnels"> | string
    name?: StringFilter<"Funnels"> | string
    createdAt?: DateTimeFilter<"Funnels"> | Date | string
    updatedAt?: DateTimeFilter<"Funnels"> | Date | string
    description?: StringNullableFilter<"Funnels"> | string | null
    published?: BoolFilter<"Funnels"> | boolean
    subDomainName?: StringNullableFilter<"Funnels"> | string | null
    favicon?: StringNullableFilter<"Funnels"> | string | null
    subAccountId?: StringFilter<"Funnels"> | string
    liveProducts?: StringNullableFilter<"Funnels"> | string | null
  }

  export type MediaUpsertWithWhereUniqueWithoutSubAccountsInput = {
    where: MediaWhereUniqueInput
    update: XOR<MediaUpdateWithoutSubAccountsInput, MediaUncheckedUpdateWithoutSubAccountsInput>
    create: XOR<MediaCreateWithoutSubAccountsInput, MediaUncheckedCreateWithoutSubAccountsInput>
  }

  export type MediaUpdateWithWhereUniqueWithoutSubAccountsInput = {
    where: MediaWhereUniqueInput
    data: XOR<MediaUpdateWithoutSubAccountsInput, MediaUncheckedUpdateWithoutSubAccountsInput>
  }

  export type MediaUpdateManyWithWhereWithoutSubAccountsInput = {
    where: MediaScalarWhereInput
    data: XOR<MediaUpdateManyMutationInput, MediaUncheckedUpdateManyWithoutSubAccountsInput>
  }

  export type MediaScalarWhereInput = {
    AND?: MediaScalarWhereInput | MediaScalarWhereInput[]
    OR?: MediaScalarWhereInput[]
    NOT?: MediaScalarWhereInput | MediaScalarWhereInput[]
    id?: StringFilter<"Media"> | string
    type?: StringNullableFilter<"Media"> | string | null
    name?: StringFilter<"Media"> | string
    link?: StringFilter<"Media"> | string
    subAccountId?: StringFilter<"Media"> | string
    createdAt?: DateTimeFilter<"Media"> | Date | string
    updatedAt?: DateTimeFilter<"Media"> | Date | string
  }

  export type ContactsUpsertWithWhereUniqueWithoutSubAccountsInput = {
    where: ContactsWhereUniqueInput
    update: XOR<ContactsUpdateWithoutSubAccountsInput, ContactsUncheckedUpdateWithoutSubAccountsInput>
    create: XOR<ContactsCreateWithoutSubAccountsInput, ContactsUncheckedCreateWithoutSubAccountsInput>
  }

  export type ContactsUpdateWithWhereUniqueWithoutSubAccountsInput = {
    where: ContactsWhereUniqueInput
    data: XOR<ContactsUpdateWithoutSubAccountsInput, ContactsUncheckedUpdateWithoutSubAccountsInput>
  }

  export type ContactsUpdateManyWithWhereWithoutSubAccountsInput = {
    where: ContactsScalarWhereInput
    data: XOR<ContactsUpdateManyMutationInput, ContactsUncheckedUpdateManyWithoutSubAccountsInput>
  }

  export type ContactsScalarWhereInput = {
    AND?: ContactsScalarWhereInput | ContactsScalarWhereInput[]
    OR?: ContactsScalarWhereInput[]
    NOT?: ContactsScalarWhereInput | ContactsScalarWhereInput[]
    id?: StringFilter<"Contacts"> | string
    name?: StringFilter<"Contacts"> | string
    email?: StringFilter<"Contacts"> | string
    createdAt?: DateTimeFilter<"Contacts"> | Date | string
    updatedAt?: DateTimeFilter<"Contacts"> | Date | string
    subAccountId?: StringFilter<"Contacts"> | string
  }

  export type TriggersUpsertWithWhereUniqueWithoutSubAccountsInput = {
    where: TriggersWhereUniqueInput
    update: XOR<TriggersUpdateWithoutSubAccountsInput, TriggersUncheckedUpdateWithoutSubAccountsInput>
    create: XOR<TriggersCreateWithoutSubAccountsInput, TriggersUncheckedCreateWithoutSubAccountsInput>
  }

  export type TriggersUpdateWithWhereUniqueWithoutSubAccountsInput = {
    where: TriggersWhereUniqueInput
    data: XOR<TriggersUpdateWithoutSubAccountsInput, TriggersUncheckedUpdateWithoutSubAccountsInput>
  }

  export type TriggersUpdateManyWithWhereWithoutSubAccountsInput = {
    where: TriggersScalarWhereInput
    data: XOR<TriggersUpdateManyMutationInput, TriggersUncheckedUpdateManyWithoutSubAccountsInput>
  }

  export type TriggersScalarWhereInput = {
    AND?: TriggersScalarWhereInput | TriggersScalarWhereInput[]
    OR?: TriggersScalarWhereInput[]
    NOT?: TriggersScalarWhereInput | TriggersScalarWhereInput[]
    id?: StringFilter<"Triggers"> | string
    name?: StringFilter<"Triggers"> | string
    type?: EnumTriggerTypesFilter<"Triggers"> | $Enums.TriggerTypes
    createdAt?: DateTimeFilter<"Triggers"> | Date | string
    updatedAt?: DateTimeFilter<"Triggers"> | Date | string
    subAccountId?: StringFilter<"Triggers"> | string
  }

  export type AutomationsUpsertWithWhereUniqueWithoutSubAccountsInput = {
    where: AutomationsWhereUniqueInput
    update: XOR<AutomationsUpdateWithoutSubAccountsInput, AutomationsUncheckedUpdateWithoutSubAccountsInput>
    create: XOR<AutomationsCreateWithoutSubAccountsInput, AutomationsUncheckedCreateWithoutSubAccountsInput>
  }

  export type AutomationsUpdateWithWhereUniqueWithoutSubAccountsInput = {
    where: AutomationsWhereUniqueInput
    data: XOR<AutomationsUpdateWithoutSubAccountsInput, AutomationsUncheckedUpdateWithoutSubAccountsInput>
  }

  export type AutomationsUpdateManyWithWhereWithoutSubAccountsInput = {
    where: AutomationsScalarWhereInput
    data: XOR<AutomationsUpdateManyMutationInput, AutomationsUncheckedUpdateManyWithoutSubAccountsInput>
  }

  export type AutomationsScalarWhereInput = {
    AND?: AutomationsScalarWhereInput | AutomationsScalarWhereInput[]
    OR?: AutomationsScalarWhereInput[]
    NOT?: AutomationsScalarWhereInput | AutomationsScalarWhereInput[]
    id?: StringFilter<"Automations"> | string
    name?: StringFilter<"Automations"> | string
    createdAt?: DateTimeFilter<"Automations"> | Date | string
    updatedAt?: DateTimeFilter<"Automations"> | Date | string
    triggerId?: StringNullableFilter<"Automations"> | string | null
    published?: BoolFilter<"Automations"> | boolean
    subAccountId?: StringFilter<"Automations"> | string
  }

  export type PipelinesUpsertWithWhereUniqueWithoutSubAccountInput = {
    where: PipelinesWhereUniqueInput
    update: XOR<PipelinesUpdateWithoutSubAccountInput, PipelinesUncheckedUpdateWithoutSubAccountInput>
    create: XOR<PipelinesCreateWithoutSubAccountInput, PipelinesUncheckedCreateWithoutSubAccountInput>
  }

  export type PipelinesUpdateWithWhereUniqueWithoutSubAccountInput = {
    where: PipelinesWhereUniqueInput
    data: XOR<PipelinesUpdateWithoutSubAccountInput, PipelinesUncheckedUpdateWithoutSubAccountInput>
  }

  export type PipelinesUpdateManyWithWhereWithoutSubAccountInput = {
    where: PipelinesScalarWhereInput
    data: XOR<PipelinesUpdateManyMutationInput, PipelinesUncheckedUpdateManyWithoutSubAccountInput>
  }

  export type PipelinesScalarWhereInput = {
    AND?: PipelinesScalarWhereInput | PipelinesScalarWhereInput[]
    OR?: PipelinesScalarWhereInput[]
    NOT?: PipelinesScalarWhereInput | PipelinesScalarWhereInput[]
    id?: StringFilter<"Pipelines"> | string
    name?: StringFilter<"Pipelines"> | string
    createdAt?: DateTimeFilter<"Pipelines"> | Date | string
    updatedAt?: DateTimeFilter<"Pipelines"> | Date | string
    subAccountId?: StringFilter<"Pipelines"> | string
  }

  export type TagsUpsertWithWhereUniqueWithoutSubAccountsInput = {
    where: TagsWhereUniqueInput
    update: XOR<TagsUpdateWithoutSubAccountsInput, TagsUncheckedUpdateWithoutSubAccountsInput>
    create: XOR<TagsCreateWithoutSubAccountsInput, TagsUncheckedCreateWithoutSubAccountsInput>
  }

  export type TagsUpdateWithWhereUniqueWithoutSubAccountsInput = {
    where: TagsWhereUniqueInput
    data: XOR<TagsUpdateWithoutSubAccountsInput, TagsUncheckedUpdateWithoutSubAccountsInput>
  }

  export type TagsUpdateManyWithWhereWithoutSubAccountsInput = {
    where: TagsScalarWhereInput
    data: XOR<TagsUpdateManyMutationInput, TagsUncheckedUpdateManyWithoutSubAccountsInput>
  }

  export type TagsScalarWhereInput = {
    AND?: TagsScalarWhereInput | TagsScalarWhereInput[]
    OR?: TagsScalarWhereInput[]
    NOT?: TagsScalarWhereInput | TagsScalarWhereInput[]
    id?: StringFilter<"Tags"> | string
    nane?: StringFilter<"Tags"> | string
    color?: StringFilter<"Tags"> | string
    createdAt?: DateTimeFilter<"Tags"> | Date | string
    updatedAt?: DateTimeFilter<"Tags"> | Date | string
    subAccountId?: StringFilter<"Tags"> | string
  }

  export type NotificationsUpsertWithWhereUniqueWithoutSubAccountsInput = {
    where: NotificationsWhereUniqueInput
    update: XOR<NotificationsUpdateWithoutSubAccountsInput, NotificationsUncheckedUpdateWithoutSubAccountsInput>
    create: XOR<NotificationsCreateWithoutSubAccountsInput, NotificationsUncheckedCreateWithoutSubAccountsInput>
  }

  export type NotificationsUpdateWithWhereUniqueWithoutSubAccountsInput = {
    where: NotificationsWhereUniqueInput
    data: XOR<NotificationsUpdateWithoutSubAccountsInput, NotificationsUncheckedUpdateWithoutSubAccountsInput>
  }

  export type NotificationsUpdateManyWithWhereWithoutSubAccountsInput = {
    where: NotificationsScalarWhereInput
    data: XOR<NotificationsUpdateManyMutationInput, NotificationsUncheckedUpdateManyWithoutSubAccountsInput>
  }

  export type SubAccountSidebarOptionUpsertWithWhereUniqueWithoutSubAccountInput = {
    where: SubAccountSidebarOptionWhereUniqueInput
    update: XOR<SubAccountSidebarOptionUpdateWithoutSubAccountInput, SubAccountSidebarOptionUncheckedUpdateWithoutSubAccountInput>
    create: XOR<SubAccountSidebarOptionCreateWithoutSubAccountInput, SubAccountSidebarOptionUncheckedCreateWithoutSubAccountInput>
  }

  export type SubAccountSidebarOptionUpdateWithWhereUniqueWithoutSubAccountInput = {
    where: SubAccountSidebarOptionWhereUniqueInput
    data: XOR<SubAccountSidebarOptionUpdateWithoutSubAccountInput, SubAccountSidebarOptionUncheckedUpdateWithoutSubAccountInput>
  }

  export type SubAccountSidebarOptionUpdateManyWithWhereWithoutSubAccountInput = {
    where: SubAccountSidebarOptionScalarWhereInput
    data: XOR<SubAccountSidebarOptionUpdateManyMutationInput, SubAccountSidebarOptionUncheckedUpdateManyWithoutSubAccountInput>
  }

  export type SubAccountSidebarOptionScalarWhereInput = {
    AND?: SubAccountSidebarOptionScalarWhereInput | SubAccountSidebarOptionScalarWhereInput[]
    OR?: SubAccountSidebarOptionScalarWhereInput[]
    NOT?: SubAccountSidebarOptionScalarWhereInput | SubAccountSidebarOptionScalarWhereInput[]
    id?: StringFilter<"SubAccountSidebarOption"> | string
    name?: StringFilter<"SubAccountSidebarOption"> | string
    link?: StringFilter<"SubAccountSidebarOption"> | string
    icon?: EnumIconFilter<"SubAccountSidebarOption"> | $Enums.Icon
    createdAt?: DateTimeFilter<"SubAccountSidebarOption"> | Date | string
    updatedAt?: DateTimeFilter<"SubAccountSidebarOption"> | Date | string
    subAccountId?: StringFilter<"SubAccountSidebarOption"> | string
    subAccount?: StringNullableFilter<"SubAccountSidebarOption"> | string | null
  }

  export type LaneCreateWithoutPipelineInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: number
    Tickets?: TicketsCreateNestedManyWithoutLaneInput
  }

  export type LaneUncheckedCreateWithoutPipelineInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: number
    Tickets?: TicketsUncheckedCreateNestedManyWithoutLaneInput
  }

  export type LaneCreateOrConnectWithoutPipelineInput = {
    where: LaneWhereUniqueInput
    create: XOR<LaneCreateWithoutPipelineInput, LaneUncheckedCreateWithoutPipelineInput>
  }

  export type LaneCreateManyPipelineInputEnvelope = {
    data: LaneCreateManyPipelineInput | LaneCreateManyPipelineInput[]
    skipDuplicates?: boolean
  }

  export type SubAccountsCreateWithoutPipelineInput = {
    id?: string
    connectAccountId?: string | null
    name: string
    subAcctountLogo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    Agency: AgencyCreateNestedOneWithoutSubAccountInput
    SidebarOption?: AgencySidebarOptionCreateNestedManyWithoutSubAccountsInput
    Permissions?: PermissionsCreateNestedManyWithoutSubAcctountInput
    Funnels?: FunnelsCreateNestedManyWithoutSubAccountInput
    Media?: MediaCreateNestedManyWithoutSubAccountsInput
    Contact?: ContactsCreateNestedManyWithoutSubAccountsInput
    Trigger?: TriggersCreateNestedManyWithoutSubAccountsInput
    Automation?: AutomationsCreateNestedManyWithoutSubAccountsInput
    Tags?: TagsCreateNestedManyWithoutSubAccountsInput
    Notification?: NotificationsCreateNestedManyWithoutSubAccountsInput
    SubAccountSidebarOption?: SubAccountSidebarOptionCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountsUncheckedCreateWithoutPipelineInput = {
    id?: string
    connectAccountId?: string | null
    name: string
    subAcctountLogo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    agencyId: string
    SidebarOption?: AgencySidebarOptionUncheckedCreateNestedManyWithoutSubAccountsInput
    Permissions?: PermissionsUncheckedCreateNestedManyWithoutSubAcctountInput
    Funnels?: FunnelsUncheckedCreateNestedManyWithoutSubAccountInput
    Media?: MediaUncheckedCreateNestedManyWithoutSubAccountsInput
    Contact?: ContactsUncheckedCreateNestedManyWithoutSubAccountsInput
    Trigger?: TriggersUncheckedCreateNestedManyWithoutSubAccountsInput
    Automation?: AutomationsUncheckedCreateNestedManyWithoutSubAccountsInput
    Tags?: TagsUncheckedCreateNestedManyWithoutSubAccountsInput
    Notification?: NotificationsUncheckedCreateNestedManyWithoutSubAccountsInput
    SubAccountSidebarOption?: SubAccountSidebarOptionUncheckedCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountsCreateOrConnectWithoutPipelineInput = {
    where: SubAccountsWhereUniqueInput
    create: XOR<SubAccountsCreateWithoutPipelineInput, SubAccountsUncheckedCreateWithoutPipelineInput>
  }

  export type LaneUpsertWithWhereUniqueWithoutPipelineInput = {
    where: LaneWhereUniqueInput
    update: XOR<LaneUpdateWithoutPipelineInput, LaneUncheckedUpdateWithoutPipelineInput>
    create: XOR<LaneCreateWithoutPipelineInput, LaneUncheckedCreateWithoutPipelineInput>
  }

  export type LaneUpdateWithWhereUniqueWithoutPipelineInput = {
    where: LaneWhereUniqueInput
    data: XOR<LaneUpdateWithoutPipelineInput, LaneUncheckedUpdateWithoutPipelineInput>
  }

  export type LaneUpdateManyWithWhereWithoutPipelineInput = {
    where: LaneScalarWhereInput
    data: XOR<LaneUpdateManyMutationInput, LaneUncheckedUpdateManyWithoutPipelineInput>
  }

  export type LaneScalarWhereInput = {
    AND?: LaneScalarWhereInput | LaneScalarWhereInput[]
    OR?: LaneScalarWhereInput[]
    NOT?: LaneScalarWhereInput | LaneScalarWhereInput[]
    id?: StringFilter<"Lane"> | string
    name?: StringFilter<"Lane"> | string
    createdAt?: DateTimeFilter<"Lane"> | Date | string
    updatedAt?: DateTimeFilter<"Lane"> | Date | string
    pipelineId?: StringFilter<"Lane"> | string
    order?: IntFilter<"Lane"> | number
  }

  export type SubAccountsUpsertWithoutPipelineInput = {
    update: XOR<SubAccountsUpdateWithoutPipelineInput, SubAccountsUncheckedUpdateWithoutPipelineInput>
    create: XOR<SubAccountsCreateWithoutPipelineInput, SubAccountsUncheckedCreateWithoutPipelineInput>
    where?: SubAccountsWhereInput
  }

  export type SubAccountsUpdateToOneWithWhereWithoutPipelineInput = {
    where?: SubAccountsWhereInput
    data: XOR<SubAccountsUpdateWithoutPipelineInput, SubAccountsUncheckedUpdateWithoutPipelineInput>
  }

  export type SubAccountsUpdateWithoutPipelineInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAcctountLogo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    Agency?: AgencyUpdateOneRequiredWithoutSubAccountNestedInput
    SidebarOption?: AgencySidebarOptionUpdateManyWithoutSubAccountsNestedInput
    Permissions?: PermissionsUpdateManyWithoutSubAcctountNestedInput
    Funnels?: FunnelsUpdateManyWithoutSubAccountNestedInput
    Media?: MediaUpdateManyWithoutSubAccountsNestedInput
    Contact?: ContactsUpdateManyWithoutSubAccountsNestedInput
    Trigger?: TriggersUpdateManyWithoutSubAccountsNestedInput
    Automation?: AutomationsUpdateManyWithoutSubAccountsNestedInput
    Tags?: TagsUpdateManyWithoutSubAccountsNestedInput
    Notification?: NotificationsUpdateManyWithoutSubAccountsNestedInput
    SubAccountSidebarOption?: SubAccountSidebarOptionUpdateManyWithoutSubAccountNestedInput
  }

  export type SubAccountsUncheckedUpdateWithoutPipelineInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAcctountLogo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    SidebarOption?: AgencySidebarOptionUncheckedUpdateManyWithoutSubAccountsNestedInput
    Permissions?: PermissionsUncheckedUpdateManyWithoutSubAcctountNestedInput
    Funnels?: FunnelsUncheckedUpdateManyWithoutSubAccountNestedInput
    Media?: MediaUncheckedUpdateManyWithoutSubAccountsNestedInput
    Contact?: ContactsUncheckedUpdateManyWithoutSubAccountsNestedInput
    Trigger?: TriggersUncheckedUpdateManyWithoutSubAccountsNestedInput
    Automation?: AutomationsUncheckedUpdateManyWithoutSubAccountsNestedInput
    Tags?: TagsUncheckedUpdateManyWithoutSubAccountsNestedInput
    Notification?: NotificationsUncheckedUpdateManyWithoutSubAccountsNestedInput
    SubAccountSidebarOption?: SubAccountSidebarOptionUncheckedUpdateManyWithoutSubAccountNestedInput
  }

  export type SubAccountsCreateWithoutTriggerInput = {
    id?: string
    connectAccountId?: string | null
    name: string
    subAcctountLogo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    Agency: AgencyCreateNestedOneWithoutSubAccountInput
    SidebarOption?: AgencySidebarOptionCreateNestedManyWithoutSubAccountsInput
    Permissions?: PermissionsCreateNestedManyWithoutSubAcctountInput
    Funnels?: FunnelsCreateNestedManyWithoutSubAccountInput
    Media?: MediaCreateNestedManyWithoutSubAccountsInput
    Contact?: ContactsCreateNestedManyWithoutSubAccountsInput
    Automation?: AutomationsCreateNestedManyWithoutSubAccountsInput
    Pipeline?: PipelinesCreateNestedManyWithoutSubAccountInput
    Tags?: TagsCreateNestedManyWithoutSubAccountsInput
    Notification?: NotificationsCreateNestedManyWithoutSubAccountsInput
    SubAccountSidebarOption?: SubAccountSidebarOptionCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountsUncheckedCreateWithoutTriggerInput = {
    id?: string
    connectAccountId?: string | null
    name: string
    subAcctountLogo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    agencyId: string
    SidebarOption?: AgencySidebarOptionUncheckedCreateNestedManyWithoutSubAccountsInput
    Permissions?: PermissionsUncheckedCreateNestedManyWithoutSubAcctountInput
    Funnels?: FunnelsUncheckedCreateNestedManyWithoutSubAccountInput
    Media?: MediaUncheckedCreateNestedManyWithoutSubAccountsInput
    Contact?: ContactsUncheckedCreateNestedManyWithoutSubAccountsInput
    Automation?: AutomationsUncheckedCreateNestedManyWithoutSubAccountsInput
    Pipeline?: PipelinesUncheckedCreateNestedManyWithoutSubAccountInput
    Tags?: TagsUncheckedCreateNestedManyWithoutSubAccountsInput
    Notification?: NotificationsUncheckedCreateNestedManyWithoutSubAccountsInput
    SubAccountSidebarOption?: SubAccountSidebarOptionUncheckedCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountsCreateOrConnectWithoutTriggerInput = {
    where: SubAccountsWhereUniqueInput
    create: XOR<SubAccountsCreateWithoutTriggerInput, SubAccountsUncheckedCreateWithoutTriggerInput>
  }

  export type AutomationsCreateWithoutTriggerInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    published?: boolean
    SubAccounts: SubAccountsCreateNestedOneWithoutAutomationInput
    Actions?: ActionsCreateNestedManyWithoutAutomationsInput
    AutomationInstance?: AutomationInstanceCreateNestedManyWithoutAutomationsInput
  }

  export type AutomationsUncheckedCreateWithoutTriggerInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    published?: boolean
    subAccountId: string
    Actions?: ActionsUncheckedCreateNestedManyWithoutAutomationsInput
    AutomationInstance?: AutomationInstanceUncheckedCreateNestedManyWithoutAutomationsInput
  }

  export type AutomationsCreateOrConnectWithoutTriggerInput = {
    where: AutomationsWhereUniqueInput
    create: XOR<AutomationsCreateWithoutTriggerInput, AutomationsUncheckedCreateWithoutTriggerInput>
  }

  export type AutomationsCreateManyTriggerInputEnvelope = {
    data: AutomationsCreateManyTriggerInput | AutomationsCreateManyTriggerInput[]
    skipDuplicates?: boolean
  }

  export type SubAccountsUpsertWithoutTriggerInput = {
    update: XOR<SubAccountsUpdateWithoutTriggerInput, SubAccountsUncheckedUpdateWithoutTriggerInput>
    create: XOR<SubAccountsCreateWithoutTriggerInput, SubAccountsUncheckedCreateWithoutTriggerInput>
    where?: SubAccountsWhereInput
  }

  export type SubAccountsUpdateToOneWithWhereWithoutTriggerInput = {
    where?: SubAccountsWhereInput
    data: XOR<SubAccountsUpdateWithoutTriggerInput, SubAccountsUncheckedUpdateWithoutTriggerInput>
  }

  export type SubAccountsUpdateWithoutTriggerInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAcctountLogo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    Agency?: AgencyUpdateOneRequiredWithoutSubAccountNestedInput
    SidebarOption?: AgencySidebarOptionUpdateManyWithoutSubAccountsNestedInput
    Permissions?: PermissionsUpdateManyWithoutSubAcctountNestedInput
    Funnels?: FunnelsUpdateManyWithoutSubAccountNestedInput
    Media?: MediaUpdateManyWithoutSubAccountsNestedInput
    Contact?: ContactsUpdateManyWithoutSubAccountsNestedInput
    Automation?: AutomationsUpdateManyWithoutSubAccountsNestedInput
    Pipeline?: PipelinesUpdateManyWithoutSubAccountNestedInput
    Tags?: TagsUpdateManyWithoutSubAccountsNestedInput
    Notification?: NotificationsUpdateManyWithoutSubAccountsNestedInput
    SubAccountSidebarOption?: SubAccountSidebarOptionUpdateManyWithoutSubAccountNestedInput
  }

  export type SubAccountsUncheckedUpdateWithoutTriggerInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAcctountLogo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    SidebarOption?: AgencySidebarOptionUncheckedUpdateManyWithoutSubAccountsNestedInput
    Permissions?: PermissionsUncheckedUpdateManyWithoutSubAcctountNestedInput
    Funnels?: FunnelsUncheckedUpdateManyWithoutSubAccountNestedInput
    Media?: MediaUncheckedUpdateManyWithoutSubAccountsNestedInput
    Contact?: ContactsUncheckedUpdateManyWithoutSubAccountsNestedInput
    Automation?: AutomationsUncheckedUpdateManyWithoutSubAccountsNestedInput
    Pipeline?: PipelinesUncheckedUpdateManyWithoutSubAccountNestedInput
    Tags?: TagsUncheckedUpdateManyWithoutSubAccountsNestedInput
    Notification?: NotificationsUncheckedUpdateManyWithoutSubAccountsNestedInput
    SubAccountSidebarOption?: SubAccountSidebarOptionUncheckedUpdateManyWithoutSubAccountNestedInput
  }

  export type AutomationsUpsertWithWhereUniqueWithoutTriggerInput = {
    where: AutomationsWhereUniqueInput
    update: XOR<AutomationsUpdateWithoutTriggerInput, AutomationsUncheckedUpdateWithoutTriggerInput>
    create: XOR<AutomationsCreateWithoutTriggerInput, AutomationsUncheckedCreateWithoutTriggerInput>
  }

  export type AutomationsUpdateWithWhereUniqueWithoutTriggerInput = {
    where: AutomationsWhereUniqueInput
    data: XOR<AutomationsUpdateWithoutTriggerInput, AutomationsUncheckedUpdateWithoutTriggerInput>
  }

  export type AutomationsUpdateManyWithWhereWithoutTriggerInput = {
    where: AutomationsScalarWhereInput
    data: XOR<AutomationsUpdateManyMutationInput, AutomationsUncheckedUpdateManyWithoutTriggerInput>
  }

  export type TriggersCreateWithoutAutomationsInput = {
    id?: string
    name: string
    type: $Enums.TriggerTypes
    createdAt?: Date | string
    updatedAt?: Date | string
    SubAccounts: SubAccountsCreateNestedOneWithoutTriggerInput
  }

  export type TriggersUncheckedCreateWithoutAutomationsInput = {
    id?: string
    name: string
    type: $Enums.TriggerTypes
    createdAt?: Date | string
    updatedAt?: Date | string
    subAccountId: string
  }

  export type TriggersCreateOrConnectWithoutAutomationsInput = {
    where: TriggersWhereUniqueInput
    create: XOR<TriggersCreateWithoutAutomationsInput, TriggersUncheckedCreateWithoutAutomationsInput>
  }

  export type SubAccountsCreateWithoutAutomationInput = {
    id?: string
    connectAccountId?: string | null
    name: string
    subAcctountLogo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    Agency: AgencyCreateNestedOneWithoutSubAccountInput
    SidebarOption?: AgencySidebarOptionCreateNestedManyWithoutSubAccountsInput
    Permissions?: PermissionsCreateNestedManyWithoutSubAcctountInput
    Funnels?: FunnelsCreateNestedManyWithoutSubAccountInput
    Media?: MediaCreateNestedManyWithoutSubAccountsInput
    Contact?: ContactsCreateNestedManyWithoutSubAccountsInput
    Trigger?: TriggersCreateNestedManyWithoutSubAccountsInput
    Pipeline?: PipelinesCreateNestedManyWithoutSubAccountInput
    Tags?: TagsCreateNestedManyWithoutSubAccountsInput
    Notification?: NotificationsCreateNestedManyWithoutSubAccountsInput
    SubAccountSidebarOption?: SubAccountSidebarOptionCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountsUncheckedCreateWithoutAutomationInput = {
    id?: string
    connectAccountId?: string | null
    name: string
    subAcctountLogo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    agencyId: string
    SidebarOption?: AgencySidebarOptionUncheckedCreateNestedManyWithoutSubAccountsInput
    Permissions?: PermissionsUncheckedCreateNestedManyWithoutSubAcctountInput
    Funnels?: FunnelsUncheckedCreateNestedManyWithoutSubAccountInput
    Media?: MediaUncheckedCreateNestedManyWithoutSubAccountsInput
    Contact?: ContactsUncheckedCreateNestedManyWithoutSubAccountsInput
    Trigger?: TriggersUncheckedCreateNestedManyWithoutSubAccountsInput
    Pipeline?: PipelinesUncheckedCreateNestedManyWithoutSubAccountInput
    Tags?: TagsUncheckedCreateNestedManyWithoutSubAccountsInput
    Notification?: NotificationsUncheckedCreateNestedManyWithoutSubAccountsInput
    SubAccountSidebarOption?: SubAccountSidebarOptionUncheckedCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountsCreateOrConnectWithoutAutomationInput = {
    where: SubAccountsWhereUniqueInput
    create: XOR<SubAccountsCreateWithoutAutomationInput, SubAccountsUncheckedCreateWithoutAutomationInput>
  }

  export type ActionsCreateWithoutAutomationsInput = {
    id?: string
    name: string
    type: $Enums.ActionType
    createdAt?: Date | string
    updatedAt?: Date | string
    order: number
    laneId?: string
  }

  export type ActionsUncheckedCreateWithoutAutomationsInput = {
    id?: string
    name: string
    type: $Enums.ActionType
    createdAt?: Date | string
    updatedAt?: Date | string
    order: number
    laneId?: string
  }

  export type ActionsCreateOrConnectWithoutAutomationsInput = {
    where: ActionsWhereUniqueInput
    create: XOR<ActionsCreateWithoutAutomationsInput, ActionsUncheckedCreateWithoutAutomationsInput>
  }

  export type ActionsCreateManyAutomationsInputEnvelope = {
    data: ActionsCreateManyAutomationsInput | ActionsCreateManyAutomationsInput[]
    skipDuplicates?: boolean
  }

  export type AutomationInstanceCreateWithoutAutomationsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    active?: boolean
  }

  export type AutomationInstanceUncheckedCreateWithoutAutomationsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    active?: boolean
  }

  export type AutomationInstanceCreateOrConnectWithoutAutomationsInput = {
    where: AutomationInstanceWhereUniqueInput
    create: XOR<AutomationInstanceCreateWithoutAutomationsInput, AutomationInstanceUncheckedCreateWithoutAutomationsInput>
  }

  export type AutomationInstanceCreateManyAutomationsInputEnvelope = {
    data: AutomationInstanceCreateManyAutomationsInput | AutomationInstanceCreateManyAutomationsInput[]
    skipDuplicates?: boolean
  }

  export type TriggersUpsertWithoutAutomationsInput = {
    update: XOR<TriggersUpdateWithoutAutomationsInput, TriggersUncheckedUpdateWithoutAutomationsInput>
    create: XOR<TriggersCreateWithoutAutomationsInput, TriggersUncheckedCreateWithoutAutomationsInput>
    where?: TriggersWhereInput
  }

  export type TriggersUpdateToOneWithWhereWithoutAutomationsInput = {
    where?: TriggersWhereInput
    data: XOR<TriggersUpdateWithoutAutomationsInput, TriggersUncheckedUpdateWithoutAutomationsInput>
  }

  export type TriggersUpdateWithoutAutomationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTriggerTypesFieldUpdateOperationsInput | $Enums.TriggerTypes
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SubAccounts?: SubAccountsUpdateOneRequiredWithoutTriggerNestedInput
  }

  export type TriggersUncheckedUpdateWithoutAutomationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTriggerTypesFieldUpdateOperationsInput | $Enums.TriggerTypes
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subAccountId?: StringFieldUpdateOperationsInput | string
  }

  export type SubAccountsUpsertWithoutAutomationInput = {
    update: XOR<SubAccountsUpdateWithoutAutomationInput, SubAccountsUncheckedUpdateWithoutAutomationInput>
    create: XOR<SubAccountsCreateWithoutAutomationInput, SubAccountsUncheckedCreateWithoutAutomationInput>
    where?: SubAccountsWhereInput
  }

  export type SubAccountsUpdateToOneWithWhereWithoutAutomationInput = {
    where?: SubAccountsWhereInput
    data: XOR<SubAccountsUpdateWithoutAutomationInput, SubAccountsUncheckedUpdateWithoutAutomationInput>
  }

  export type SubAccountsUpdateWithoutAutomationInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAcctountLogo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    Agency?: AgencyUpdateOneRequiredWithoutSubAccountNestedInput
    SidebarOption?: AgencySidebarOptionUpdateManyWithoutSubAccountsNestedInput
    Permissions?: PermissionsUpdateManyWithoutSubAcctountNestedInput
    Funnels?: FunnelsUpdateManyWithoutSubAccountNestedInput
    Media?: MediaUpdateManyWithoutSubAccountsNestedInput
    Contact?: ContactsUpdateManyWithoutSubAccountsNestedInput
    Trigger?: TriggersUpdateManyWithoutSubAccountsNestedInput
    Pipeline?: PipelinesUpdateManyWithoutSubAccountNestedInput
    Tags?: TagsUpdateManyWithoutSubAccountsNestedInput
    Notification?: NotificationsUpdateManyWithoutSubAccountsNestedInput
    SubAccountSidebarOption?: SubAccountSidebarOptionUpdateManyWithoutSubAccountNestedInput
  }

  export type SubAccountsUncheckedUpdateWithoutAutomationInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAcctountLogo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    SidebarOption?: AgencySidebarOptionUncheckedUpdateManyWithoutSubAccountsNestedInput
    Permissions?: PermissionsUncheckedUpdateManyWithoutSubAcctountNestedInput
    Funnels?: FunnelsUncheckedUpdateManyWithoutSubAccountNestedInput
    Media?: MediaUncheckedUpdateManyWithoutSubAccountsNestedInput
    Contact?: ContactsUncheckedUpdateManyWithoutSubAccountsNestedInput
    Trigger?: TriggersUncheckedUpdateManyWithoutSubAccountsNestedInput
    Pipeline?: PipelinesUncheckedUpdateManyWithoutSubAccountNestedInput
    Tags?: TagsUncheckedUpdateManyWithoutSubAccountsNestedInput
    Notification?: NotificationsUncheckedUpdateManyWithoutSubAccountsNestedInput
    SubAccountSidebarOption?: SubAccountSidebarOptionUncheckedUpdateManyWithoutSubAccountNestedInput
  }

  export type ActionsUpsertWithWhereUniqueWithoutAutomationsInput = {
    where: ActionsWhereUniqueInput
    update: XOR<ActionsUpdateWithoutAutomationsInput, ActionsUncheckedUpdateWithoutAutomationsInput>
    create: XOR<ActionsCreateWithoutAutomationsInput, ActionsUncheckedCreateWithoutAutomationsInput>
  }

  export type ActionsUpdateWithWhereUniqueWithoutAutomationsInput = {
    where: ActionsWhereUniqueInput
    data: XOR<ActionsUpdateWithoutAutomationsInput, ActionsUncheckedUpdateWithoutAutomationsInput>
  }

  export type ActionsUpdateManyWithWhereWithoutAutomationsInput = {
    where: ActionsScalarWhereInput
    data: XOR<ActionsUpdateManyMutationInput, ActionsUncheckedUpdateManyWithoutAutomationsInput>
  }

  export type ActionsScalarWhereInput = {
    AND?: ActionsScalarWhereInput | ActionsScalarWhereInput[]
    OR?: ActionsScalarWhereInput[]
    NOT?: ActionsScalarWhereInput | ActionsScalarWhereInput[]
    id?: StringFilter<"Actions"> | string
    name?: StringFilter<"Actions"> | string
    type?: EnumActionTypeFilter<"Actions"> | $Enums.ActionType
    createdAt?: DateTimeFilter<"Actions"> | Date | string
    updatedAt?: DateTimeFilter<"Actions"> | Date | string
    automatedId?: StringFilter<"Actions"> | string
    order?: IntFilter<"Actions"> | number
    laneId?: StringFilter<"Actions"> | string
  }

  export type AutomationInstanceUpsertWithWhereUniqueWithoutAutomationsInput = {
    where: AutomationInstanceWhereUniqueInput
    update: XOR<AutomationInstanceUpdateWithoutAutomationsInput, AutomationInstanceUncheckedUpdateWithoutAutomationsInput>
    create: XOR<AutomationInstanceCreateWithoutAutomationsInput, AutomationInstanceUncheckedCreateWithoutAutomationsInput>
  }

  export type AutomationInstanceUpdateWithWhereUniqueWithoutAutomationsInput = {
    where: AutomationInstanceWhereUniqueInput
    data: XOR<AutomationInstanceUpdateWithoutAutomationsInput, AutomationInstanceUncheckedUpdateWithoutAutomationsInput>
  }

  export type AutomationInstanceUpdateManyWithWhereWithoutAutomationsInput = {
    where: AutomationInstanceScalarWhereInput
    data: XOR<AutomationInstanceUpdateManyMutationInput, AutomationInstanceUncheckedUpdateManyWithoutAutomationsInput>
  }

  export type AutomationInstanceScalarWhereInput = {
    AND?: AutomationInstanceScalarWhereInput | AutomationInstanceScalarWhereInput[]
    OR?: AutomationInstanceScalarWhereInput[]
    NOT?: AutomationInstanceScalarWhereInput | AutomationInstanceScalarWhereInput[]
    id?: StringFilter<"AutomationInstance"> | string
    createdAt?: DateTimeFilter<"AutomationInstance"> | Date | string
    updatedAt?: DateTimeFilter<"AutomationInstance"> | Date | string
    automationId?: StringFilter<"AutomationInstance"> | string
    active?: BoolFilter<"AutomationInstance"> | boolean
  }

  export type AutomationsCreateWithoutAutomationInstanceInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    published?: boolean
    Trigger?: TriggersCreateNestedOneWithoutAutomationsInput
    SubAccounts: SubAccountsCreateNestedOneWithoutAutomationInput
    Actions?: ActionsCreateNestedManyWithoutAutomationsInput
  }

  export type AutomationsUncheckedCreateWithoutAutomationInstanceInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    triggerId?: string | null
    published?: boolean
    subAccountId: string
    Actions?: ActionsUncheckedCreateNestedManyWithoutAutomationsInput
  }

  export type AutomationsCreateOrConnectWithoutAutomationInstanceInput = {
    where: AutomationsWhereUniqueInput
    create: XOR<AutomationsCreateWithoutAutomationInstanceInput, AutomationsUncheckedCreateWithoutAutomationInstanceInput>
  }

  export type AutomationsUpsertWithoutAutomationInstanceInput = {
    update: XOR<AutomationsUpdateWithoutAutomationInstanceInput, AutomationsUncheckedUpdateWithoutAutomationInstanceInput>
    create: XOR<AutomationsCreateWithoutAutomationInstanceInput, AutomationsUncheckedCreateWithoutAutomationInstanceInput>
    where?: AutomationsWhereInput
  }

  export type AutomationsUpdateToOneWithWhereWithoutAutomationInstanceInput = {
    where?: AutomationsWhereInput
    data: XOR<AutomationsUpdateWithoutAutomationInstanceInput, AutomationsUncheckedUpdateWithoutAutomationInstanceInput>
  }

  export type AutomationsUpdateWithoutAutomationInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    published?: BoolFieldUpdateOperationsInput | boolean
    Trigger?: TriggersUpdateOneWithoutAutomationsNestedInput
    SubAccounts?: SubAccountsUpdateOneRequiredWithoutAutomationNestedInput
    Actions?: ActionsUpdateManyWithoutAutomationsNestedInput
  }

  export type AutomationsUncheckedUpdateWithoutAutomationInstanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    triggerId?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    subAccountId?: StringFieldUpdateOperationsInput | string
    Actions?: ActionsUncheckedUpdateManyWithoutAutomationsNestedInput
  }

  export type AutomationsCreateWithoutActionsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    published?: boolean
    Trigger?: TriggersCreateNestedOneWithoutAutomationsInput
    SubAccounts: SubAccountsCreateNestedOneWithoutAutomationInput
    AutomationInstance?: AutomationInstanceCreateNestedManyWithoutAutomationsInput
  }

  export type AutomationsUncheckedCreateWithoutActionsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    triggerId?: string | null
    published?: boolean
    subAccountId: string
    AutomationInstance?: AutomationInstanceUncheckedCreateNestedManyWithoutAutomationsInput
  }

  export type AutomationsCreateOrConnectWithoutActionsInput = {
    where: AutomationsWhereUniqueInput
    create: XOR<AutomationsCreateWithoutActionsInput, AutomationsUncheckedCreateWithoutActionsInput>
  }

  export type AutomationsUpsertWithoutActionsInput = {
    update: XOR<AutomationsUpdateWithoutActionsInput, AutomationsUncheckedUpdateWithoutActionsInput>
    create: XOR<AutomationsCreateWithoutActionsInput, AutomationsUncheckedCreateWithoutActionsInput>
    where?: AutomationsWhereInput
  }

  export type AutomationsUpdateToOneWithWhereWithoutActionsInput = {
    where?: AutomationsWhereInput
    data: XOR<AutomationsUpdateWithoutActionsInput, AutomationsUncheckedUpdateWithoutActionsInput>
  }

  export type AutomationsUpdateWithoutActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    published?: BoolFieldUpdateOperationsInput | boolean
    Trigger?: TriggersUpdateOneWithoutAutomationsNestedInput
    SubAccounts?: SubAccountsUpdateOneRequiredWithoutAutomationNestedInput
    AutomationInstance?: AutomationInstanceUpdateManyWithoutAutomationsNestedInput
  }

  export type AutomationsUncheckedUpdateWithoutActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    triggerId?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    subAccountId?: StringFieldUpdateOperationsInput | string
    AutomationInstance?: AutomationInstanceUncheckedUpdateManyWithoutAutomationsNestedInput
  }

  export type SubAccountsCreateWithoutContactInput = {
    id?: string
    connectAccountId?: string | null
    name: string
    subAcctountLogo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    Agency: AgencyCreateNestedOneWithoutSubAccountInput
    SidebarOption?: AgencySidebarOptionCreateNestedManyWithoutSubAccountsInput
    Permissions?: PermissionsCreateNestedManyWithoutSubAcctountInput
    Funnels?: FunnelsCreateNestedManyWithoutSubAccountInput
    Media?: MediaCreateNestedManyWithoutSubAccountsInput
    Trigger?: TriggersCreateNestedManyWithoutSubAccountsInput
    Automation?: AutomationsCreateNestedManyWithoutSubAccountsInput
    Pipeline?: PipelinesCreateNestedManyWithoutSubAccountInput
    Tags?: TagsCreateNestedManyWithoutSubAccountsInput
    Notification?: NotificationsCreateNestedManyWithoutSubAccountsInput
    SubAccountSidebarOption?: SubAccountSidebarOptionCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountsUncheckedCreateWithoutContactInput = {
    id?: string
    connectAccountId?: string | null
    name: string
    subAcctountLogo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    agencyId: string
    SidebarOption?: AgencySidebarOptionUncheckedCreateNestedManyWithoutSubAccountsInput
    Permissions?: PermissionsUncheckedCreateNestedManyWithoutSubAcctountInput
    Funnels?: FunnelsUncheckedCreateNestedManyWithoutSubAccountInput
    Media?: MediaUncheckedCreateNestedManyWithoutSubAccountsInput
    Trigger?: TriggersUncheckedCreateNestedManyWithoutSubAccountsInput
    Automation?: AutomationsUncheckedCreateNestedManyWithoutSubAccountsInput
    Pipeline?: PipelinesUncheckedCreateNestedManyWithoutSubAccountInput
    Tags?: TagsUncheckedCreateNestedManyWithoutSubAccountsInput
    Notification?: NotificationsUncheckedCreateNestedManyWithoutSubAccountsInput
    SubAccountSidebarOption?: SubAccountSidebarOptionUncheckedCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountsCreateOrConnectWithoutContactInput = {
    where: SubAccountsWhereUniqueInput
    create: XOR<SubAccountsCreateWithoutContactInput, SubAccountsUncheckedCreateWithoutContactInput>
  }

  export type TicketsCreateWithoutContactsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: number
    value?: Decimal | DecimalJsLike | number | string | null
    description?: string | null
    Lane: LaneCreateNestedOneWithoutTicketsInput
    tags?: TagsCreateNestedManyWithoutTicketsInput
    Users?: UsersCreateNestedOneWithoutTicketInput
  }

  export type TicketsUncheckedCreateWithoutContactsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lineId: string
    order?: number
    value?: Decimal | DecimalJsLike | number | string | null
    description?: string | null
    userId?: string | null
    tags?: TagsUncheckedCreateNestedManyWithoutTicketsInput
  }

  export type TicketsCreateOrConnectWithoutContactsInput = {
    where: TicketsWhereUniqueInput
    create: XOR<TicketsCreateWithoutContactsInput, TicketsUncheckedCreateWithoutContactsInput>
  }

  export type TicketsCreateManyContactsInputEnvelope = {
    data: TicketsCreateManyContactsInput | TicketsCreateManyContactsInput[]
    skipDuplicates?: boolean
  }

  export type SubAccountsUpsertWithoutContactInput = {
    update: XOR<SubAccountsUpdateWithoutContactInput, SubAccountsUncheckedUpdateWithoutContactInput>
    create: XOR<SubAccountsCreateWithoutContactInput, SubAccountsUncheckedCreateWithoutContactInput>
    where?: SubAccountsWhereInput
  }

  export type SubAccountsUpdateToOneWithWhereWithoutContactInput = {
    where?: SubAccountsWhereInput
    data: XOR<SubAccountsUpdateWithoutContactInput, SubAccountsUncheckedUpdateWithoutContactInput>
  }

  export type SubAccountsUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAcctountLogo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    Agency?: AgencyUpdateOneRequiredWithoutSubAccountNestedInput
    SidebarOption?: AgencySidebarOptionUpdateManyWithoutSubAccountsNestedInput
    Permissions?: PermissionsUpdateManyWithoutSubAcctountNestedInput
    Funnels?: FunnelsUpdateManyWithoutSubAccountNestedInput
    Media?: MediaUpdateManyWithoutSubAccountsNestedInput
    Trigger?: TriggersUpdateManyWithoutSubAccountsNestedInput
    Automation?: AutomationsUpdateManyWithoutSubAccountsNestedInput
    Pipeline?: PipelinesUpdateManyWithoutSubAccountNestedInput
    Tags?: TagsUpdateManyWithoutSubAccountsNestedInput
    Notification?: NotificationsUpdateManyWithoutSubAccountsNestedInput
    SubAccountSidebarOption?: SubAccountSidebarOptionUpdateManyWithoutSubAccountNestedInput
  }

  export type SubAccountsUncheckedUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAcctountLogo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    SidebarOption?: AgencySidebarOptionUncheckedUpdateManyWithoutSubAccountsNestedInput
    Permissions?: PermissionsUncheckedUpdateManyWithoutSubAcctountNestedInput
    Funnels?: FunnelsUncheckedUpdateManyWithoutSubAccountNestedInput
    Media?: MediaUncheckedUpdateManyWithoutSubAccountsNestedInput
    Trigger?: TriggersUncheckedUpdateManyWithoutSubAccountsNestedInput
    Automation?: AutomationsUncheckedUpdateManyWithoutSubAccountsNestedInput
    Pipeline?: PipelinesUncheckedUpdateManyWithoutSubAccountNestedInput
    Tags?: TagsUncheckedUpdateManyWithoutSubAccountsNestedInput
    Notification?: NotificationsUncheckedUpdateManyWithoutSubAccountsNestedInput
    SubAccountSidebarOption?: SubAccountSidebarOptionUncheckedUpdateManyWithoutSubAccountNestedInput
  }

  export type TicketsUpsertWithWhereUniqueWithoutContactsInput = {
    where: TicketsWhereUniqueInput
    update: XOR<TicketsUpdateWithoutContactsInput, TicketsUncheckedUpdateWithoutContactsInput>
    create: XOR<TicketsCreateWithoutContactsInput, TicketsUncheckedCreateWithoutContactsInput>
  }

  export type TicketsUpdateWithWhereUniqueWithoutContactsInput = {
    where: TicketsWhereUniqueInput
    data: XOR<TicketsUpdateWithoutContactsInput, TicketsUncheckedUpdateWithoutContactsInput>
  }

  export type TicketsUpdateManyWithWhereWithoutContactsInput = {
    where: TicketsScalarWhereInput
    data: XOR<TicketsUpdateManyMutationInput, TicketsUncheckedUpdateManyWithoutContactsInput>
  }

  export type SubAccountsCreateWithoutMediaInput = {
    id?: string
    connectAccountId?: string | null
    name: string
    subAcctountLogo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    Agency: AgencyCreateNestedOneWithoutSubAccountInput
    SidebarOption?: AgencySidebarOptionCreateNestedManyWithoutSubAccountsInput
    Permissions?: PermissionsCreateNestedManyWithoutSubAcctountInput
    Funnels?: FunnelsCreateNestedManyWithoutSubAccountInput
    Contact?: ContactsCreateNestedManyWithoutSubAccountsInput
    Trigger?: TriggersCreateNestedManyWithoutSubAccountsInput
    Automation?: AutomationsCreateNestedManyWithoutSubAccountsInput
    Pipeline?: PipelinesCreateNestedManyWithoutSubAccountInput
    Tags?: TagsCreateNestedManyWithoutSubAccountsInput
    Notification?: NotificationsCreateNestedManyWithoutSubAccountsInput
    SubAccountSidebarOption?: SubAccountSidebarOptionCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountsUncheckedCreateWithoutMediaInput = {
    id?: string
    connectAccountId?: string | null
    name: string
    subAcctountLogo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    agencyId: string
    SidebarOption?: AgencySidebarOptionUncheckedCreateNestedManyWithoutSubAccountsInput
    Permissions?: PermissionsUncheckedCreateNestedManyWithoutSubAcctountInput
    Funnels?: FunnelsUncheckedCreateNestedManyWithoutSubAccountInput
    Contact?: ContactsUncheckedCreateNestedManyWithoutSubAccountsInput
    Trigger?: TriggersUncheckedCreateNestedManyWithoutSubAccountsInput
    Automation?: AutomationsUncheckedCreateNestedManyWithoutSubAccountsInput
    Pipeline?: PipelinesUncheckedCreateNestedManyWithoutSubAccountInput
    Tags?: TagsUncheckedCreateNestedManyWithoutSubAccountsInput
    Notification?: NotificationsUncheckedCreateNestedManyWithoutSubAccountsInput
    SubAccountSidebarOption?: SubAccountSidebarOptionUncheckedCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountsCreateOrConnectWithoutMediaInput = {
    where: SubAccountsWhereUniqueInput
    create: XOR<SubAccountsCreateWithoutMediaInput, SubAccountsUncheckedCreateWithoutMediaInput>
  }

  export type SubAccountsUpsertWithoutMediaInput = {
    update: XOR<SubAccountsUpdateWithoutMediaInput, SubAccountsUncheckedUpdateWithoutMediaInput>
    create: XOR<SubAccountsCreateWithoutMediaInput, SubAccountsUncheckedCreateWithoutMediaInput>
    where?: SubAccountsWhereInput
  }

  export type SubAccountsUpdateToOneWithWhereWithoutMediaInput = {
    where?: SubAccountsWhereInput
    data: XOR<SubAccountsUpdateWithoutMediaInput, SubAccountsUncheckedUpdateWithoutMediaInput>
  }

  export type SubAccountsUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAcctountLogo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    Agency?: AgencyUpdateOneRequiredWithoutSubAccountNestedInput
    SidebarOption?: AgencySidebarOptionUpdateManyWithoutSubAccountsNestedInput
    Permissions?: PermissionsUpdateManyWithoutSubAcctountNestedInput
    Funnels?: FunnelsUpdateManyWithoutSubAccountNestedInput
    Contact?: ContactsUpdateManyWithoutSubAccountsNestedInput
    Trigger?: TriggersUpdateManyWithoutSubAccountsNestedInput
    Automation?: AutomationsUpdateManyWithoutSubAccountsNestedInput
    Pipeline?: PipelinesUpdateManyWithoutSubAccountNestedInput
    Tags?: TagsUpdateManyWithoutSubAccountsNestedInput
    Notification?: NotificationsUpdateManyWithoutSubAccountsNestedInput
    SubAccountSidebarOption?: SubAccountSidebarOptionUpdateManyWithoutSubAccountNestedInput
  }

  export type SubAccountsUncheckedUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAcctountLogo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    SidebarOption?: AgencySidebarOptionUncheckedUpdateManyWithoutSubAccountsNestedInput
    Permissions?: PermissionsUncheckedUpdateManyWithoutSubAcctountNestedInput
    Funnels?: FunnelsUncheckedUpdateManyWithoutSubAccountNestedInput
    Contact?: ContactsUncheckedUpdateManyWithoutSubAccountsNestedInput
    Trigger?: TriggersUncheckedUpdateManyWithoutSubAccountsNestedInput
    Automation?: AutomationsUncheckedUpdateManyWithoutSubAccountsNestedInput
    Pipeline?: PipelinesUncheckedUpdateManyWithoutSubAccountNestedInput
    Tags?: TagsUncheckedUpdateManyWithoutSubAccountsNestedInput
    Notification?: NotificationsUncheckedUpdateManyWithoutSubAccountsNestedInput
    SubAccountSidebarOption?: SubAccountSidebarOptionUncheckedUpdateManyWithoutSubAccountNestedInput
  }

  export type PipelinesCreateWithoutLaneInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    SubAccount: SubAccountsCreateNestedOneWithoutPipelineInput
  }

  export type PipelinesUncheckedCreateWithoutLaneInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subAccountId: string
  }

  export type PipelinesCreateOrConnectWithoutLaneInput = {
    where: PipelinesWhereUniqueInput
    create: XOR<PipelinesCreateWithoutLaneInput, PipelinesUncheckedCreateWithoutLaneInput>
  }

  export type TicketsCreateWithoutLaneInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: number
    value?: Decimal | DecimalJsLike | number | string | null
    description?: string | null
    tags?: TagsCreateNestedManyWithoutTicketsInput
    Users?: UsersCreateNestedOneWithoutTicketInput
    Contacts?: ContactsCreateNestedOneWithoutTicketsInput
  }

  export type TicketsUncheckedCreateWithoutLaneInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: number
    value?: Decimal | DecimalJsLike | number | string | null
    description?: string | null
    userId?: string | null
    contactId?: string | null
    tags?: TagsUncheckedCreateNestedManyWithoutTicketsInput
  }

  export type TicketsCreateOrConnectWithoutLaneInput = {
    where: TicketsWhereUniqueInput
    create: XOR<TicketsCreateWithoutLaneInput, TicketsUncheckedCreateWithoutLaneInput>
  }

  export type TicketsCreateManyLaneInputEnvelope = {
    data: TicketsCreateManyLaneInput | TicketsCreateManyLaneInput[]
    skipDuplicates?: boolean
  }

  export type PipelinesUpsertWithoutLaneInput = {
    update: XOR<PipelinesUpdateWithoutLaneInput, PipelinesUncheckedUpdateWithoutLaneInput>
    create: XOR<PipelinesCreateWithoutLaneInput, PipelinesUncheckedCreateWithoutLaneInput>
    where?: PipelinesWhereInput
  }

  export type PipelinesUpdateToOneWithWhereWithoutLaneInput = {
    where?: PipelinesWhereInput
    data: XOR<PipelinesUpdateWithoutLaneInput, PipelinesUncheckedUpdateWithoutLaneInput>
  }

  export type PipelinesUpdateWithoutLaneInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SubAccount?: SubAccountsUpdateOneRequiredWithoutPipelineNestedInput
  }

  export type PipelinesUncheckedUpdateWithoutLaneInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subAccountId?: StringFieldUpdateOperationsInput | string
  }

  export type TicketsUpsertWithWhereUniqueWithoutLaneInput = {
    where: TicketsWhereUniqueInput
    update: XOR<TicketsUpdateWithoutLaneInput, TicketsUncheckedUpdateWithoutLaneInput>
    create: XOR<TicketsCreateWithoutLaneInput, TicketsUncheckedCreateWithoutLaneInput>
  }

  export type TicketsUpdateWithWhereUniqueWithoutLaneInput = {
    where: TicketsWhereUniqueInput
    data: XOR<TicketsUpdateWithoutLaneInput, TicketsUncheckedUpdateWithoutLaneInput>
  }

  export type TicketsUpdateManyWithWhereWithoutLaneInput = {
    where: TicketsScalarWhereInput
    data: XOR<TicketsUpdateManyMutationInput, TicketsUncheckedUpdateManyWithoutLaneInput>
  }

  export type LaneCreateWithoutTicketsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: number
    Pipeline: PipelinesCreateNestedOneWithoutLaneInput
  }

  export type LaneUncheckedCreateWithoutTicketsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    pipelineId: string
    order?: number
  }

  export type LaneCreateOrConnectWithoutTicketsInput = {
    where: LaneWhereUniqueInput
    create: XOR<LaneCreateWithoutTicketsInput, LaneUncheckedCreateWithoutTicketsInput>
  }

  export type TagsCreateWithoutTicketsInput = {
    id?: string
    nane: string
    color: string
    createdAt?: Date | string
    updatedAt?: Date | string
    SubAccounts: SubAccountsCreateNestedOneWithoutTagsInput
  }

  export type TagsUncheckedCreateWithoutTicketsInput = {
    id?: string
    nane: string
    color: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subAccountId: string
  }

  export type TagsCreateOrConnectWithoutTicketsInput = {
    where: TagsWhereUniqueInput
    create: XOR<TagsCreateWithoutTicketsInput, TagsUncheckedCreateWithoutTicketsInput>
  }

  export type UsersCreateWithoutTicketInput = {
    id?: string
    name: string
    avatarUrl: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.Role
    Agency?: AgencyCreateNestedOneWithoutUserInput
    Permission?: PermissionsCreateNestedManyWithoutUsersInput
    Notification?: NotificationsCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutTicketInput = {
    id?: string
    name: string
    avatarUrl: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.Role
    agencyId?: string | null
    Permission?: PermissionsUncheckedCreateNestedManyWithoutUsersInput
    Notification?: NotificationsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutTicketInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutTicketInput, UsersUncheckedCreateWithoutTicketInput>
  }

  export type ContactsCreateWithoutTicketsInput = {
    id?: string
    name: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    SubAccounts: SubAccountsCreateNestedOneWithoutContactInput
  }

  export type ContactsUncheckedCreateWithoutTicketsInput = {
    id?: string
    name: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subAccountId: string
  }

  export type ContactsCreateOrConnectWithoutTicketsInput = {
    where: ContactsWhereUniqueInput
    create: XOR<ContactsCreateWithoutTicketsInput, ContactsUncheckedCreateWithoutTicketsInput>
  }

  export type LaneUpsertWithoutTicketsInput = {
    update: XOR<LaneUpdateWithoutTicketsInput, LaneUncheckedUpdateWithoutTicketsInput>
    create: XOR<LaneCreateWithoutTicketsInput, LaneUncheckedCreateWithoutTicketsInput>
    where?: LaneWhereInput
  }

  export type LaneUpdateToOneWithWhereWithoutTicketsInput = {
    where?: LaneWhereInput
    data: XOR<LaneUpdateWithoutTicketsInput, LaneUncheckedUpdateWithoutTicketsInput>
  }

  export type LaneUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: IntFieldUpdateOperationsInput | number
    Pipeline?: PipelinesUpdateOneRequiredWithoutLaneNestedInput
  }

  export type LaneUncheckedUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pipelineId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type TagsUpsertWithWhereUniqueWithoutTicketsInput = {
    where: TagsWhereUniqueInput
    update: XOR<TagsUpdateWithoutTicketsInput, TagsUncheckedUpdateWithoutTicketsInput>
    create: XOR<TagsCreateWithoutTicketsInput, TagsUncheckedCreateWithoutTicketsInput>
  }

  export type TagsUpdateWithWhereUniqueWithoutTicketsInput = {
    where: TagsWhereUniqueInput
    data: XOR<TagsUpdateWithoutTicketsInput, TagsUncheckedUpdateWithoutTicketsInput>
  }

  export type TagsUpdateManyWithWhereWithoutTicketsInput = {
    where: TagsScalarWhereInput
    data: XOR<TagsUpdateManyMutationInput, TagsUncheckedUpdateManyWithoutTicketsInput>
  }

  export type UsersUpsertWithoutTicketInput = {
    update: XOR<UsersUpdateWithoutTicketInput, UsersUncheckedUpdateWithoutTicketInput>
    create: XOR<UsersCreateWithoutTicketInput, UsersUncheckedCreateWithoutTicketInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutTicketInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutTicketInput, UsersUncheckedUpdateWithoutTicketInput>
  }

  export type UsersUpdateWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    Agency?: AgencyUpdateOneWithoutUserNestedInput
    Permission?: PermissionsUpdateManyWithoutUsersNestedInput
    Notification?: NotificationsUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
    Permission?: PermissionsUncheckedUpdateManyWithoutUsersNestedInput
    Notification?: NotificationsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type ContactsUpsertWithoutTicketsInput = {
    update: XOR<ContactsUpdateWithoutTicketsInput, ContactsUncheckedUpdateWithoutTicketsInput>
    create: XOR<ContactsCreateWithoutTicketsInput, ContactsUncheckedCreateWithoutTicketsInput>
    where?: ContactsWhereInput
  }

  export type ContactsUpdateToOneWithWhereWithoutTicketsInput = {
    where?: ContactsWhereInput
    data: XOR<ContactsUpdateWithoutTicketsInput, ContactsUncheckedUpdateWithoutTicketsInput>
  }

  export type ContactsUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SubAccounts?: SubAccountsUpdateOneRequiredWithoutContactNestedInput
  }

  export type ContactsUncheckedUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subAccountId?: StringFieldUpdateOperationsInput | string
  }

  export type SubAccountsCreateWithoutTagsInput = {
    id?: string
    connectAccountId?: string | null
    name: string
    subAcctountLogo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    Agency: AgencyCreateNestedOneWithoutSubAccountInput
    SidebarOption?: AgencySidebarOptionCreateNestedManyWithoutSubAccountsInput
    Permissions?: PermissionsCreateNestedManyWithoutSubAcctountInput
    Funnels?: FunnelsCreateNestedManyWithoutSubAccountInput
    Media?: MediaCreateNestedManyWithoutSubAccountsInput
    Contact?: ContactsCreateNestedManyWithoutSubAccountsInput
    Trigger?: TriggersCreateNestedManyWithoutSubAccountsInput
    Automation?: AutomationsCreateNestedManyWithoutSubAccountsInput
    Pipeline?: PipelinesCreateNestedManyWithoutSubAccountInput
    Notification?: NotificationsCreateNestedManyWithoutSubAccountsInput
    SubAccountSidebarOption?: SubAccountSidebarOptionCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountsUncheckedCreateWithoutTagsInput = {
    id?: string
    connectAccountId?: string | null
    name: string
    subAcctountLogo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    agencyId: string
    SidebarOption?: AgencySidebarOptionUncheckedCreateNestedManyWithoutSubAccountsInput
    Permissions?: PermissionsUncheckedCreateNestedManyWithoutSubAcctountInput
    Funnels?: FunnelsUncheckedCreateNestedManyWithoutSubAccountInput
    Media?: MediaUncheckedCreateNestedManyWithoutSubAccountsInput
    Contact?: ContactsUncheckedCreateNestedManyWithoutSubAccountsInput
    Trigger?: TriggersUncheckedCreateNestedManyWithoutSubAccountsInput
    Automation?: AutomationsUncheckedCreateNestedManyWithoutSubAccountsInput
    Pipeline?: PipelinesUncheckedCreateNestedManyWithoutSubAccountInput
    Notification?: NotificationsUncheckedCreateNestedManyWithoutSubAccountsInput
    SubAccountSidebarOption?: SubAccountSidebarOptionUncheckedCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountsCreateOrConnectWithoutTagsInput = {
    where: SubAccountsWhereUniqueInput
    create: XOR<SubAccountsCreateWithoutTagsInput, SubAccountsUncheckedCreateWithoutTagsInput>
  }

  export type TicketsCreateWithoutTagsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: number
    value?: Decimal | DecimalJsLike | number | string | null
    description?: string | null
    Lane: LaneCreateNestedOneWithoutTicketsInput
    Users?: UsersCreateNestedOneWithoutTicketInput
    Contacts?: ContactsCreateNestedOneWithoutTicketsInput
  }

  export type TicketsUncheckedCreateWithoutTagsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lineId: string
    order?: number
    value?: Decimal | DecimalJsLike | number | string | null
    description?: string | null
    userId?: string | null
    contactId?: string | null
  }

  export type TicketsCreateOrConnectWithoutTagsInput = {
    where: TicketsWhereUniqueInput
    create: XOR<TicketsCreateWithoutTagsInput, TicketsUncheckedCreateWithoutTagsInput>
  }

  export type SubAccountsUpsertWithoutTagsInput = {
    update: XOR<SubAccountsUpdateWithoutTagsInput, SubAccountsUncheckedUpdateWithoutTagsInput>
    create: XOR<SubAccountsCreateWithoutTagsInput, SubAccountsUncheckedCreateWithoutTagsInput>
    where?: SubAccountsWhereInput
  }

  export type SubAccountsUpdateToOneWithWhereWithoutTagsInput = {
    where?: SubAccountsWhereInput
    data: XOR<SubAccountsUpdateWithoutTagsInput, SubAccountsUncheckedUpdateWithoutTagsInput>
  }

  export type SubAccountsUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAcctountLogo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    Agency?: AgencyUpdateOneRequiredWithoutSubAccountNestedInput
    SidebarOption?: AgencySidebarOptionUpdateManyWithoutSubAccountsNestedInput
    Permissions?: PermissionsUpdateManyWithoutSubAcctountNestedInput
    Funnels?: FunnelsUpdateManyWithoutSubAccountNestedInput
    Media?: MediaUpdateManyWithoutSubAccountsNestedInput
    Contact?: ContactsUpdateManyWithoutSubAccountsNestedInput
    Trigger?: TriggersUpdateManyWithoutSubAccountsNestedInput
    Automation?: AutomationsUpdateManyWithoutSubAccountsNestedInput
    Pipeline?: PipelinesUpdateManyWithoutSubAccountNestedInput
    Notification?: NotificationsUpdateManyWithoutSubAccountsNestedInput
    SubAccountSidebarOption?: SubAccountSidebarOptionUpdateManyWithoutSubAccountNestedInput
  }

  export type SubAccountsUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAcctountLogo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    SidebarOption?: AgencySidebarOptionUncheckedUpdateManyWithoutSubAccountsNestedInput
    Permissions?: PermissionsUncheckedUpdateManyWithoutSubAcctountNestedInput
    Funnels?: FunnelsUncheckedUpdateManyWithoutSubAccountNestedInput
    Media?: MediaUncheckedUpdateManyWithoutSubAccountsNestedInput
    Contact?: ContactsUncheckedUpdateManyWithoutSubAccountsNestedInput
    Trigger?: TriggersUncheckedUpdateManyWithoutSubAccountsNestedInput
    Automation?: AutomationsUncheckedUpdateManyWithoutSubAccountsNestedInput
    Pipeline?: PipelinesUncheckedUpdateManyWithoutSubAccountNestedInput
    Notification?: NotificationsUncheckedUpdateManyWithoutSubAccountsNestedInput
    SubAccountSidebarOption?: SubAccountSidebarOptionUncheckedUpdateManyWithoutSubAccountNestedInput
  }

  export type TicketsUpsertWithWhereUniqueWithoutTagsInput = {
    where: TicketsWhereUniqueInput
    update: XOR<TicketsUpdateWithoutTagsInput, TicketsUncheckedUpdateWithoutTagsInput>
    create: XOR<TicketsCreateWithoutTagsInput, TicketsUncheckedCreateWithoutTagsInput>
  }

  export type TicketsUpdateWithWhereUniqueWithoutTagsInput = {
    where: TicketsWhereUniqueInput
    data: XOR<TicketsUpdateWithoutTagsInput, TicketsUncheckedUpdateWithoutTagsInput>
  }

  export type TicketsUpdateManyWithWhereWithoutTagsInput = {
    where: TicketsScalarWhereInput
    data: XOR<TicketsUpdateManyMutationInput, TicketsUncheckedUpdateManyWithoutTagsInput>
  }

  export type SubAccountsCreateWithoutSubAccountSidebarOptionInput = {
    id?: string
    connectAccountId?: string | null
    name: string
    subAcctountLogo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    Agency: AgencyCreateNestedOneWithoutSubAccountInput
    SidebarOption?: AgencySidebarOptionCreateNestedManyWithoutSubAccountsInput
    Permissions?: PermissionsCreateNestedManyWithoutSubAcctountInput
    Funnels?: FunnelsCreateNestedManyWithoutSubAccountInput
    Media?: MediaCreateNestedManyWithoutSubAccountsInput
    Contact?: ContactsCreateNestedManyWithoutSubAccountsInput
    Trigger?: TriggersCreateNestedManyWithoutSubAccountsInput
    Automation?: AutomationsCreateNestedManyWithoutSubAccountsInput
    Pipeline?: PipelinesCreateNestedManyWithoutSubAccountInput
    Tags?: TagsCreateNestedManyWithoutSubAccountsInput
    Notification?: NotificationsCreateNestedManyWithoutSubAccountsInput
  }

  export type SubAccountsUncheckedCreateWithoutSubAccountSidebarOptionInput = {
    id?: string
    connectAccountId?: string | null
    name: string
    subAcctountLogo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    agencyId: string
    SidebarOption?: AgencySidebarOptionUncheckedCreateNestedManyWithoutSubAccountsInput
    Permissions?: PermissionsUncheckedCreateNestedManyWithoutSubAcctountInput
    Funnels?: FunnelsUncheckedCreateNestedManyWithoutSubAccountInput
    Media?: MediaUncheckedCreateNestedManyWithoutSubAccountsInput
    Contact?: ContactsUncheckedCreateNestedManyWithoutSubAccountsInput
    Trigger?: TriggersUncheckedCreateNestedManyWithoutSubAccountsInput
    Automation?: AutomationsUncheckedCreateNestedManyWithoutSubAccountsInput
    Pipeline?: PipelinesUncheckedCreateNestedManyWithoutSubAccountInput
    Tags?: TagsUncheckedCreateNestedManyWithoutSubAccountsInput
    Notification?: NotificationsUncheckedCreateNestedManyWithoutSubAccountsInput
  }

  export type SubAccountsCreateOrConnectWithoutSubAccountSidebarOptionInput = {
    where: SubAccountsWhereUniqueInput
    create: XOR<SubAccountsCreateWithoutSubAccountSidebarOptionInput, SubAccountsUncheckedCreateWithoutSubAccountSidebarOptionInput>
  }

  export type SubAccountsUpsertWithoutSubAccountSidebarOptionInput = {
    update: XOR<SubAccountsUpdateWithoutSubAccountSidebarOptionInput, SubAccountsUncheckedUpdateWithoutSubAccountSidebarOptionInput>
    create: XOR<SubAccountsCreateWithoutSubAccountSidebarOptionInput, SubAccountsUncheckedCreateWithoutSubAccountSidebarOptionInput>
    where?: SubAccountsWhereInput
  }

  export type SubAccountsUpdateToOneWithWhereWithoutSubAccountSidebarOptionInput = {
    where?: SubAccountsWhereInput
    data: XOR<SubAccountsUpdateWithoutSubAccountSidebarOptionInput, SubAccountsUncheckedUpdateWithoutSubAccountSidebarOptionInput>
  }

  export type SubAccountsUpdateWithoutSubAccountSidebarOptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAcctountLogo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    Agency?: AgencyUpdateOneRequiredWithoutSubAccountNestedInput
    SidebarOption?: AgencySidebarOptionUpdateManyWithoutSubAccountsNestedInput
    Permissions?: PermissionsUpdateManyWithoutSubAcctountNestedInput
    Funnels?: FunnelsUpdateManyWithoutSubAccountNestedInput
    Media?: MediaUpdateManyWithoutSubAccountsNestedInput
    Contact?: ContactsUpdateManyWithoutSubAccountsNestedInput
    Trigger?: TriggersUpdateManyWithoutSubAccountsNestedInput
    Automation?: AutomationsUpdateManyWithoutSubAccountsNestedInput
    Pipeline?: PipelinesUpdateManyWithoutSubAccountNestedInput
    Tags?: TagsUpdateManyWithoutSubAccountsNestedInput
    Notification?: NotificationsUpdateManyWithoutSubAccountsNestedInput
  }

  export type SubAccountsUncheckedUpdateWithoutSubAccountSidebarOptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAcctountLogo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    SidebarOption?: AgencySidebarOptionUncheckedUpdateManyWithoutSubAccountsNestedInput
    Permissions?: PermissionsUncheckedUpdateManyWithoutSubAcctountNestedInput
    Funnels?: FunnelsUncheckedUpdateManyWithoutSubAccountNestedInput
    Media?: MediaUncheckedUpdateManyWithoutSubAccountsNestedInput
    Contact?: ContactsUncheckedUpdateManyWithoutSubAccountsNestedInput
    Trigger?: TriggersUncheckedUpdateManyWithoutSubAccountsNestedInput
    Automation?: AutomationsUncheckedUpdateManyWithoutSubAccountsNestedInput
    Pipeline?: PipelinesUncheckedUpdateManyWithoutSubAccountNestedInput
    Tags?: TagsUncheckedUpdateManyWithoutSubAccountsNestedInput
    Notification?: NotificationsUncheckedUpdateManyWithoutSubAccountsNestedInput
  }

  export type AgencyCreateWithoutInvitationInput = {
    id?: string
    connectAccountId?: string | null
    customerId?: string
    name: string
    agencyLogo: string
    companyEmail: string
    companyPhone: string
    whiteLabel?: boolean
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    goal: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UsersCreateNestedManyWithoutAgencyInput
    SubAccount?: SubAccountsCreateNestedManyWithoutAgencyInput
    SidebarOption?: AgencySidebarOptionCreateNestedManyWithoutAgencyInput
    Notification?: NotificationsCreateNestedManyWithoutAgencyInput
    Subscription?: SubscriptionsCreateNestedOneWithoutAgencyInput
    AddOns?: AddOnsCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUncheckedCreateWithoutInvitationInput = {
    id?: string
    connectAccountId?: string | null
    customerId?: string
    name: string
    agencyLogo: string
    companyEmail: string
    companyPhone: string
    whiteLabel?: boolean
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    goal: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UsersUncheckedCreateNestedManyWithoutAgencyInput
    SubAccount?: SubAccountsUncheckedCreateNestedManyWithoutAgencyInput
    SidebarOption?: AgencySidebarOptionUncheckedCreateNestedManyWithoutAgencyInput
    Notification?: NotificationsUncheckedCreateNestedManyWithoutAgencyInput
    Subscription?: SubscriptionsUncheckedCreateNestedOneWithoutAgencyInput
    AddOns?: AddOnsUncheckedCreateNestedManyWithoutAgencyInput
  }

  export type AgencyCreateOrConnectWithoutInvitationInput = {
    where: AgencyWhereUniqueInput
    create: XOR<AgencyCreateWithoutInvitationInput, AgencyUncheckedCreateWithoutInvitationInput>
  }

  export type AgencyUpsertWithoutInvitationInput = {
    update: XOR<AgencyUpdateWithoutInvitationInput, AgencyUncheckedUpdateWithoutInvitationInput>
    create: XOR<AgencyCreateWithoutInvitationInput, AgencyUncheckedCreateWithoutInvitationInput>
    where?: AgencyWhereInput
  }

  export type AgencyUpdateToOneWithWhereWithoutInvitationInput = {
    where?: AgencyWhereInput
    data: XOR<AgencyUpdateWithoutInvitationInput, AgencyUncheckedUpdateWithoutInvitationInput>
  }

  export type AgencyUpdateWithoutInvitationInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    agencyLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    whiteLabel?: BoolFieldUpdateOperationsInput | boolean
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateManyWithoutAgencyNestedInput
    SubAccount?: SubAccountsUpdateManyWithoutAgencyNestedInput
    SidebarOption?: AgencySidebarOptionUpdateManyWithoutAgencyNestedInput
    Notification?: NotificationsUpdateManyWithoutAgencyNestedInput
    Subscription?: SubscriptionsUpdateOneWithoutAgencyNestedInput
    AddOns?: AddOnsUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateWithoutInvitationInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    agencyLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    whiteLabel?: BoolFieldUpdateOperationsInput | boolean
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUncheckedUpdateManyWithoutAgencyNestedInput
    SubAccount?: SubAccountsUncheckedUpdateManyWithoutAgencyNestedInput
    SidebarOption?: AgencySidebarOptionUncheckedUpdateManyWithoutAgencyNestedInput
    Notification?: NotificationsUncheckedUpdateManyWithoutAgencyNestedInput
    Subscription?: SubscriptionsUncheckedUpdateOneWithoutAgencyNestedInput
    AddOns?: AddOnsUncheckedUpdateManyWithoutAgencyNestedInput
  }

  export type SubAccountsCreateWithoutFunnelsInput = {
    id?: string
    connectAccountId?: string | null
    name: string
    subAcctountLogo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    Agency: AgencyCreateNestedOneWithoutSubAccountInput
    SidebarOption?: AgencySidebarOptionCreateNestedManyWithoutSubAccountsInput
    Permissions?: PermissionsCreateNestedManyWithoutSubAcctountInput
    Media?: MediaCreateNestedManyWithoutSubAccountsInput
    Contact?: ContactsCreateNestedManyWithoutSubAccountsInput
    Trigger?: TriggersCreateNestedManyWithoutSubAccountsInput
    Automation?: AutomationsCreateNestedManyWithoutSubAccountsInput
    Pipeline?: PipelinesCreateNestedManyWithoutSubAccountInput
    Tags?: TagsCreateNestedManyWithoutSubAccountsInput
    Notification?: NotificationsCreateNestedManyWithoutSubAccountsInput
    SubAccountSidebarOption?: SubAccountSidebarOptionCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountsUncheckedCreateWithoutFunnelsInput = {
    id?: string
    connectAccountId?: string | null
    name: string
    subAcctountLogo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    agencyId: string
    SidebarOption?: AgencySidebarOptionUncheckedCreateNestedManyWithoutSubAccountsInput
    Permissions?: PermissionsUncheckedCreateNestedManyWithoutSubAcctountInput
    Media?: MediaUncheckedCreateNestedManyWithoutSubAccountsInput
    Contact?: ContactsUncheckedCreateNestedManyWithoutSubAccountsInput
    Trigger?: TriggersUncheckedCreateNestedManyWithoutSubAccountsInput
    Automation?: AutomationsUncheckedCreateNestedManyWithoutSubAccountsInput
    Pipeline?: PipelinesUncheckedCreateNestedManyWithoutSubAccountInput
    Tags?: TagsUncheckedCreateNestedManyWithoutSubAccountsInput
    Notification?: NotificationsUncheckedCreateNestedManyWithoutSubAccountsInput
    SubAccountSidebarOption?: SubAccountSidebarOptionUncheckedCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountsCreateOrConnectWithoutFunnelsInput = {
    where: SubAccountsWhereUniqueInput
    create: XOR<SubAccountsCreateWithoutFunnelsInput, SubAccountsUncheckedCreateWithoutFunnelsInput>
  }

  export type FunelPagesCreateWithoutFunnelInput = {
    id?: string
    name: string
    pathName?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    visits?: number
    content?: string | null
    order: number
    previewImage: string
  }

  export type FunelPagesUncheckedCreateWithoutFunnelInput = {
    id?: string
    name: string
    pathName?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    visits?: number
    content?: string | null
    order: number
    previewImage: string
  }

  export type FunelPagesCreateOrConnectWithoutFunnelInput = {
    where: FunelPagesWhereUniqueInput
    create: XOR<FunelPagesCreateWithoutFunnelInput, FunelPagesUncheckedCreateWithoutFunnelInput>
  }

  export type FunelPagesCreateManyFunnelInputEnvelope = {
    data: FunelPagesCreateManyFunnelInput | FunelPagesCreateManyFunnelInput[]
    skipDuplicates?: boolean
  }

  export type ClassNameCreateWithoutFunnelInput = {
    id?: string
    name: string
    color: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customData?: string | null
  }

  export type ClassNameUncheckedCreateWithoutFunnelInput = {
    id?: string
    name: string
    color: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customData?: string | null
  }

  export type ClassNameCreateOrConnectWithoutFunnelInput = {
    where: ClassNameWhereUniqueInput
    create: XOR<ClassNameCreateWithoutFunnelInput, ClassNameUncheckedCreateWithoutFunnelInput>
  }

  export type ClassNameCreateManyFunnelInputEnvelope = {
    data: ClassNameCreateManyFunnelInput | ClassNameCreateManyFunnelInput[]
    skipDuplicates?: boolean
  }

  export type SubAccountsUpsertWithoutFunnelsInput = {
    update: XOR<SubAccountsUpdateWithoutFunnelsInput, SubAccountsUncheckedUpdateWithoutFunnelsInput>
    create: XOR<SubAccountsCreateWithoutFunnelsInput, SubAccountsUncheckedCreateWithoutFunnelsInput>
    where?: SubAccountsWhereInput
  }

  export type SubAccountsUpdateToOneWithWhereWithoutFunnelsInput = {
    where?: SubAccountsWhereInput
    data: XOR<SubAccountsUpdateWithoutFunnelsInput, SubAccountsUncheckedUpdateWithoutFunnelsInput>
  }

  export type SubAccountsUpdateWithoutFunnelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAcctountLogo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    Agency?: AgencyUpdateOneRequiredWithoutSubAccountNestedInput
    SidebarOption?: AgencySidebarOptionUpdateManyWithoutSubAccountsNestedInput
    Permissions?: PermissionsUpdateManyWithoutSubAcctountNestedInput
    Media?: MediaUpdateManyWithoutSubAccountsNestedInput
    Contact?: ContactsUpdateManyWithoutSubAccountsNestedInput
    Trigger?: TriggersUpdateManyWithoutSubAccountsNestedInput
    Automation?: AutomationsUpdateManyWithoutSubAccountsNestedInput
    Pipeline?: PipelinesUpdateManyWithoutSubAccountNestedInput
    Tags?: TagsUpdateManyWithoutSubAccountsNestedInput
    Notification?: NotificationsUpdateManyWithoutSubAccountsNestedInput
    SubAccountSidebarOption?: SubAccountSidebarOptionUpdateManyWithoutSubAccountNestedInput
  }

  export type SubAccountsUncheckedUpdateWithoutFunnelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAcctountLogo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    SidebarOption?: AgencySidebarOptionUncheckedUpdateManyWithoutSubAccountsNestedInput
    Permissions?: PermissionsUncheckedUpdateManyWithoutSubAcctountNestedInput
    Media?: MediaUncheckedUpdateManyWithoutSubAccountsNestedInput
    Contact?: ContactsUncheckedUpdateManyWithoutSubAccountsNestedInput
    Trigger?: TriggersUncheckedUpdateManyWithoutSubAccountsNestedInput
    Automation?: AutomationsUncheckedUpdateManyWithoutSubAccountsNestedInput
    Pipeline?: PipelinesUncheckedUpdateManyWithoutSubAccountNestedInput
    Tags?: TagsUncheckedUpdateManyWithoutSubAccountsNestedInput
    Notification?: NotificationsUncheckedUpdateManyWithoutSubAccountsNestedInput
    SubAccountSidebarOption?: SubAccountSidebarOptionUncheckedUpdateManyWithoutSubAccountNestedInput
  }

  export type FunelPagesUpsertWithWhereUniqueWithoutFunnelInput = {
    where: FunelPagesWhereUniqueInput
    update: XOR<FunelPagesUpdateWithoutFunnelInput, FunelPagesUncheckedUpdateWithoutFunnelInput>
    create: XOR<FunelPagesCreateWithoutFunnelInput, FunelPagesUncheckedCreateWithoutFunnelInput>
  }

  export type FunelPagesUpdateWithWhereUniqueWithoutFunnelInput = {
    where: FunelPagesWhereUniqueInput
    data: XOR<FunelPagesUpdateWithoutFunnelInput, FunelPagesUncheckedUpdateWithoutFunnelInput>
  }

  export type FunelPagesUpdateManyWithWhereWithoutFunnelInput = {
    where: FunelPagesScalarWhereInput
    data: XOR<FunelPagesUpdateManyMutationInput, FunelPagesUncheckedUpdateManyWithoutFunnelInput>
  }

  export type FunelPagesScalarWhereInput = {
    AND?: FunelPagesScalarWhereInput | FunelPagesScalarWhereInput[]
    OR?: FunelPagesScalarWhereInput[]
    NOT?: FunelPagesScalarWhereInput | FunelPagesScalarWhereInput[]
    id?: StringFilter<"FunelPages"> | string
    name?: StringFilter<"FunelPages"> | string
    pathName?: StringFilter<"FunelPages"> | string
    createdAt?: DateTimeFilter<"FunelPages"> | Date | string
    updatedAt?: DateTimeFilter<"FunelPages"> | Date | string
    visits?: IntFilter<"FunelPages"> | number
    content?: StringNullableFilter<"FunelPages"> | string | null
    order?: IntFilter<"FunelPages"> | number
    previewImage?: StringFilter<"FunelPages"> | string
    funnelId?: StringFilter<"FunelPages"> | string
  }

  export type ClassNameUpsertWithWhereUniqueWithoutFunnelInput = {
    where: ClassNameWhereUniqueInput
    update: XOR<ClassNameUpdateWithoutFunnelInput, ClassNameUncheckedUpdateWithoutFunnelInput>
    create: XOR<ClassNameCreateWithoutFunnelInput, ClassNameUncheckedCreateWithoutFunnelInput>
  }

  export type ClassNameUpdateWithWhereUniqueWithoutFunnelInput = {
    where: ClassNameWhereUniqueInput
    data: XOR<ClassNameUpdateWithoutFunnelInput, ClassNameUncheckedUpdateWithoutFunnelInput>
  }

  export type ClassNameUpdateManyWithWhereWithoutFunnelInput = {
    where: ClassNameScalarWhereInput
    data: XOR<ClassNameUpdateManyMutationInput, ClassNameUncheckedUpdateManyWithoutFunnelInput>
  }

  export type ClassNameScalarWhereInput = {
    AND?: ClassNameScalarWhereInput | ClassNameScalarWhereInput[]
    OR?: ClassNameScalarWhereInput[]
    NOT?: ClassNameScalarWhereInput | ClassNameScalarWhereInput[]
    id?: StringFilter<"ClassName"> | string
    name?: StringFilter<"ClassName"> | string
    color?: StringFilter<"ClassName"> | string
    createdAt?: DateTimeFilter<"ClassName"> | Date | string
    updatedAt?: DateTimeFilter<"ClassName"> | Date | string
    funnelId?: StringFilter<"ClassName"> | string
    customData?: StringNullableFilter<"ClassName"> | string | null
  }

  export type UsersCreateWithoutNotificationInput = {
    id?: string
    name: string
    avatarUrl: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.Role
    Agency?: AgencyCreateNestedOneWithoutUserInput
    Permission?: PermissionsCreateNestedManyWithoutUsersInput
    Ticket?: TicketsCreateNestedManyWithoutUsersInput
  }

  export type UsersUncheckedCreateWithoutNotificationInput = {
    id?: string
    name: string
    avatarUrl: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.Role
    agencyId?: string | null
    Permission?: PermissionsUncheckedCreateNestedManyWithoutUsersInput
    Ticket?: TicketsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UsersCreateOrConnectWithoutNotificationInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutNotificationInput, UsersUncheckedCreateWithoutNotificationInput>
  }

  export type AgencyCreateWithoutNotificationInput = {
    id?: string
    connectAccountId?: string | null
    customerId?: string
    name: string
    agencyLogo: string
    companyEmail: string
    companyPhone: string
    whiteLabel?: boolean
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    goal: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UsersCreateNestedManyWithoutAgencyInput
    SubAccount?: SubAccountsCreateNestedManyWithoutAgencyInput
    SidebarOption?: AgencySidebarOptionCreateNestedManyWithoutAgencyInput
    Invitation?: InvitationsCreateNestedManyWithoutAgencyInput
    Subscription?: SubscriptionsCreateNestedOneWithoutAgencyInput
    AddOns?: AddOnsCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUncheckedCreateWithoutNotificationInput = {
    id?: string
    connectAccountId?: string | null
    customerId?: string
    name: string
    agencyLogo: string
    companyEmail: string
    companyPhone: string
    whiteLabel?: boolean
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    goal: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UsersUncheckedCreateNestedManyWithoutAgencyInput
    SubAccount?: SubAccountsUncheckedCreateNestedManyWithoutAgencyInput
    SidebarOption?: AgencySidebarOptionUncheckedCreateNestedManyWithoutAgencyInput
    Invitation?: InvitationsUncheckedCreateNestedManyWithoutAgencyInput
    Subscription?: SubscriptionsUncheckedCreateNestedOneWithoutAgencyInput
    AddOns?: AddOnsUncheckedCreateNestedManyWithoutAgencyInput
  }

  export type AgencyCreateOrConnectWithoutNotificationInput = {
    where: AgencyWhereUniqueInput
    create: XOR<AgencyCreateWithoutNotificationInput, AgencyUncheckedCreateWithoutNotificationInput>
  }

  export type SubAccountsCreateWithoutNotificationInput = {
    id?: string
    connectAccountId?: string | null
    name: string
    subAcctountLogo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    Agency: AgencyCreateNestedOneWithoutSubAccountInput
    SidebarOption?: AgencySidebarOptionCreateNestedManyWithoutSubAccountsInput
    Permissions?: PermissionsCreateNestedManyWithoutSubAcctountInput
    Funnels?: FunnelsCreateNestedManyWithoutSubAccountInput
    Media?: MediaCreateNestedManyWithoutSubAccountsInput
    Contact?: ContactsCreateNestedManyWithoutSubAccountsInput
    Trigger?: TriggersCreateNestedManyWithoutSubAccountsInput
    Automation?: AutomationsCreateNestedManyWithoutSubAccountsInput
    Pipeline?: PipelinesCreateNestedManyWithoutSubAccountInput
    Tags?: TagsCreateNestedManyWithoutSubAccountsInput
    SubAccountSidebarOption?: SubAccountSidebarOptionCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountsUncheckedCreateWithoutNotificationInput = {
    id?: string
    connectAccountId?: string | null
    name: string
    subAcctountLogo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    agencyId: string
    SidebarOption?: AgencySidebarOptionUncheckedCreateNestedManyWithoutSubAccountsInput
    Permissions?: PermissionsUncheckedCreateNestedManyWithoutSubAcctountInput
    Funnels?: FunnelsUncheckedCreateNestedManyWithoutSubAccountInput
    Media?: MediaUncheckedCreateNestedManyWithoutSubAccountsInput
    Contact?: ContactsUncheckedCreateNestedManyWithoutSubAccountsInput
    Trigger?: TriggersUncheckedCreateNestedManyWithoutSubAccountsInput
    Automation?: AutomationsUncheckedCreateNestedManyWithoutSubAccountsInput
    Pipeline?: PipelinesUncheckedCreateNestedManyWithoutSubAccountInput
    Tags?: TagsUncheckedCreateNestedManyWithoutSubAccountsInput
    SubAccountSidebarOption?: SubAccountSidebarOptionUncheckedCreateNestedManyWithoutSubAccountInput
  }

  export type SubAccountsCreateOrConnectWithoutNotificationInput = {
    where: SubAccountsWhereUniqueInput
    create: XOR<SubAccountsCreateWithoutNotificationInput, SubAccountsUncheckedCreateWithoutNotificationInput>
  }

  export type UsersUpsertWithoutNotificationInput = {
    update: XOR<UsersUpdateWithoutNotificationInput, UsersUncheckedUpdateWithoutNotificationInput>
    create: XOR<UsersCreateWithoutNotificationInput, UsersUncheckedCreateWithoutNotificationInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutNotificationInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutNotificationInput, UsersUncheckedUpdateWithoutNotificationInput>
  }

  export type UsersUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    Agency?: AgencyUpdateOneWithoutUserNestedInput
    Permission?: PermissionsUpdateManyWithoutUsersNestedInput
    Ticket?: TicketsUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    agencyId?: NullableStringFieldUpdateOperationsInput | string | null
    Permission?: PermissionsUncheckedUpdateManyWithoutUsersNestedInput
    Ticket?: TicketsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type AgencyUpsertWithoutNotificationInput = {
    update: XOR<AgencyUpdateWithoutNotificationInput, AgencyUncheckedUpdateWithoutNotificationInput>
    create: XOR<AgencyCreateWithoutNotificationInput, AgencyUncheckedCreateWithoutNotificationInput>
    where?: AgencyWhereInput
  }

  export type AgencyUpdateToOneWithWhereWithoutNotificationInput = {
    where?: AgencyWhereInput
    data: XOR<AgencyUpdateWithoutNotificationInput, AgencyUncheckedUpdateWithoutNotificationInput>
  }

  export type AgencyUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    agencyLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    whiteLabel?: BoolFieldUpdateOperationsInput | boolean
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateManyWithoutAgencyNestedInput
    SubAccount?: SubAccountsUpdateManyWithoutAgencyNestedInput
    SidebarOption?: AgencySidebarOptionUpdateManyWithoutAgencyNestedInput
    Invitation?: InvitationsUpdateManyWithoutAgencyNestedInput
    Subscription?: SubscriptionsUpdateOneWithoutAgencyNestedInput
    AddOns?: AddOnsUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    agencyLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    whiteLabel?: BoolFieldUpdateOperationsInput | boolean
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUncheckedUpdateManyWithoutAgencyNestedInput
    SubAccount?: SubAccountsUncheckedUpdateManyWithoutAgencyNestedInput
    SidebarOption?: AgencySidebarOptionUncheckedUpdateManyWithoutAgencyNestedInput
    Invitation?: InvitationsUncheckedUpdateManyWithoutAgencyNestedInput
    Subscription?: SubscriptionsUncheckedUpdateOneWithoutAgencyNestedInput
    AddOns?: AddOnsUncheckedUpdateManyWithoutAgencyNestedInput
  }

  export type SubAccountsUpsertWithoutNotificationInput = {
    update: XOR<SubAccountsUpdateWithoutNotificationInput, SubAccountsUncheckedUpdateWithoutNotificationInput>
    create: XOR<SubAccountsCreateWithoutNotificationInput, SubAccountsUncheckedCreateWithoutNotificationInput>
    where?: SubAccountsWhereInput
  }

  export type SubAccountsUpdateToOneWithWhereWithoutNotificationInput = {
    where?: SubAccountsWhereInput
    data: XOR<SubAccountsUpdateWithoutNotificationInput, SubAccountsUncheckedUpdateWithoutNotificationInput>
  }

  export type SubAccountsUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAcctountLogo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    Agency?: AgencyUpdateOneRequiredWithoutSubAccountNestedInput
    SidebarOption?: AgencySidebarOptionUpdateManyWithoutSubAccountsNestedInput
    Permissions?: PermissionsUpdateManyWithoutSubAcctountNestedInput
    Funnels?: FunnelsUpdateManyWithoutSubAccountNestedInput
    Media?: MediaUpdateManyWithoutSubAccountsNestedInput
    Contact?: ContactsUpdateManyWithoutSubAccountsNestedInput
    Trigger?: TriggersUpdateManyWithoutSubAccountsNestedInput
    Automation?: AutomationsUpdateManyWithoutSubAccountsNestedInput
    Pipeline?: PipelinesUpdateManyWithoutSubAccountNestedInput
    Tags?: TagsUpdateManyWithoutSubAccountsNestedInput
    SubAccountSidebarOption?: SubAccountSidebarOptionUpdateManyWithoutSubAccountNestedInput
  }

  export type SubAccountsUncheckedUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAcctountLogo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    SidebarOption?: AgencySidebarOptionUncheckedUpdateManyWithoutSubAccountsNestedInput
    Permissions?: PermissionsUncheckedUpdateManyWithoutSubAcctountNestedInput
    Funnels?: FunnelsUncheckedUpdateManyWithoutSubAccountNestedInput
    Media?: MediaUncheckedUpdateManyWithoutSubAccountsNestedInput
    Contact?: ContactsUncheckedUpdateManyWithoutSubAccountsNestedInput
    Trigger?: TriggersUncheckedUpdateManyWithoutSubAccountsNestedInput
    Automation?: AutomationsUncheckedUpdateManyWithoutSubAccountsNestedInput
    Pipeline?: PipelinesUncheckedUpdateManyWithoutSubAccountNestedInput
    Tags?: TagsUncheckedUpdateManyWithoutSubAccountsNestedInput
    SubAccountSidebarOption?: SubAccountSidebarOptionUncheckedUpdateManyWithoutSubAccountNestedInput
  }

  export type AgencyCreateWithoutSubscriptionInput = {
    id?: string
    connectAccountId?: string | null
    customerId?: string
    name: string
    agencyLogo: string
    companyEmail: string
    companyPhone: string
    whiteLabel?: boolean
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    goal: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UsersCreateNestedManyWithoutAgencyInput
    SubAccount?: SubAccountsCreateNestedManyWithoutAgencyInput
    SidebarOption?: AgencySidebarOptionCreateNestedManyWithoutAgencyInput
    Invitation?: InvitationsCreateNestedManyWithoutAgencyInput
    Notification?: NotificationsCreateNestedManyWithoutAgencyInput
    AddOns?: AddOnsCreateNestedManyWithoutAgencyInput
  }

  export type AgencyUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    connectAccountId?: string | null
    customerId?: string
    name: string
    agencyLogo: string
    companyEmail: string
    companyPhone: string
    whiteLabel?: boolean
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    goal: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UsersUncheckedCreateNestedManyWithoutAgencyInput
    SubAccount?: SubAccountsUncheckedCreateNestedManyWithoutAgencyInput
    SidebarOption?: AgencySidebarOptionUncheckedCreateNestedManyWithoutAgencyInput
    Invitation?: InvitationsUncheckedCreateNestedManyWithoutAgencyInput
    Notification?: NotificationsUncheckedCreateNestedManyWithoutAgencyInput
    AddOns?: AddOnsUncheckedCreateNestedManyWithoutAgencyInput
  }

  export type AgencyCreateOrConnectWithoutSubscriptionInput = {
    where: AgencyWhereUniqueInput
    create: XOR<AgencyCreateWithoutSubscriptionInput, AgencyUncheckedCreateWithoutSubscriptionInput>
  }

  export type AgencyUpsertWithoutSubscriptionInput = {
    update: XOR<AgencyUpdateWithoutSubscriptionInput, AgencyUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<AgencyCreateWithoutSubscriptionInput, AgencyUncheckedCreateWithoutSubscriptionInput>
    where?: AgencyWhereInput
  }

  export type AgencyUpdateToOneWithWhereWithoutSubscriptionInput = {
    where?: AgencyWhereInput
    data: XOR<AgencyUpdateWithoutSubscriptionInput, AgencyUncheckedUpdateWithoutSubscriptionInput>
  }

  export type AgencyUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    agencyLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    whiteLabel?: BoolFieldUpdateOperationsInput | boolean
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateManyWithoutAgencyNestedInput
    SubAccount?: SubAccountsUpdateManyWithoutAgencyNestedInput
    SidebarOption?: AgencySidebarOptionUpdateManyWithoutAgencyNestedInput
    Invitation?: InvitationsUpdateManyWithoutAgencyNestedInput
    Notification?: NotificationsUpdateManyWithoutAgencyNestedInput
    AddOns?: AddOnsUpdateManyWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    agencyLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    whiteLabel?: BoolFieldUpdateOperationsInput | boolean
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUncheckedUpdateManyWithoutAgencyNestedInput
    SubAccount?: SubAccountsUncheckedUpdateManyWithoutAgencyNestedInput
    SidebarOption?: AgencySidebarOptionUncheckedUpdateManyWithoutAgencyNestedInput
    Invitation?: InvitationsUncheckedUpdateManyWithoutAgencyNestedInput
    Notification?: NotificationsUncheckedUpdateManyWithoutAgencyNestedInput
    AddOns?: AddOnsUncheckedUpdateManyWithoutAgencyNestedInput
  }

  export type FunnelsCreateWithoutClassNameInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    published?: boolean
    subDomainName?: string | null
    favicon?: string | null
    liveProducts?: string | null
    SubAccount: SubAccountsCreateNestedOneWithoutFunnelsInput
    FunelPages?: FunelPagesCreateNestedManyWithoutFunnelInput
  }

  export type FunnelsUncheckedCreateWithoutClassNameInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    published?: boolean
    subDomainName?: string | null
    favicon?: string | null
    subAccountId: string
    liveProducts?: string | null
    FunelPages?: FunelPagesUncheckedCreateNestedManyWithoutFunnelInput
  }

  export type FunnelsCreateOrConnectWithoutClassNameInput = {
    where: FunnelsWhereUniqueInput
    create: XOR<FunnelsCreateWithoutClassNameInput, FunnelsUncheckedCreateWithoutClassNameInput>
  }

  export type FunnelsUpsertWithoutClassNameInput = {
    update: XOR<FunnelsUpdateWithoutClassNameInput, FunnelsUncheckedUpdateWithoutClassNameInput>
    create: XOR<FunnelsCreateWithoutClassNameInput, FunnelsUncheckedCreateWithoutClassNameInput>
    where?: FunnelsWhereInput
  }

  export type FunnelsUpdateToOneWithWhereWithoutClassNameInput = {
    where?: FunnelsWhereInput
    data: XOR<FunnelsUpdateWithoutClassNameInput, FunnelsUncheckedUpdateWithoutClassNameInput>
  }

  export type FunnelsUpdateWithoutClassNameInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    subDomainName?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    liveProducts?: NullableStringFieldUpdateOperationsInput | string | null
    SubAccount?: SubAccountsUpdateOneRequiredWithoutFunnelsNestedInput
    FunelPages?: FunelPagesUpdateManyWithoutFunnelNestedInput
  }

  export type FunnelsUncheckedUpdateWithoutClassNameInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    subDomainName?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    subAccountId?: StringFieldUpdateOperationsInput | string
    liveProducts?: NullableStringFieldUpdateOperationsInput | string | null
    FunelPages?: FunelPagesUncheckedUpdateManyWithoutFunnelNestedInput
  }

  export type FunnelsCreateWithoutFunelPagesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    published?: boolean
    subDomainName?: string | null
    favicon?: string | null
    liveProducts?: string | null
    SubAccount: SubAccountsCreateNestedOneWithoutFunnelsInput
    className?: ClassNameCreateNestedManyWithoutFunnelInput
  }

  export type FunnelsUncheckedCreateWithoutFunelPagesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    published?: boolean
    subDomainName?: string | null
    favicon?: string | null
    subAccountId: string
    liveProducts?: string | null
    className?: ClassNameUncheckedCreateNestedManyWithoutFunnelInput
  }

  export type FunnelsCreateOrConnectWithoutFunelPagesInput = {
    where: FunnelsWhereUniqueInput
    create: XOR<FunnelsCreateWithoutFunelPagesInput, FunnelsUncheckedCreateWithoutFunelPagesInput>
  }

  export type FunnelsUpsertWithoutFunelPagesInput = {
    update: XOR<FunnelsUpdateWithoutFunelPagesInput, FunnelsUncheckedUpdateWithoutFunelPagesInput>
    create: XOR<FunnelsCreateWithoutFunelPagesInput, FunnelsUncheckedCreateWithoutFunelPagesInput>
    where?: FunnelsWhereInput
  }

  export type FunnelsUpdateToOneWithWhereWithoutFunelPagesInput = {
    where?: FunnelsWhereInput
    data: XOR<FunnelsUpdateWithoutFunelPagesInput, FunnelsUncheckedUpdateWithoutFunelPagesInput>
  }

  export type FunnelsUpdateWithoutFunelPagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    subDomainName?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    liveProducts?: NullableStringFieldUpdateOperationsInput | string | null
    SubAccount?: SubAccountsUpdateOneRequiredWithoutFunnelsNestedInput
    className?: ClassNameUpdateManyWithoutFunnelNestedInput
  }

  export type FunnelsUncheckedUpdateWithoutFunelPagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    subDomainName?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    subAccountId?: StringFieldUpdateOperationsInput | string
    liveProducts?: NullableStringFieldUpdateOperationsInput | string | null
    className?: ClassNameUncheckedUpdateManyWithoutFunnelNestedInput
  }

  export type AgencyCreateWithoutAddOnsInput = {
    id?: string
    connectAccountId?: string | null
    customerId?: string
    name: string
    agencyLogo: string
    companyEmail: string
    companyPhone: string
    whiteLabel?: boolean
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    goal: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UsersCreateNestedManyWithoutAgencyInput
    SubAccount?: SubAccountsCreateNestedManyWithoutAgencyInput
    SidebarOption?: AgencySidebarOptionCreateNestedManyWithoutAgencyInput
    Invitation?: InvitationsCreateNestedManyWithoutAgencyInput
    Notification?: NotificationsCreateNestedManyWithoutAgencyInput
    Subscription?: SubscriptionsCreateNestedOneWithoutAgencyInput
  }

  export type AgencyUncheckedCreateWithoutAddOnsInput = {
    id?: string
    connectAccountId?: string | null
    customerId?: string
    name: string
    agencyLogo: string
    companyEmail: string
    companyPhone: string
    whiteLabel?: boolean
    address: string
    city: string
    zipCode: string
    state: string
    country: string
    goal: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UsersUncheckedCreateNestedManyWithoutAgencyInput
    SubAccount?: SubAccountsUncheckedCreateNestedManyWithoutAgencyInput
    SidebarOption?: AgencySidebarOptionUncheckedCreateNestedManyWithoutAgencyInput
    Invitation?: InvitationsUncheckedCreateNestedManyWithoutAgencyInput
    Notification?: NotificationsUncheckedCreateNestedManyWithoutAgencyInput
    Subscription?: SubscriptionsUncheckedCreateNestedOneWithoutAgencyInput
  }

  export type AgencyCreateOrConnectWithoutAddOnsInput = {
    where: AgencyWhereUniqueInput
    create: XOR<AgencyCreateWithoutAddOnsInput, AgencyUncheckedCreateWithoutAddOnsInput>
  }

  export type AgencyUpsertWithoutAddOnsInput = {
    update: XOR<AgencyUpdateWithoutAddOnsInput, AgencyUncheckedUpdateWithoutAddOnsInput>
    create: XOR<AgencyCreateWithoutAddOnsInput, AgencyUncheckedCreateWithoutAddOnsInput>
    where?: AgencyWhereInput
  }

  export type AgencyUpdateToOneWithWhereWithoutAddOnsInput = {
    where?: AgencyWhereInput
    data: XOR<AgencyUpdateWithoutAddOnsInput, AgencyUncheckedUpdateWithoutAddOnsInput>
  }

  export type AgencyUpdateWithoutAddOnsInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    agencyLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    whiteLabel?: BoolFieldUpdateOperationsInput | boolean
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUpdateManyWithoutAgencyNestedInput
    SubAccount?: SubAccountsUpdateManyWithoutAgencyNestedInput
    SidebarOption?: AgencySidebarOptionUpdateManyWithoutAgencyNestedInput
    Invitation?: InvitationsUpdateManyWithoutAgencyNestedInput
    Notification?: NotificationsUpdateManyWithoutAgencyNestedInput
    Subscription?: SubscriptionsUpdateOneWithoutAgencyNestedInput
  }

  export type AgencyUncheckedUpdateWithoutAddOnsInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    agencyLogo?: StringFieldUpdateOperationsInput | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    whiteLabel?: BoolFieldUpdateOperationsInput | boolean
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UsersUncheckedUpdateManyWithoutAgencyNestedInput
    SubAccount?: SubAccountsUncheckedUpdateManyWithoutAgencyNestedInput
    SidebarOption?: AgencySidebarOptionUncheckedUpdateManyWithoutAgencyNestedInput
    Invitation?: InvitationsUncheckedUpdateManyWithoutAgencyNestedInput
    Notification?: NotificationsUncheckedUpdateManyWithoutAgencyNestedInput
    Subscription?: SubscriptionsUncheckedUpdateOneWithoutAgencyNestedInput
  }

  export type PermissionsCreateManyUsersInput = {
    id?: string
    subAccontId: string
    access: boolean
  }

  export type TicketsCreateManyUsersInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lineId: string
    order?: number
    value?: Decimal | DecimalJsLike | number | string | null
    description?: string | null
    contactId?: string | null
  }

  export type NotificationsCreateManyUsersInput = {
    id?: string
    notification: string
    agencyId: string
    subAccountId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PermissionsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    access?: BoolFieldUpdateOperationsInput | boolean
    SubAcctount?: SubAccountsUpdateOneRequiredWithoutPermissionsNestedInput
  }

  export type PermissionsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    subAccontId?: StringFieldUpdateOperationsInput | string
    access?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PermissionsUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    subAccontId?: StringFieldUpdateOperationsInput | string
    access?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TicketsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    Lane?: LaneUpdateOneRequiredWithoutTicketsNestedInput
    tags?: TagsUpdateManyWithoutTicketsNestedInput
    Contacts?: ContactsUpdateOneWithoutTicketsNestedInput
  }

  export type TicketsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lineId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TagsUncheckedUpdateManyWithoutTicketsNestedInput
  }

  export type TicketsUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lineId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    notification?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Agency?: AgencyUpdateOneRequiredWithoutNotificationNestedInput
    SubAccounts?: SubAccountsUpdateOneWithoutNotificationNestedInput
  }

  export type NotificationsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    notification?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    subAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationsUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    notification?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    subAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsersCreateManyAgencyInput = {
    id?: string
    name: string
    avatarUrl: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: $Enums.Role
  }

  export type SubAccountsCreateManyAgencyInput = {
    id?: string
    connectAccountId?: string | null
    name: string
    subAcctountLogo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyEmail: string
    companyPhone: string
    goal?: number
    address: string
    city: string
    zipCode: string
    state: string
    country: string
  }

  export type AgencySidebarOptionCreateManyAgencyInput = {
    id?: string
    name?: string
    link?: string
    icon?: $Enums.Icon
    createdAt?: Date | string
    updatedAt?: Date | string
    subAccountId?: string | null
  }

  export type InvitationsCreateManyAgencyInput = {
    id?: string
    email: string
    status?: $Enums.InvitationStatus
    role?: $Enums.Role
  }

  export type NotificationsCreateManyAgencyInput = {
    id?: string
    notification: string
    subAccountId?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddOnsCreateManyAgencyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    active?: boolean
    priceId: string
  }

  export type UsersUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    Permission?: PermissionsUpdateManyWithoutUsersNestedInput
    Ticket?: TicketsUpdateManyWithoutUsersNestedInput
    Notification?: NotificationsUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    Permission?: PermissionsUncheckedUpdateManyWithoutUsersNestedInput
    Ticket?: TicketsUncheckedUpdateManyWithoutUsersNestedInput
    Notification?: NotificationsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UsersUncheckedUpdateManyWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatarUrl?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
  }

  export type SubAccountsUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAcctountLogo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    SidebarOption?: AgencySidebarOptionUpdateManyWithoutSubAccountsNestedInput
    Permissions?: PermissionsUpdateManyWithoutSubAcctountNestedInput
    Funnels?: FunnelsUpdateManyWithoutSubAccountNestedInput
    Media?: MediaUpdateManyWithoutSubAccountsNestedInput
    Contact?: ContactsUpdateManyWithoutSubAccountsNestedInput
    Trigger?: TriggersUpdateManyWithoutSubAccountsNestedInput
    Automation?: AutomationsUpdateManyWithoutSubAccountsNestedInput
    Pipeline?: PipelinesUpdateManyWithoutSubAccountNestedInput
    Tags?: TagsUpdateManyWithoutSubAccountsNestedInput
    Notification?: NotificationsUpdateManyWithoutSubAccountsNestedInput
    SubAccountSidebarOption?: SubAccountSidebarOptionUpdateManyWithoutSubAccountNestedInput
  }

  export type SubAccountsUncheckedUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAcctountLogo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    SidebarOption?: AgencySidebarOptionUncheckedUpdateManyWithoutSubAccountsNestedInput
    Permissions?: PermissionsUncheckedUpdateManyWithoutSubAcctountNestedInput
    Funnels?: FunnelsUncheckedUpdateManyWithoutSubAccountNestedInput
    Media?: MediaUncheckedUpdateManyWithoutSubAccountsNestedInput
    Contact?: ContactsUncheckedUpdateManyWithoutSubAccountsNestedInput
    Trigger?: TriggersUncheckedUpdateManyWithoutSubAccountsNestedInput
    Automation?: AutomationsUncheckedUpdateManyWithoutSubAccountsNestedInput
    Pipeline?: PipelinesUncheckedUpdateManyWithoutSubAccountNestedInput
    Tags?: TagsUncheckedUpdateManyWithoutSubAccountsNestedInput
    Notification?: NotificationsUncheckedUpdateManyWithoutSubAccountsNestedInput
    SubAccountSidebarOption?: SubAccountSidebarOptionUncheckedUpdateManyWithoutSubAccountNestedInput
  }

  export type SubAccountsUncheckedUpdateManyWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    subAcctountLogo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyEmail?: StringFieldUpdateOperationsInput | string
    companyPhone?: StringFieldUpdateOperationsInput | string
    goal?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
  }

  export type AgencySidebarOptionUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    icon?: EnumIconFieldUpdateOperationsInput | $Enums.Icon
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SubAccounts?: SubAccountsUpdateOneWithoutSidebarOptionNestedInput
  }

  export type AgencySidebarOptionUncheckedUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    icon?: EnumIconFieldUpdateOperationsInput | $Enums.Icon
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subAccountId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AgencySidebarOptionUncheckedUpdateManyWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    icon?: EnumIconFieldUpdateOperationsInput | $Enums.Icon
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subAccountId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InvitationsUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
  }

  export type InvitationsUncheckedUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
  }

  export type InvitationsUncheckedUpdateManyWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
  }

  export type NotificationsUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    notification?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Users?: UsersUpdateOneRequiredWithoutNotificationNestedInput
    SubAccounts?: SubAccountsUpdateOneWithoutNotificationNestedInput
  }

  export type NotificationsUncheckedUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    notification?: StringFieldUpdateOperationsInput | string
    subAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationsUncheckedUpdateManyWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    notification?: StringFieldUpdateOperationsInput | string
    subAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddOnsUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    priceId?: StringFieldUpdateOperationsInput | string
  }

  export type AddOnsUncheckedUpdateWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    priceId?: StringFieldUpdateOperationsInput | string
  }

  export type AddOnsUncheckedUpdateManyWithoutAgencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    priceId?: StringFieldUpdateOperationsInput | string
  }

  export type AgencySidebarOptionCreateManySubAccountsInput = {
    id?: string
    name?: string
    link?: string
    icon?: $Enums.Icon
    createdAt?: Date | string
    updatedAt?: Date | string
    agencyId: string
  }

  export type PermissionsCreateManySubAcctountInput = {
    id?: string
    email: string
    access: boolean
  }

  export type FunnelsCreateManySubAccountInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description?: string | null
    published?: boolean
    subDomainName?: string | null
    favicon?: string | null
    liveProducts?: string | null
  }

  export type MediaCreateManySubAccountsInput = {
    id?: string
    type?: string | null
    name: string
    link: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactsCreateManySubAccountsInput = {
    id?: string
    name: string
    email: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TriggersCreateManySubAccountsInput = {
    id?: string
    name: string
    type: $Enums.TriggerTypes
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AutomationsCreateManySubAccountsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    triggerId?: string | null
    published?: boolean
  }

  export type PipelinesCreateManySubAccountInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagsCreateManySubAccountsInput = {
    id?: string
    nane: string
    color: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationsCreateManySubAccountsInput = {
    id?: string
    notification: string
    agencyId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubAccountSidebarOptionCreateManySubAccountInput = {
    id?: string
    name: string
    link?: string
    icon?: $Enums.Icon
    createdAt?: Date | string
    updatedAt?: Date | string
    subAccount?: string | null
  }

  export type AgencySidebarOptionUpdateWithoutSubAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    icon?: EnumIconFieldUpdateOperationsInput | $Enums.Icon
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Agency?: AgencyUpdateOneRequiredWithoutSidebarOptionNestedInput
  }

  export type AgencySidebarOptionUncheckedUpdateWithoutSubAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    icon?: EnumIconFieldUpdateOperationsInput | $Enums.Icon
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agencyId?: StringFieldUpdateOperationsInput | string
  }

  export type AgencySidebarOptionUncheckedUpdateManyWithoutSubAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    icon?: EnumIconFieldUpdateOperationsInput | $Enums.Icon
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agencyId?: StringFieldUpdateOperationsInput | string
  }

  export type PermissionsUpdateWithoutSubAcctountInput = {
    id?: StringFieldUpdateOperationsInput | string
    access?: BoolFieldUpdateOperationsInput | boolean
    Users?: UsersUpdateOneRequiredWithoutPermissionNestedInput
  }

  export type PermissionsUncheckedUpdateWithoutSubAcctountInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    access?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PermissionsUncheckedUpdateManyWithoutSubAcctountInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    access?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FunnelsUpdateWithoutSubAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    subDomainName?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    liveProducts?: NullableStringFieldUpdateOperationsInput | string | null
    FunelPages?: FunelPagesUpdateManyWithoutFunnelNestedInput
    className?: ClassNameUpdateManyWithoutFunnelNestedInput
  }

  export type FunnelsUncheckedUpdateWithoutSubAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    subDomainName?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    liveProducts?: NullableStringFieldUpdateOperationsInput | string | null
    FunelPages?: FunelPagesUncheckedUpdateManyWithoutFunnelNestedInput
    className?: ClassNameUncheckedUpdateManyWithoutFunnelNestedInput
  }

  export type FunnelsUncheckedUpdateManyWithoutSubAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    subDomainName?: NullableStringFieldUpdateOperationsInput | string | null
    favicon?: NullableStringFieldUpdateOperationsInput | string | null
    liveProducts?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MediaUpdateWithoutSubAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaUncheckedUpdateWithoutSubAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaUncheckedUpdateManyWithoutSubAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactsUpdateWithoutSubAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Tickets?: TicketsUpdateManyWithoutContactsNestedInput
  }

  export type ContactsUncheckedUpdateWithoutSubAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Tickets?: TicketsUncheckedUpdateManyWithoutContactsNestedInput
  }

  export type ContactsUncheckedUpdateManyWithoutSubAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TriggersUpdateWithoutSubAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTriggerTypesFieldUpdateOperationsInput | $Enums.TriggerTypes
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Automations?: AutomationsUpdateManyWithoutTriggerNestedInput
  }

  export type TriggersUncheckedUpdateWithoutSubAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTriggerTypesFieldUpdateOperationsInput | $Enums.TriggerTypes
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Automations?: AutomationsUncheckedUpdateManyWithoutTriggerNestedInput
  }

  export type TriggersUncheckedUpdateManyWithoutSubAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumTriggerTypesFieldUpdateOperationsInput | $Enums.TriggerTypes
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutomationsUpdateWithoutSubAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    published?: BoolFieldUpdateOperationsInput | boolean
    Trigger?: TriggersUpdateOneWithoutAutomationsNestedInput
    Actions?: ActionsUpdateManyWithoutAutomationsNestedInput
    AutomationInstance?: AutomationInstanceUpdateManyWithoutAutomationsNestedInput
  }

  export type AutomationsUncheckedUpdateWithoutSubAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    triggerId?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    Actions?: ActionsUncheckedUpdateManyWithoutAutomationsNestedInput
    AutomationInstance?: AutomationInstanceUncheckedUpdateManyWithoutAutomationsNestedInput
  }

  export type AutomationsUncheckedUpdateManyWithoutSubAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    triggerId?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PipelinesUpdateWithoutSubAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Lane?: LaneUpdateManyWithoutPipelineNestedInput
  }

  export type PipelinesUncheckedUpdateWithoutSubAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Lane?: LaneUncheckedUpdateManyWithoutPipelineNestedInput
  }

  export type PipelinesUncheckedUpdateManyWithoutSubAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagsUpdateWithoutSubAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nane?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Tickets?: TicketsUpdateManyWithoutTagsNestedInput
  }

  export type TagsUncheckedUpdateWithoutSubAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nane?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Tickets?: TicketsUncheckedUpdateManyWithoutTagsNestedInput
  }

  export type TagsUncheckedUpdateManyWithoutSubAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nane?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationsUpdateWithoutSubAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    notification?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Users?: UsersUpdateOneRequiredWithoutNotificationNestedInput
    Agency?: AgencyUpdateOneRequiredWithoutNotificationNestedInput
  }

  export type NotificationsUncheckedUpdateWithoutSubAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    notification?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationsUncheckedUpdateManyWithoutSubAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    notification?: StringFieldUpdateOperationsInput | string
    agencyId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubAccountSidebarOptionUpdateWithoutSubAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    icon?: EnumIconFieldUpdateOperationsInput | $Enums.Icon
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subAccount?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubAccountSidebarOptionUncheckedUpdateWithoutSubAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    icon?: EnumIconFieldUpdateOperationsInput | $Enums.Icon
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subAccount?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SubAccountSidebarOptionUncheckedUpdateManyWithoutSubAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    icon?: EnumIconFieldUpdateOperationsInput | $Enums.Icon
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subAccount?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LaneCreateManyPipelineInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: number
  }

  export type LaneUpdateWithoutPipelineInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: IntFieldUpdateOperationsInput | number
    Tickets?: TicketsUpdateManyWithoutLaneNestedInput
  }

  export type LaneUncheckedUpdateWithoutPipelineInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: IntFieldUpdateOperationsInput | number
    Tickets?: TicketsUncheckedUpdateManyWithoutLaneNestedInput
  }

  export type LaneUncheckedUpdateManyWithoutPipelineInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type AutomationsCreateManyTriggerInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    published?: boolean
    subAccountId: string
  }

  export type AutomationsUpdateWithoutTriggerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    published?: BoolFieldUpdateOperationsInput | boolean
    SubAccounts?: SubAccountsUpdateOneRequiredWithoutAutomationNestedInput
    Actions?: ActionsUpdateManyWithoutAutomationsNestedInput
    AutomationInstance?: AutomationInstanceUpdateManyWithoutAutomationsNestedInput
  }

  export type AutomationsUncheckedUpdateWithoutTriggerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    published?: BoolFieldUpdateOperationsInput | boolean
    subAccountId?: StringFieldUpdateOperationsInput | string
    Actions?: ActionsUncheckedUpdateManyWithoutAutomationsNestedInput
    AutomationInstance?: AutomationInstanceUncheckedUpdateManyWithoutAutomationsNestedInput
  }

  export type AutomationsUncheckedUpdateManyWithoutTriggerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    published?: BoolFieldUpdateOperationsInput | boolean
    subAccountId?: StringFieldUpdateOperationsInput | string
  }

  export type ActionsCreateManyAutomationsInput = {
    id?: string
    name: string
    type: $Enums.ActionType
    createdAt?: Date | string
    updatedAt?: Date | string
    order: number
    laneId?: string
  }

  export type AutomationInstanceCreateManyAutomationsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    active?: boolean
  }

  export type ActionsUpdateWithoutAutomationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumActionTypeFieldUpdateOperationsInput | $Enums.ActionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: IntFieldUpdateOperationsInput | number
    laneId?: StringFieldUpdateOperationsInput | string
  }

  export type ActionsUncheckedUpdateWithoutAutomationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumActionTypeFieldUpdateOperationsInput | $Enums.ActionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: IntFieldUpdateOperationsInput | number
    laneId?: StringFieldUpdateOperationsInput | string
  }

  export type ActionsUncheckedUpdateManyWithoutAutomationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumActionTypeFieldUpdateOperationsInput | $Enums.ActionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: IntFieldUpdateOperationsInput | number
    laneId?: StringFieldUpdateOperationsInput | string
  }

  export type AutomationInstanceUpdateWithoutAutomationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AutomationInstanceUncheckedUpdateWithoutAutomationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AutomationInstanceUncheckedUpdateManyWithoutAutomationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TicketsCreateManyContactsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lineId: string
    order?: number
    value?: Decimal | DecimalJsLike | number | string | null
    description?: string | null
    userId?: string | null
  }

  export type TicketsUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    Lane?: LaneUpdateOneRequiredWithoutTicketsNestedInput
    tags?: TagsUpdateManyWithoutTicketsNestedInput
    Users?: UsersUpdateOneWithoutTicketNestedInput
  }

  export type TicketsUncheckedUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lineId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TagsUncheckedUpdateManyWithoutTicketsNestedInput
  }

  export type TicketsUncheckedUpdateManyWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lineId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TicketsCreateManyLaneInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    order?: number
    value?: Decimal | DecimalJsLike | number | string | null
    description?: string | null
    userId?: string | null
    contactId?: string | null
  }

  export type TicketsUpdateWithoutLaneInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TagsUpdateManyWithoutTicketsNestedInput
    Users?: UsersUpdateOneWithoutTicketNestedInput
    Contacts?: ContactsUpdateOneWithoutTicketsNestedInput
  }

  export type TicketsUncheckedUpdateWithoutLaneInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TagsUncheckedUpdateManyWithoutTicketsNestedInput
  }

  export type TicketsUncheckedUpdateManyWithoutLaneInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TagsUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nane?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SubAccounts?: SubAccountsUpdateOneRequiredWithoutTagsNestedInput
  }

  export type TagsUncheckedUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nane?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subAccountId?: StringFieldUpdateOperationsInput | string
  }

  export type TagsUncheckedUpdateManyWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nane?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subAccountId?: StringFieldUpdateOperationsInput | string
  }

  export type TicketsUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    Lane?: LaneUpdateOneRequiredWithoutTicketsNestedInput
    Users?: UsersUpdateOneWithoutTicketNestedInput
    Contacts?: ContactsUpdateOneWithoutTicketsNestedInput
  }

  export type TicketsUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lineId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TicketsUncheckedUpdateManyWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lineId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FunelPagesCreateManyFunnelInput = {
    id?: string
    name: string
    pathName?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    visits?: number
    content?: string | null
    order: number
    previewImage: string
  }

  export type ClassNameCreateManyFunnelInput = {
    id?: string
    name: string
    color: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customData?: string | null
  }

  export type FunelPagesUpdateWithoutFunnelInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pathName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visits?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    previewImage?: StringFieldUpdateOperationsInput | string
  }

  export type FunelPagesUncheckedUpdateWithoutFunnelInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pathName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visits?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    previewImage?: StringFieldUpdateOperationsInput | string
  }

  export type FunelPagesUncheckedUpdateManyWithoutFunnelInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    pathName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visits?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    previewImage?: StringFieldUpdateOperationsInput | string
  }

  export type ClassNameUpdateWithoutFunnelInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customData?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClassNameUncheckedUpdateWithoutFunnelInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customData?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClassNameUncheckedUpdateManyWithoutFunnelInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customData?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}